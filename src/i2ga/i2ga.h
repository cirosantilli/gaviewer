
/*
Gaigen 1.0, Copyright (c) 2001-2010, University of Amsterdam

Copying, use and development for education and research purposes 
permitted as long as this license is not removed from the files.

All rights for commercial use reserved; for more information
contact Daniel Fontijne (fontijne@science.uva.nl)

This software is unsupported.
*/
/*
Header file i2ga.h, generated by Gaigen 1.0 on Mon Mar 22 19:10:50 2010
*/
#ifndef _i2ga_H_
#define _i2ga_H_

#include <stdio.h>
#include <stdlib.h>

// undefine all definitions possibly made in other gaigen header file
// This is important when multiple algebras are used in the same application
#undef GAIM_PRODUCT_GP
#undef GAIM_PRODUCT_HIP
#undef GAIM_PRODUCT_MHIP
#undef GAIM_PRODUCT_LCONT
#undef GAIM_PRODUCT_RCONT
#undef GAIM_PRODUCT_OP
#undef GAIM_PRODUCT_SCP
#undef GAIM_PRODUCT_GPEM
#undef GAIM_PRODUCT_LCEM
#undef GAIM_PRODUCT_SCPEM
#undef GAIM_PRODUCT_IGP
#undef GAIM_PRODUCT_GP_EM
#undef GAIM_PRODUCT_LCONT_EM
#undef GAIM_PRODUCT_OM
#undef GAIM_FUNCTION_GRADEINVOLUTION
#undef GAIM_FUNCTION_REVERSE
#undef GAIM_FUNCTION_NEGATE
#undef GAIM_FUNCTION_ADD
#undef GAIM_FUNCTION_SUBSTRACT
#undef GAIM_FUNCTION_NORM_A
#undef GAIM_FUNCTION_NORMALIZE
#undef GAIM_FUNCTION_TAKEGRADE
#undef GAIM_FUNCTION_VERSORINVERSE
#undef GAIM_FUNCTION_GENERALINVERSE
#undef GAIM_FUNCTION_SPINORPRODUCT
#undef GAIM_FUNCTION_CLIFFORDCONJUGATE
#undef GAIM_FUNCTION_LOUNESTOINVERSE
#undef GAIM_FUNCTION_HIGHESTGRADE
#undef GAIM_FUNCTION_GRADE
#undef GAIM_FUNCTION_OUTERMORPHISM
#undef GAIM_FUNCTION_PROJECT
#undef GAIM_FUNCTION_MEETJOIN
#undef GAIM_FUNCTION_RANDOM
#undef GAIM_FUNCTION_RECIPROCALFRAME
#undef GAIM_FUNCTION_PROFILE
#undef GAIM_FUNCTION_FACTOR
#undef GAIM_FUNCTION_FASTTEMPVAR
#undef GAIM_FUNCTION_FASTDUAL
#undef GAIM_FUNCTION_MULTIVECTORTYPE
#undef GAIM_FUNCTION_PARSESTRING
#undef GAIM_FUNCTION_NAMESPACE
#undef GAIM_FUNCTION_USINGNAMESPACE
#undef GAIM_FUNCTION_UNDEFINED
#undef GAIM_FUNCTION_UNDEFINED
#undef GAIM_FUNCTION_UNDEFINED
#undef GAIM_FUNCTION_UNDEFINED
#undef GAIM_INVERSEPSEUDOSCALAR
#undef GAIM_PSEUDOSCALAR
#undef GAIM_FLOAT
#undef GAIM_DOUBLE
#undef GAIM_CLASSNAME
#undef GAIM_OM_CLASSNAME
#undef GAIM_CONSTRUCTOR_1_COOR
#undef GAIM_CONSTRUCTOR_2_COOR
#undef GAIM_CONSTRUCTOR_3_COOR
#undef GAIM_CONSTRUCTOR_4_COOR
#undef GAIM_CONSTRUCTOR_5_COOR
#undef GAIM_CONSTRUCTOR_6_COOR
#undef GAIM_CONSTRUCTOR_7_COOR
#undef GAIM_CONSTRUCTOR_8_COOR

// what functions/products are implemented (used by superclass):
#define GAIM_PRODUCT_GP
#define GAIM_PRODUCT_IGP
#define GAIM_PRODUCT_GP_EM gpem
#define GAIM_PRODUCT_HIP
#define GAIM_PRODUCT_MHIP
#define GAIM_PRODUCT_LCONT
#define GAIM_PRODUCT_LCONT_EM lcem
#define GAIM_PRODUCT_RCONT
#define GAIM_PRODUCT_OP
#define GAIM_PRODUCT_SCP
#define GAIM_PRODUCT_GPEM
#define GAIM_PRODUCT_LCEM
#define GAIM_PRODUCT_SCPEM
#define GAIM_PRODUCT_OM
#define GAIM_FUNCTION_GRADEINVOLUTION
#define GAIM_FUNCTION_REVERSE
#define GAIM_FUNCTION_NEGATE
#define GAIM_FUNCTION_ADD
#define GAIM_FUNCTION_SUBSTRACT
#define GAIM_FUNCTION_NORM_A
#define GAIM_FUNCTION_NORMALIZE
#define GAIM_FUNCTION_TAKEGRADE
#define GAIM_FUNCTION_VERSORINVERSE
#define GAIM_FUNCTION_GENERALINVERSE
#define GAIM_FUNCTION_CLIFFORDCONJUGATE
#define GAIM_FUNCTION_HIGHESTGRADE
#define GAIM_FUNCTION_GRADE
#define GAIM_FUNCTION_OUTERMORPHISM
#define GAIM_FUNCTION_PROJECT
#define GAIM_FUNCTION_MEETJOIN
#define GAIM_FUNCTION_RANDOM
#define GAIM_FUNCTION_RECIPROCALFRAME
#define GAIM_FUNCTION_FACTOR
#define GAIM_FUNCTION_FASTTEMPVAR
#define GAIM_FUNCTION_FASTDUAL
#define GAIM_FUNCTION_MULTIVECTORTYPE
#define GAIM_FUNCTION_PARSESTRING
#define GAIM_INVERSEPSEUDOSCALAR i2gai::Ii
#define GAIM_PSEUDOSCALAR i2gai::I
#define GAIM_FLOAT double
#define GAIM_DOUBLE
#define GAIM_CLASSNAME i2gai
#define GAIM_OM_CLASSNAME i2gai_om

#define GAIM_CONSTRUCTOR_1_COOR
#define GAIM_CONSTRUCTOR_6_COOR

/* grade macros */
#ifndef GRADE0
#define GRADE0 (1 << 0)
#endif
#ifndef GRADE1
#define GRADE1 (1 << 1)
#endif
#ifndef GRADE2
#define GRADE2 (1 << 2)
#endif
#ifndef GRADE3
#define GRADE3 (1 << 3)
#endif
#ifndef GRADE4
#define GRADE4 (1 << 4)
#endif
#ifndef GRADE5
#define GRADE5 (1 << 5)
#endif
#ifndef GRADE6
#define GRADE6 (1 << 6)
#endif

/* coordinate macros */
#define I2GA_S 0
#define I2GA_I 0
#define I2GA_E1 0
#define I2GA_E2 1
#define I2GA_NO 2
#define I2GA_NI 3
#define I2GA_GO 4
#define I2GA_GI 5
#define I2GA_E1_E2 0
#define I2GA_E1_NO 1
#define I2GA_E2_NO 2
#define I2GA_E1_NI 3
#define I2GA_E2_NI 4
#define I2GA_NO_NI 5
#define I2GA_E1_GO 6
#define I2GA_E2_GO 7
#define I2GA_NO_GO 8
#define I2GA_NI_GO 9
#define I2GA_E1_GI 10
#define I2GA_E2_GI 11
#define I2GA_NO_GI 12
#define I2GA_NI_GI 13
#define I2GA_GO_GI 14
#define I2GA_E1_E2_NO 0
#define I2GA_E1_E2_NI 1
#define I2GA_E1_NO_NI 2
#define I2GA_E2_NO_NI 3
#define I2GA_E1_E2_GO 4
#define I2GA_E1_NO_GO 5
#define I2GA_E2_NO_GO 6
#define I2GA_E1_NI_GO 7
#define I2GA_E2_NI_GO 8
#define I2GA_NO_NI_GO 9
#define I2GA_E1_E2_GI 10
#define I2GA_E1_NO_GI 11
#define I2GA_E2_NO_GI 12
#define I2GA_E1_NI_GI 13
#define I2GA_E2_NI_GI 14
#define I2GA_NO_NI_GI 15
#define I2GA_E1_GO_GI 16
#define I2GA_E2_GO_GI 17
#define I2GA_NO_GO_GI 18
#define I2GA_NI_GO_GI 19
#define I2GA_E1_E2_NO_NI 0
#define I2GA_E1_E2_NO_GO 1
#define I2GA_E1_E2_NI_GO 2
#define I2GA_E1_NO_NI_GO 3
#define I2GA_E2_NO_NI_GO 4
#define I2GA_E1_E2_NO_GI 5
#define I2GA_E1_E2_NI_GI 6
#define I2GA_E1_NO_NI_GI 7
#define I2GA_E2_NO_NI_GI 8
#define I2GA_E1_E2_GO_GI 9
#define I2GA_E1_NO_GO_GI 10
#define I2GA_E2_NO_GO_GI 11
#define I2GA_E1_NI_GO_GI 12
#define I2GA_E2_NI_GO_GI 13
#define I2GA_NO_NI_GO_GI 14
#define I2GA_E1_E2_NO_NI_GO 0
#define I2GA_E1_E2_NO_NI_GI 1
#define I2GA_E1_E2_NO_GO_GI 2
#define I2GA_E1_E2_NI_GO_GI 3
#define I2GA_E1_NO_NI_GO_GI 4
#define I2GA_E2_NO_NI_GO_GI 5

#define GA_BLADE 1 // (versor of a single grade)
#define GA_VERSOR  2 // versor (invertible product of vectors)
#define GA_MULTIVECTOR 3 // the most general type of multivector
extern const char *i2gai_typeNames[4];

// the layer 0 functions:
// layer 0 functions are always pure C, unless custom float class if used
extern "C" {

extern const int i2gai_omct[192];
extern const int *i2gai_bevt[7];
extern const int i2gai_newBevt[64];
extern char *i2gai_basisElementNames[64];
extern int i2gai_gradeSize[7];
extern int i2gai_mvSize[128];

/* optimized implementations of products with a result of zero: */
extern void i2gai_opt_zero_result(const double *a, const double *b, double *c);

/* optimized implementations of products: (to be compiled from .opt file) */
extern void i2gai_general_gp(const double *a[], const double *b[], double *c);
extern void i2gai_general_hip(const double *a[], const double *b[], double *c);
extern void i2gai_general_mhip(const double *a[], const double *b[], double *c);
extern void i2gai_general_lcont(const double *a[], const double *b[], double *c);
extern void i2gai_general_rcont(const double *a[], const double *b[], double *c);
extern void i2gai_general_op(const double *a[], const double *b[], double *c);
extern void i2gai_general_scp(const double *a[], const double *b[], double *c);
extern void i2gai_general_gpem(const double *a[], const double *b[], double *c);
extern void i2gai_general_lcem(const double *a[], const double *b[], double *c);
extern void i2gai_general_scpem(const double *a[], const double *b[], double *c);

/* mapping from grade usage -> index in fp table & the function pointer table */
typedef void (*i2gai_genFuncPtr)(const double *a[], const double *b[], double *c);
typedef void (*i2gai_optFuncPtr)(const double *a, const double *b, double *c);
extern const int i2gai_map_gp_a[];
extern const int i2gai_map_gp_b[];
extern /*const*/ i2gai_optFuncPtr i2gai_func_gp[]; /* pointers to optimized functions for doing 'gp' products */
extern const int i2gai_resultUsage_gp[]; /* grade & memory usage of results of 'gp' products */
extern const int i2gai_map_hip_a[];
extern const int i2gai_map_hip_b[];
extern /*const*/ i2gai_optFuncPtr i2gai_func_hip[]; /* pointers to optimized functions for doing 'hip' products */
extern const int i2gai_resultUsage_hip[]; /* grade & memory usage of results of 'hip' products */
extern const int i2gai_map_mhip_a[];
extern const int i2gai_map_mhip_b[];
extern /*const*/ i2gai_optFuncPtr i2gai_func_mhip[]; /* pointers to optimized functions for doing 'mhip' products */
extern const int i2gai_resultUsage_mhip[]; /* grade & memory usage of results of 'mhip' products */
extern const int i2gai_map_lcont_a[];
extern const int i2gai_map_lcont_b[];
extern /*const*/ i2gai_optFuncPtr i2gai_func_lcont[]; /* pointers to optimized functions for doing 'lcont' products */
extern const int i2gai_resultUsage_lcont[]; /* grade & memory usage of results of 'lcont' products */
extern const int i2gai_map_rcont_a[];
extern const int i2gai_map_rcont_b[];
extern /*const*/ i2gai_optFuncPtr i2gai_func_rcont[]; /* pointers to optimized functions for doing 'rcont' products */
extern const int i2gai_resultUsage_rcont[]; /* grade & memory usage of results of 'rcont' products */
extern const int i2gai_map_op_a[];
extern const int i2gai_map_op_b[];
extern /*const*/ i2gai_optFuncPtr i2gai_func_op[]; /* pointers to optimized functions for doing 'op' products */
extern const int i2gai_resultUsage_op[]; /* grade & memory usage of results of 'op' products */
extern const int i2gai_map_scp_a[];
extern const int i2gai_map_scp_b[];
extern /*const*/ i2gai_optFuncPtr i2gai_func_scp[]; /* pointers to optimized functions for doing 'scp' products */
extern const int i2gai_resultUsage_scp[]; /* grade & memory usage of results of 'scp' products */
extern const int i2gai_map_gpem_a[];
extern const int i2gai_map_gpem_b[];
extern /*const*/ i2gai_optFuncPtr i2gai_func_gpem[]; /* pointers to optimized functions for doing 'gpem' products */
extern const int i2gai_resultUsage_gpem[]; /* grade & memory usage of results of 'gpem' products */
extern const int i2gai_map_lcem_a[];
extern const int i2gai_map_lcem_b[];
extern /*const*/ i2gai_optFuncPtr i2gai_func_lcem[]; /* pointers to optimized functions for doing 'lcem' products */
extern const int i2gai_resultUsage_lcem[]; /* grade & memory usage of results of 'lcem' products */
extern const int i2gai_map_scpem_a[];
extern const int i2gai_map_scpem_b[];
extern /*const*/ i2gai_optFuncPtr i2gai_func_scpem[]; /* pointers to optimized functions for doing 'scpem' products */
extern const int i2gai_resultUsage_scpem[]; /* grade & memory usage of results of 'scpem' products */
extern void i2gai_opt_om_01x01(const double *a, const double *b, double *c);
extern void i2gai_opt_om_06x06(const double *a, const double *b, double *c);
extern void i2gai_opt_om_0Fx0F(const double *a, const double *b, double *c);
extern void i2gai_opt_om_14x14(const double *a, const double *b, double *c);

extern void i2gai_copy(double *dest, const double *src, int length);
extern void i2gai_null(double *dest, int length);
extern void i2gai_reverse(double *a[7]);
extern void i2gai_cliffordConjugate(double *a[7]);
extern void i2gai_involution(double *a[7]);
extern void i2gai_negate(double *dest, const double *src, int length);
extern void i2gai_addSameGradeUsage(double *c, const double *a, const double *b, int length);
extern void i2gai_add(const double *a[7], const double *b[7], double *c[7]);
extern void i2gai_subSameGradeUsage(double *c, const double *a, const double *b, int length);
extern void i2gai_sub(const double *a[7], const double *b[7], double *c[7]);
extern double i2gai_norm_a(const double a[], int nb);
// end of the layer 0 functions
} /* end of 'extern "C"' */


class i2gai_om;
class i2gai_be;
class i2ga_ben;
class i2ga;

class i2gai {
public:
	static i2gai e1;
	static i2gai e2;
	static i2gai no;
	static i2gai ni;
	static i2gai go;
	static i2gai gi;
	static i2gai *bv[6];
	static i2gai I;
	static i2gai Ii;

	static const int dim;
	static const int nbCoor;

	i2gai();
	i2gai(const i2gai &a);
	~i2gai();
	i2gai(int gradeUsage, const double *coordinates);
	i2gai(int grade, double c0);
	i2gai(int grade, double c0, double c1, double c2, double c3, double c4, double c5);
	i2gai(int grade, double c0, double c1, double c2, double c3, double c4, double c5, double c6, double c7, double c8, double c9, double c10, double c11, double c12, double c13, double c14);
	i2gai(int grade, double c0, double c1, double c2, double c3, double c4, double c5, double c6, double c7, double c8, double c9, double c10, double c11, double c12, double c13, double c14, double c15, double c16, double c17, double c18, double c19);

	void null();

	void set(int gradeUsage, const double *coordinates);
	void setScalar(const double coordinates[1]);
	void setVector(const double coordinates[6]);
	void set2Vector(const double coordinates[15]);
	void set3Vector(const double coordinates[20]);
	void set4Vector(const double coordinates[15]);
	void set5Vector(const double coordinates[6]);
	void set6Vector(const double coordinates[1]);
	int set(int grade, double c0);
	int set(int grade, double c0, double c1, double c2, double c3, double c4, double c5);
	int set(int grade, double c0, double c1, double c2, double c3, double c4, double c5, double c6, double c7, double c8, double c9, double c10, double c11, double c12, double c13, double c14);
	int set(int grade, double c0, double c1, double c2, double c3, double c4, double c5, double c6, double c7, double c8, double c9, double c10, double c11, double c12, double c13, double c14, double c15, double c16, double c17, double c18, double c19);
	inline int setScalar(double c0)
		{return set(GRADE0, c0);}
	inline int setVector(double c0, double c1, double c2, double c3, double c4, double c5)
		{return set(GRADE1, c0, c1, c2, c3, c4, c5);}
	inline int set2Vector(double c0, double c1, double c2, double c3, double c4, double c5, double c6, double c7, double c8, double c9, double c10, double c11, double c12, double c13, double c14)
		{return set(GRADE2, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14);}
	inline int set3Vector(double c0, double c1, double c2, double c3, double c4, double c5, double c6, double c7, double c8, double c9, double c10, double c11, double c12, double c13, double c14, double c15, double c16, double c17, double c18, double c19)
		{return set(GRADE3, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19);}
	inline int set4Vector(double c0, double c1, double c2, double c3, double c4, double c5, double c6, double c7, double c8, double c9, double c10, double c11, double c12, double c13, double c14)
		{return set(GRADE4, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14);}
	inline int set5Vector(double c0, double c1, double c2, double c3, double c4, double c5)
		{return set(GRADE5, c0, c1, c2, c3, c4, c5);}
	inline int set6Vector(double c0)
		{return set(GRADE6, c0);}

	inline double scalar() const {return((gradeUsage() & GRADE0) ? c[0] : (double)0.0);};

	const char *string(const char *prec = NULL) const;
	void print(const char *text = NULL, const char *prec = NULL) const;
	void fprint(FILE *F, const char *text = NULL, const char *prec = NULL) const;

	static const char *fpPrecision; // floating point precision (during printing)
	static const char *stringStartDelimiter, *stringEndDelimiter; // start and end delimiters of string
	static int setFPPrecision(const char *prec);
	static int setStringDelimiters(char start, char end);
	static int renameBasisVector(const char *oldName, const char *newName); // renames basis vector 'oldName' to 'newName'
	

	int usage; /* usage of grades/memory */
	inline int gradeUsage() const {return usage & 0x7f;}
	inline int memUsage() const {return (usage>>0x7) & 0x7f;}


	void gp(const i2gai &a, const i2gai &b);

	void hip(const i2gai &a, const i2gai &b);

	void mhip(const i2gai &a, const i2gai &b);

	void lcont(const i2gai &a, const i2gai &b);

	void rcont(const i2gai &a, const i2gai &b);

	void op(const i2gai &a, const i2gai &b);

	void op(double scalar, const i2gai &a);
	inline void op(const i2gai &a, double scalar) {op(scalar, a);};

	void scp(const i2gai &a, const i2gai &b);

	void gpem(const i2gai &a, const i2gai &b);

	void lcem(const i2gai &a, const i2gai &b);

	void scpem(const i2gai &a, const i2gai &b);
	void copy(const i2gai &a);
	void compress(double epsilon = 1e-14); // compresses (removes all grades which are 0) this multivector in place
	void reverse(const i2gai &a);
	void cliffordConjugate(const i2gai &a);
	void gradeInvolution(const i2gai &a);
	void negate(const i2gai &a);

	void add(const i2gai &a, const i2gai &b);
	void add(double scalar, const i2gai &b);
	inline void add(const i2gai &b, double scalar) {add(scalar, b);};

	void sub(const i2gai &a, const i2gai &b);
	void sub(double scalar, const i2gai &b);
	inline void sub(const i2gai &b, double scalar) {sub(scalar, b);};
	void takeGrade(const i2gai &a, int grade);

	int highestGrade(const i2gai &a, double epsilon = 1e-14);

	int grade() const; // return the grade of 'this', if 'this' is a homogeneous multivector; otherwise it returns -1
	int largestGrade() const; // return the grade with the largest norm_a
	int maxGrade() const; // return the maximum non zero grade of 'this', returns -1 if this = 0
	int versorInverse(const i2gai &a); // compute inverse, for versors only
	int generalInverse(const i2gai &a); // compute inverse, for general multivectors; uses gaussian elimination (slower and less stable than versorInverse)
	void om(const i2gai &a, const i2gai_om &om);
	void expand(double matrix[], const int table[]) const;
	double norm_a() const;
	double norm_b() const;
	double largestCoordinate() const;
	void normalize(const i2gai &a, int norm);

	int project(const i2gai &blade, const i2gai &a);
	int projectOntoVersor(const i2gai &versor, const i2gai &a);
	int reject(const i2gai &blade, const i2gai &a);

	int versorInverseEM(const i2gai &a);
	int projectEM(const i2gai &blade, const i2gai &a);

	int factor(i2gai factors[], int versor = 0) const;
	inline int factorVersor(i2gai factors[]) const {return factor(factors, 1);};

	int deltaProduct(const i2gai &a, const i2gai &b); // sets this to delta(a, b); returns the grade of the delta product
	int join(const i2gai &a, const i2gai &b, int algorithm = 1); // sets this to join(a, b); returns the grade of the join
	int meet(const i2gai &a, const i2gai &b, int algorithm = 1); // sets this to meet(a, b); returns the grade of the meet
protected:
	int joinAlg1(const i2gai &a, const i2gai &b, int ga, int gb, int gj);
	int joinAlg2(const i2gai &a, const i2gai &b, int ga, int gb, int gj);
public:

	inline int randomBlade(int grade, double scale) {return random(grade, scale, 0);}
	inline int randomVersor(int grade, double scale) {return random(grade, scale, 1);}
	int random(int grade, double scale, int versor);

	static int reciprocalFrame(i2gai f[], const i2gai e[], int nbVectors);

	int mvType(int *grade = NULL, double epsilon = 1e-14) const;

	int parseString(const char *str, const i2ga_ben *ben = NULL);

	const double *coordinates(int grade) const;
	inline double get_e1() const {
		return (gradeUsage() & GRADE1) ? c[i2gai_mvSize[gradeUsage() & 1] + 0] : (double)0.0;
	}
	inline double get_e2() const {
		return (gradeUsage() & GRADE1) ? c[i2gai_mvSize[gradeUsage() & 1] + 1] : (double)0.0;
	}
	inline double get_no() const {
		return (gradeUsage() & GRADE1) ? c[i2gai_mvSize[gradeUsage() & 1] + 2] : (double)0.0;
	}
	inline double get_ni() const {
		return (gradeUsage() & GRADE1) ? c[i2gai_mvSize[gradeUsage() & 1] + 3] : (double)0.0;
	}
	inline double get_go() const {
		return (gradeUsage() & GRADE1) ? c[i2gai_mvSize[gradeUsage() & 1] + 4] : (double)0.0;
	}
	inline double get_gi() const {
		return (gradeUsage() & GRADE1) ? c[i2gai_mvSize[gradeUsage() & 1] + 5] : (double)0.0;
	}
	inline double get_e1_e2() const {
		return (gradeUsage() & GRADE2) ? c[i2gai_mvSize[gradeUsage() & 3] + 0] : (double)0.0;
	}
	inline double get_e1_no() const {
		return (gradeUsage() & GRADE2) ? c[i2gai_mvSize[gradeUsage() & 3] + 1] : (double)0.0;
	}
	inline double get_e2_no() const {
		return (gradeUsage() & GRADE2) ? c[i2gai_mvSize[gradeUsage() & 3] + 2] : (double)0.0;
	}
	inline double get_e1_ni() const {
		return (gradeUsage() & GRADE2) ? c[i2gai_mvSize[gradeUsage() & 3] + 3] : (double)0.0;
	}
	inline double get_e2_ni() const {
		return (gradeUsage() & GRADE2) ? c[i2gai_mvSize[gradeUsage() & 3] + 4] : (double)0.0;
	}
	inline double get_no_ni() const {
		return (gradeUsage() & GRADE2) ? c[i2gai_mvSize[gradeUsage() & 3] + 5] : (double)0.0;
	}
	inline double get_e1_go() const {
		return (gradeUsage() & GRADE2) ? c[i2gai_mvSize[gradeUsage() & 3] + 6] : (double)0.0;
	}
	inline double get_e2_go() const {
		return (gradeUsage() & GRADE2) ? c[i2gai_mvSize[gradeUsage() & 3] + 7] : (double)0.0;
	}
	inline double get_no_go() const {
		return (gradeUsage() & GRADE2) ? c[i2gai_mvSize[gradeUsage() & 3] + 8] : (double)0.0;
	}
	inline double get_ni_go() const {
		return (gradeUsage() & GRADE2) ? c[i2gai_mvSize[gradeUsage() & 3] + 9] : (double)0.0;
	}
	inline double get_e1_gi() const {
		return (gradeUsage() & GRADE2) ? c[i2gai_mvSize[gradeUsage() & 3] + 10] : (double)0.0;
	}
	inline double get_e2_gi() const {
		return (gradeUsage() & GRADE2) ? c[i2gai_mvSize[gradeUsage() & 3] + 11] : (double)0.0;
	}
	inline double get_no_gi() const {
		return (gradeUsage() & GRADE2) ? c[i2gai_mvSize[gradeUsage() & 3] + 12] : (double)0.0;
	}
	inline double get_ni_gi() const {
		return (gradeUsage() & GRADE2) ? c[i2gai_mvSize[gradeUsage() & 3] + 13] : (double)0.0;
	}
	inline double get_go_gi() const {
		return (gradeUsage() & GRADE2) ? c[i2gai_mvSize[gradeUsage() & 3] + 14] : (double)0.0;
	}
	inline double get_e1_e2_no() const {
		return (gradeUsage() & GRADE3) ? c[i2gai_mvSize[gradeUsage() & 7] + 0] : (double)0.0;
	}
	inline double get_e1_e2_ni() const {
		return (gradeUsage() & GRADE3) ? c[i2gai_mvSize[gradeUsage() & 7] + 1] : (double)0.0;
	}
	inline double get_e1_no_ni() const {
		return (gradeUsage() & GRADE3) ? c[i2gai_mvSize[gradeUsage() & 7] + 2] : (double)0.0;
	}
	inline double get_e2_no_ni() const {
		return (gradeUsage() & GRADE3) ? c[i2gai_mvSize[gradeUsage() & 7] + 3] : (double)0.0;
	}
	inline double get_e1_e2_go() const {
		return (gradeUsage() & GRADE3) ? c[i2gai_mvSize[gradeUsage() & 7] + 4] : (double)0.0;
	}
	inline double get_e1_no_go() const {
		return (gradeUsage() & GRADE3) ? c[i2gai_mvSize[gradeUsage() & 7] + 5] : (double)0.0;
	}
	inline double get_e2_no_go() const {
		return (gradeUsage() & GRADE3) ? c[i2gai_mvSize[gradeUsage() & 7] + 6] : (double)0.0;
	}
	inline double get_e1_ni_go() const {
		return (gradeUsage() & GRADE3) ? c[i2gai_mvSize[gradeUsage() & 7] + 7] : (double)0.0;
	}
	inline double get_e2_ni_go() const {
		return (gradeUsage() & GRADE3) ? c[i2gai_mvSize[gradeUsage() & 7] + 8] : (double)0.0;
	}
	inline double get_no_ni_go() const {
		return (gradeUsage() & GRADE3) ? c[i2gai_mvSize[gradeUsage() & 7] + 9] : (double)0.0;
	}
	inline double get_e1_e2_gi() const {
		return (gradeUsage() & GRADE3) ? c[i2gai_mvSize[gradeUsage() & 7] + 10] : (double)0.0;
	}
	inline double get_e1_no_gi() const {
		return (gradeUsage() & GRADE3) ? c[i2gai_mvSize[gradeUsage() & 7] + 11] : (double)0.0;
	}
	inline double get_e2_no_gi() const {
		return (gradeUsage() & GRADE3) ? c[i2gai_mvSize[gradeUsage() & 7] + 12] : (double)0.0;
	}
	inline double get_e1_ni_gi() const {
		return (gradeUsage() & GRADE3) ? c[i2gai_mvSize[gradeUsage() & 7] + 13] : (double)0.0;
	}
	inline double get_e2_ni_gi() const {
		return (gradeUsage() & GRADE3) ? c[i2gai_mvSize[gradeUsage() & 7] + 14] : (double)0.0;
	}
	inline double get_no_ni_gi() const {
		return (gradeUsage() & GRADE3) ? c[i2gai_mvSize[gradeUsage() & 7] + 15] : (double)0.0;
	}
	inline double get_e1_go_gi() const {
		return (gradeUsage() & GRADE3) ? c[i2gai_mvSize[gradeUsage() & 7] + 16] : (double)0.0;
	}
	inline double get_e2_go_gi() const {
		return (gradeUsage() & GRADE3) ? c[i2gai_mvSize[gradeUsage() & 7] + 17] : (double)0.0;
	}
	inline double get_no_go_gi() const {
		return (gradeUsage() & GRADE3) ? c[i2gai_mvSize[gradeUsage() & 7] + 18] : (double)0.0;
	}
	inline double get_ni_go_gi() const {
		return (gradeUsage() & GRADE3) ? c[i2gai_mvSize[gradeUsage() & 7] + 19] : (double)0.0;
	}
	inline double get_e1_e2_no_ni() const {
		return (gradeUsage() & GRADE4) ? c[i2gai_mvSize[gradeUsage() & 15] + 0] : (double)0.0;
	}
	inline double get_e1_e2_no_go() const {
		return (gradeUsage() & GRADE4) ? c[i2gai_mvSize[gradeUsage() & 15] + 1] : (double)0.0;
	}
	inline double get_e1_e2_ni_go() const {
		return (gradeUsage() & GRADE4) ? c[i2gai_mvSize[gradeUsage() & 15] + 2] : (double)0.0;
	}
	inline double get_e1_no_ni_go() const {
		return (gradeUsage() & GRADE4) ? c[i2gai_mvSize[gradeUsage() & 15] + 3] : (double)0.0;
	}
	inline double get_e2_no_ni_go() const {
		return (gradeUsage() & GRADE4) ? c[i2gai_mvSize[gradeUsage() & 15] + 4] : (double)0.0;
	}
	inline double get_e1_e2_no_gi() const {
		return (gradeUsage() & GRADE4) ? c[i2gai_mvSize[gradeUsage() & 15] + 5] : (double)0.0;
	}
	inline double get_e1_e2_ni_gi() const {
		return (gradeUsage() & GRADE4) ? c[i2gai_mvSize[gradeUsage() & 15] + 6] : (double)0.0;
	}
	inline double get_e1_no_ni_gi() const {
		return (gradeUsage() & GRADE4) ? c[i2gai_mvSize[gradeUsage() & 15] + 7] : (double)0.0;
	}
	inline double get_e2_no_ni_gi() const {
		return (gradeUsage() & GRADE4) ? c[i2gai_mvSize[gradeUsage() & 15] + 8] : (double)0.0;
	}
	inline double get_e1_e2_go_gi() const {
		return (gradeUsage() & GRADE4) ? c[i2gai_mvSize[gradeUsage() & 15] + 9] : (double)0.0;
	}
	inline double get_e1_no_go_gi() const {
		return (gradeUsage() & GRADE4) ? c[i2gai_mvSize[gradeUsage() & 15] + 10] : (double)0.0;
	}
	inline double get_e2_no_go_gi() const {
		return (gradeUsage() & GRADE4) ? c[i2gai_mvSize[gradeUsage() & 15] + 11] : (double)0.0;
	}
	inline double get_e1_ni_go_gi() const {
		return (gradeUsage() & GRADE4) ? c[i2gai_mvSize[gradeUsage() & 15] + 12] : (double)0.0;
	}
	inline double get_e2_ni_go_gi() const {
		return (gradeUsage() & GRADE4) ? c[i2gai_mvSize[gradeUsage() & 15] + 13] : (double)0.0;
	}
	inline double get_no_ni_go_gi() const {
		return (gradeUsage() & GRADE4) ? c[i2gai_mvSize[gradeUsage() & 15] + 14] : (double)0.0;
	}
	inline double get_e1_e2_no_ni_go() const {
		return (gradeUsage() & GRADE5) ? c[i2gai_mvSize[gradeUsage() & 31] + 0] : (double)0.0;
	}
	inline double get_e1_e2_no_ni_gi() const {
		return (gradeUsage() & GRADE5) ? c[i2gai_mvSize[gradeUsage() & 31] + 1] : (double)0.0;
	}
	inline double get_e1_e2_no_go_gi() const {
		return (gradeUsage() & GRADE5) ? c[i2gai_mvSize[gradeUsage() & 31] + 2] : (double)0.0;
	}
	inline double get_e1_e2_ni_go_gi() const {
		return (gradeUsage() & GRADE5) ? c[i2gai_mvSize[gradeUsage() & 31] + 3] : (double)0.0;
	}
	inline double get_e1_no_ni_go_gi() const {
		return (gradeUsage() & GRADE5) ? c[i2gai_mvSize[gradeUsage() & 31] + 4] : (double)0.0;
	}
	inline double get_e2_no_ni_go_gi() const {
		return (gradeUsage() & GRADE5) ? c[i2gai_mvSize[gradeUsage() & 31] + 5] : (double)0.0;
	}
	inline double get_e1_e2_no_ni_go_gi() const {
		return (gradeUsage() & GRADE6) ? c[i2gai_mvSize[gradeUsage() & 63] + 0] : (double)0.0;
	}

	int fastDual(const i2gai &a);

	double c[64];
protected:
	inline void setUsage(int u) {usage = u;}

	void expand(const double *pa[7]) const;
	void expand2i(const i2gai &b, double const *pa[7], double const *pb[7]) const;
	void expand(const i2gai &b, double const *pa[7], double const *pb[7]) const;
	void compress(double coordinates[64]);

public:
	static int resetProfile();
	static int printProfile(float threshold = 2.0);
	static int saveProfile(const char *filename = NULL);

	inline operator i2ga &() const {return *((i2ga*)this);}
};

class i2gai_om {
public:
	i2gai_om();
	~i2gai_om();

//	i2gai_om(const i2gai &Sp); (todo) -> initSpinor2
	i2gai_om(const i2gai vectorImages[6]);
	i2gai_om(const i2gai *vectorImages[6]);
	int initOuterMorphism(const i2gai vectorImages[6]);
	int initOuterMorphism(const i2gai *vectorImages[6]);
	int initSpinor2(const i2gai &Sp);

	double c[924];

protected:
	int computeBE(i2gai be[64], int beComputed[64], int idx);

};

// undocumented internal class
class i2gai_be {
public:
	i2gai_be(const char *name, const i2gai &mv);
	~i2gai_be();

	void initToNothing();

	int compareName(const char *name) const ; // returns true if 'm_name == name'

	char *m_name;
	i2gai m_mv;
};

class i2ga_ben {
public:
	i2ga_ben();
	i2ga_ben(char startDelimiter, char endDelimiter);
	~i2ga_ben();

	int addName(const char *name, const i2gai &mv);
	int removeName(const char *name);
	int lookupName(const char *name, i2gai &mv) const ;
	int setDelimiters(char startDelimiter, char endDelimiter);
	int removeAll();
	int setDefaults();

	char m_startDelimiter, m_endDelimiter;

protected:
	void initToNothing();

	int m_nbBen;
	i2gai_be **m_ben;

};

#ifdef CLASSNAME
#undef CLASSNAME
#endif
#define CLASSNAME i2ga

#ifdef CLASSNAME_OM
#undef CLASSNAME_OM
#endif
#define CLASSNAME_OM i2ga_om


//Merging /usr/local/include/gaigen/gaigenhl.h into generated code:

// DO NOT TRY TO INCLUDE DIRECTLY.
// IT IS MEANT TO BE INCLUDED BY GENERATED CODE!

/*
 *
 * Gaigen, Copyright (c) 2001-2004, University of Amsterdam
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *      * Redistributions of source code must retain the above copyright
 *        notice, this list of conditions and the following disclaimer.
 *      * Redistributions in binary form must reproduce the above copyright
 *        notice, this list of conditions and the following disclaimer in
 *        the documentation and/or other materials provided with the
 *        distribution.
 *      * Neither the name of the University of Amsterdam nor the names of its
 *        contributors may be used to endorse or promote products derived
 *        from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
 * CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
 * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 */

#include <stdlib.h>

#define MV_MAX_TEMP 256
#define GA_MAX_DIM 8

// temporary variable allocation determines the type of return variable (reference or copy) and...
// the type of temporary variables used inside some functions
#ifdef GAIM_FUNCTION_FASTTEMPVAR
#define GAIM_RETURN_TYPE CLASSNAME&
#define GAIM_RETURN_VAR(name) CLASSNAME &name = CLASSNAME::getTemp();
#else // slow, but safe, temporary variables
#define GAIM_RETURN_TYPE CLASSNAME
#define GAIM_RETURN_VAR(name) CLASSNAME name;
#endif // GAIM_FUNCTION_FASTTEMPVAR

//#define CLASSNAME_OM GAIM_OM_CLASSNAME

class CLASSNAME;
#ifdef GAIM_PRODUCT_OM
class CLASSNAME_OM;
#endif // GAIM_PRODUCT_OM

// if no namespace is used, set these #define to nothing
#ifndef CLASSNAME_NS
#define CLASSNAME_NS
#endif // CLASSNAME_NS
#ifndef CLASSNAME_NS_DSC
#define CLASSNAME_NS_DSC
#endif // CLASSNAME_NS_DSC

#ifndef INV_MUL_SCALAR
#define INV_MUL_SCALAR
inline GAIM_FLOAT invScalar(const GAIM_FLOAT &b) {return ((GAIM_FLOAT)1.0 / b);}
inline GAIM_FLOAT mulScalar(const GAIM_FLOAT a, const GAIM_FLOAT b) {return (a * b);}
#endif // INV_MUL_SCALAR

#ifdef GAIM_NAMESPACE
namespace CLASSNAME_NS {
#endif // GAIM_NAMESPACE


#ifdef GAIM_PRODUCT_GP
extern GAIM_RETURN_TYPE gp(const CLASSNAME &a, const CLASSNAME &b);
extern GAIM_RETURN_TYPE gp(GAIM_FLOAT a, const CLASSNAME &b);
inline GAIM_RETURN_TYPE gp(const CLASSNAME &a, GAIM_FLOAT b);
inline GAIM_RETURN_TYPE operator*(GAIM_FLOAT a, const CLASSNAME &b) ;
#endif // GAIM_PRODUCT_GP

#ifdef GAIM_PRODUCT_GP_EM
extern GAIM_RETURN_TYPE gpem (const CLASSNAME &a, const CLASSNAME &b);
extern GAIM_RETURN_TYPE gpem (GAIM_FLOAT a, const CLASSNAME &b);
inline GAIM_RETURN_TYPE gpem (const CLASSNAME &a, GAIM_FLOAT b);
#endif // GAIM_PRODUCT_GP_EM

#ifdef GAIM_PRODUCT_IGP
inline GAIM_RETURN_TYPE igp(const CLASSNAME &a, const CLASSNAME &b);
inline GAIM_RETURN_TYPE igp(const CLASSNAME &a, GAIM_FLOAT b);
inline GAIM_RETURN_TYPE igp(GAIM_FLOAT a, const CLASSNAME &b);
inline GAIM_RETURN_TYPE operator/(GAIM_FLOAT a, const CLASSNAME &b);
#endif // GAIM_PRODUCT_IGP

#ifdef GAIM_PRODUCT_OP
extern GAIM_RETURN_TYPE op(const CLASSNAME &a, const CLASSNAME &b);
extern GAIM_RETURN_TYPE op(GAIM_FLOAT a, const CLASSNAME &b);
inline GAIM_RETURN_TYPE op(const CLASSNAME &a, GAIM_FLOAT b);
inline GAIM_RETURN_TYPE operator^(GAIM_FLOAT a, const CLASSNAME &b);
#endif // GAIM_PRODUCT_OP

#ifdef GAIM_PRODUCT_LCONT
extern GAIM_RETURN_TYPE lcont(const CLASSNAME &a, const CLASSNAME &b);
#endif // GAIM_PRODUCT_LCONT

#ifdef GAIM_PRODUCT_LCONT_EM
extern GAIM_RETURN_TYPE lcem(const CLASSNAME &a, const CLASSNAME &b);
#endif // GAIM_PRODUCT_LCONT_EM

#ifdef GAIM_PRODUCT_RCONT
extern GAIM_RETURN_TYPE rcont(const CLASSNAME &a, const CLASSNAME &b);
#endif // GAIM_PRODUCT_RCONT

#ifdef GAIM_PRODUCT_SCP
extern GAIM_RETURN_TYPE scp(const CLASSNAME &a, const CLASSNAME &b);
extern GAIM_RETURN_TYPE scp(GAIM_FLOAT b, const CLASSNAME &a);
inline GAIM_RETURN_TYPE scp(const CLASSNAME &a, GAIM_FLOAT b);
inline GAIM_RETURN_TYPE operator%(GAIM_FLOAT a, const CLASSNAME &b);
#endif // GAIM_PRODUCT_SCP

#ifdef GAIM_PRODUCT_HIP
extern GAIM_RETURN_TYPE hip(const CLASSNAME &a, const CLASSNAME &b);
extern GAIM_RETURN_TYPE hip(GAIM_FLOAT b, const CLASSNAME &a);
extern GAIM_RETURN_TYPE hip(const CLASSNAME &a, GAIM_FLOAT b);
#endif // GAIM_PRODUCT_HIP

#ifdef GAIM_PRODUCT_MHIP
extern GAIM_RETURN_TYPE mhip(const CLASSNAME &a, const CLASSNAME &b);
extern GAIM_RETURN_TYPE mhip(GAIM_FLOAT b, const CLASSNAME &a);
extern GAIM_RETURN_TYPE mhip(const CLASSNAME &a, GAIM_FLOAT b);
#endif // GAIM_PRODUCT_MHIP

#ifdef GAIM_FUNCTION_MEETJOIN
extern GAIM_RETURN_TYPE meet(const CLASSNAME &a, const CLASSNAME &b);
extern GAIM_RETURN_TYPE join(const CLASSNAME &a, const CLASSNAME &b);
#endif // GAIM_FUNCTION_MEETJOIN


#ifdef GAIM_FUNCTION_ADD
extern GAIM_RETURN_TYPE add(const CLASSNAME &a, const CLASSNAME &b);
extern GAIM_RETURN_TYPE add(GAIM_FLOAT a, const CLASSNAME &b);
inline GAIM_RETURN_TYPE add(const CLASSNAME &a, GAIM_FLOAT b);
inline GAIM_RETURN_TYPE operator+(GAIM_FLOAT a, const CLASSNAME &b);
#endif // GAIM_FUNCTION_ADD

#ifdef GAIM_FUNCTION_SUBSTRACT
extern GAIM_RETURN_TYPE sub(const CLASSNAME &a, const CLASSNAME &b);
extern GAIM_RETURN_TYPE sub(GAIM_FLOAT a, const CLASSNAME &b);
inline GAIM_RETURN_TYPE sub(const CLASSNAME &a, GAIM_FLOAT b);
inline GAIM_RETURN_TYPE operator-(GAIM_FLOAT a, const CLASSNAME &b);
#endif // GAIM_FUNCTION_SUBSTRACT


#ifdef GAIM_FUNCTION_NEGATE
extern GAIM_RETURN_TYPE negate(const CLASSNAME &a);
#endif //GAIM_FUNCTION_NEGATE

// casting operator from GAIM_CLASSNAME -> CLASSNAME
//operator CLASSNAME &(GAIM_CLASSNAME &a) const {return *((CLASSNAME*)&a);}
//operator int &(GAIM_CLASSNAME &a) const {return 0;}

class CLASSNAME : public GAIM_CLASSNAME {
public:
	CLASSNAME();
//	CLASSNAME(const GAIM_CLASSNAME &a)  : GAIM_CLASSNAME (a) {};
	CLASSNAME(GAIM_FLOAT scalar) : GAIM_CLASSNAME (GRADE0, scalar) {};
	CLASSNAME(int gradeUsage, const GAIM_FLOAT *coordinates) : GAIM_CLASSNAME (gradeUsage, coordinates) {};

	// casting operator from GAIM_CLASSNAME -> CLASSNAME
	//operator GAIM_CLASSNAME () const {return scalar();}


#ifdef GAIM_CONSTRUCTOR_1_COOR
	CLASSNAME(int gradeUsage, GAIM_FLOAT c0) : GAIM_CLASSNAME (gradeUsage, c0) {};
#endif
#ifdef GAIM_CONSTRUCTOR_2_COOR
	CLASSNAME(int gradeUsage, GAIM_FLOAT c0, GAIM_FLOAT c1) : GAIM_CLASSNAME (gradeUsage, c0, c1) {};
#endif
#ifdef GAIM_CONSTRUCTOR_3_COOR
	CLASSNAME(int gradeUsage, GAIM_FLOAT c0, GAIM_FLOAT c1, GAIM_FLOAT c2) : GAIM_CLASSNAME (gradeUsage, c0, c1, c2) {};
#endif
#ifdef GAIM_CONSTRUCTOR_4_COOR
	CLASSNAME(int gradeUsage, GAIM_FLOAT c0, GAIM_FLOAT c1, GAIM_FLOAT c2, GAIM_FLOAT c3) : GAIM_CLASSNAME (gradeUsage, c0, c1, c2, c3) {};
#endif
#ifdef GAIM_CONSTRUCTOR_5_COOR
	CLASSNAME(int gradeUsage, GAIM_FLOAT c0, GAIM_FLOAT c1, GAIM_FLOAT c2, GAIM_FLOAT c3, GAIM_FLOAT c4) : GAIM_CLASSNAME (gradeUsage, c0, c1, c2, c3, c4) {};
#endif
#ifdef GAIM_CONSTRUCTOR_6_COOR
	CLASSNAME(int gradeUsage, GAIM_FLOAT c0, GAIM_FLOAT c1, GAIM_FLOAT c2, GAIM_FLOAT c3, GAIM_FLOAT c4, GAIM_FLOAT c5) : GAIM_CLASSNAME (gradeUsage, c0, c1, c2, c3, c4, c5) {};
#endif
#ifdef GAIM_CONSTRUCTOR_7_COOR
	CLASSNAME(int gradeUsage, GAIM_FLOAT c0, GAIM_FLOAT c1, GAIM_FLOAT c2, GAIM_FLOAT c3, GAIM_FLOAT c4, GAIM_FLOAT c5, GAIM_FLOAT c6) : GAIM_CLASSNAME (gradeUsage, c0, c1, c2, c3, c4, c5, c6) {};
#endif
#ifdef GAIM_CONSTRUCTOR_8_COOR
	CLASSNAME(int gradeUsage, GAIM_FLOAT c0, GAIM_FLOAT c1, GAIM_FLOAT c2, GAIM_FLOAT c3, GAIM_FLOAT c4, GAIM_FLOAT c5, GAIM_FLOAT c6, GAIM_FLOAT c7) : GAIM_CLASSNAME (gradeUsage, c0, c1, c2, c3, c4, c5, c6, c7) {};
#endif
// maybe implement it like this:
//	CLASSNAME(int gradeUsage, ...) {};

	CLASSNAME(const CLASSNAME &a) : GAIM_CLASSNAME (a) {};
	~CLASSNAME();

	GAIM_RETURN_TYPE operator=(const CLASSNAME &a);
	GAIM_RETURN_TYPE operator=(GAIM_FLOAT f);

	// take grade
#ifdef GAIM_FUNCTION_TAKEGRADE
	GAIM_RETURN_TYPE grade(int g) const;
	inline GAIM_RETURN_TYPE operator()(int g) const {return grade(g);}
#endif // GAIM_FUNCTION_TAKEGRADE

#ifdef GAIM_FUNCTION_GRADE
	inline int grade() const {return ((GAIM_CLASSNAME*)this)->grade();}
#endif // GAIM_FUNCTION_GRADE

	inline const GAIM_FLOAT *operator[](int g) const {return coordinates(g);}

#ifdef GAIM_FUNCTION_REVERSE
	GAIM_RETURN_TYPE operator~() const;
	inline GAIM_RETURN_TYPE reverse() const {return operator~();};
#endif // GAIM_FUNCTION_REVERSE

#ifdef GAIM_FUNCTION_CLIFFORDCONJUGATE
	GAIM_RETURN_TYPE operator--() const;
	inline GAIM_RETURN_TYPE operator--(int) const {return operator--();};
	inline GAIM_RETURN_TYPE cliffordConjugate() const {return operator--();};
#endif // GAIM_FUNCTION_CLIFFORDCONJUGATE

#ifdef GAIM_FUNCTION_GRADEINVOLUTION
	GAIM_RETURN_TYPE operator++() const;
	inline GAIM_RETURN_TYPE operator++(int) const {return operator++();};
	inline GAIM_RETURN_TYPE gradeInvolution() const {return operator++();};
#endif // GAIM_FUNCTION_GRADEINVOLUTION

#ifdef GAIM_FUNCTION_NORMALIZE
	GAIM_RETURN_TYPE normal(int norm = 1) const;
#endif // GAIM_FUNCTION_NORMALIZE

	// inverse
#ifdef GAIM_FUNCTION_VERSORINVERSE
	inline void inverse(const CLASSNAME &a) {versorInverse(a);};
#elif defined(GAIM_FUNCTION_LOUNESTOINVERSE)
	inline void inverse(const CLASSNAME &a) {lounestoInverse(a);};
#elif defined(GAIM_FUNCTION_GENERALINVERSE)
	inline void inverse(const CLASSNAME &a) {generalInverse(a);};
#endif

#ifdef GAIM_FUNCTION_VERSORINVERSE
	inline void versorInverse(const CLASSNAME &a) {GAIM_CLASSNAME::versorInverse(a);};
	GAIM_RETURN_TYPE versorInverse() const;
#endif
#ifdef GAIM_FUNCTION_LOUNESTOINVERSE
	inline void lounestoInverse(const CLASSNAME &a) {GAIM_CLASSNAME::lounestoInverse(a);};
	GAIM_RETURN_TYPE lounestoInverse() const;
#endif
#ifdef GAIM_FUNCTION_GENERALINVERSE
	inline void generalInverse(const CLASSNAME &a) {GAIM_CLASSNAME::generalInverse(a);};
	GAIM_RETURN_TYPE generalInverse() const;
#endif

	// geometric product
#ifdef GAIM_PRODUCT_GP
	GAIM_RETURN_TYPE exp(int order = 9) const ;

	GAIM_RETURN_TYPE operator*=(const CLASSNAME &a);
	GAIM_RETURN_TYPE operator*=(GAIM_FLOAT a);
	inline GAIM_RETURN_TYPE operator*(const CLASSNAME &a) const {return CLASSNAME_NS ::gp(*this, a);}
	inline GAIM_RETURN_TYPE operator*(GAIM_FLOAT a) const {return CLASSNAME_NS ::gp(*this, a);}
#ifndef GAIM_FUNCTION_FASTDUAL
	GAIM_RETURN_TYPE dual() const;
#endif // GAIM_FUNCTION_FASTDUAL
#endif // GAIM_PRODUCT_GP

#ifdef GAIM_FUNCTION_FASTDUAL
	GAIM_RETURN_TYPE fastDual() const;
	inline GAIM_RETURN_TYPE dual() const {return fastDual();};
#endif // GAIM_FUNCTION_FASTDUAL

	// inverse geometric product
#ifdef GAIM_PRODUCT_IGP
	GAIM_RETURN_TYPE inverse() const;
	inline GAIM_RETURN_TYPE operator!() const {return inverse();}

	inline GAIM_RETURN_TYPE operator/(const CLASSNAME &a) const {return CLASSNAME_NS ::igp(*this, a);}
	inline GAIM_RETURN_TYPE operator/(GAIM_FLOAT a) const {return CLASSNAME_NS ::igp(*this, a);}
	GAIM_RETURN_TYPE operator/=(const CLASSNAME &a);
	GAIM_RETURN_TYPE operator/=(GAIM_FLOAT a);
#endif // GAIM_PRODUCT_IGP

	// scalar product
#ifdef GAIM_PRODUCT_SCP
	inline GAIM_RETURN_TYPE operator%(const CLASSNAME &a) const {return CLASSNAME_NS ::scp(*this, a);};
	inline GAIM_RETURN_TYPE operator%(GAIM_FLOAT a) const {return CLASSNAME_NS ::scp(a, *this);};
	GAIM_RETURN_TYPE operator%=(const CLASSNAME &a);
	GAIM_RETURN_TYPE operator%=(GAIM_FLOAT a);
#endif // GAIM_PRODUCT_SCP

	// left contraction
#ifdef GAIM_PRODUCT_LCONT
	inline GAIM_RETURN_TYPE operator<<(const CLASSNAME &a) const {return CLASSNAME_NS ::lcont(*this, a);}
	GAIM_RETURN_TYPE operator<<=(const CLASSNAME &a);
#endif // GAIM_PRODUCT_LCONT

	// right contraction
#ifdef GAIM_PRODUCT_RCONT
	inline GAIM_RETURN_TYPE operator>>(const CLASSNAME &a) const {return CLASSNAME_NS ::rcont(*this, a);}
	GAIM_RETURN_TYPE operator>>=(const CLASSNAME &a);
#endif // GAIM_PRODUCT_RCONT

	// outer product
#ifdef GAIM_PRODUCT_OP
	inline GAIM_RETURN_TYPE operator^(const CLASSNAME &a) const {return CLASSNAME_NS ::op(*this, a);}
	inline GAIM_RETURN_TYPE operator^(GAIM_FLOAT a) const {return CLASSNAME_NS ::op(a, *this);}
	GAIM_RETURN_TYPE operator^=(const CLASSNAME &a);
	GAIM_RETURN_TYPE operator^=(GAIM_FLOAT a);
#endif // GAIM_PRODUCT_OP

#ifdef GAIM_FUNCTION_MEETJOIN
	inline GAIM_RETURN_TYPE operator&(const CLASSNAME &a) const {return CLASSNAME_NS ::meet(*this, a);}
	inline GAIM_RETURN_TYPE operator|(const CLASSNAME &a) const {return CLASSNAME_NS ::join(*this, a);}
#endif // GAIM_FUNCTION_MEETJOIN

#ifdef GAIM_FUNCTION_ADD
	inline GAIM_RETURN_TYPE operator+(const CLASSNAME &a) const {return CLASSNAME_NS ::add(*this, a);}
	inline GAIM_RETURN_TYPE operator+(GAIM_FLOAT a) const {return CLASSNAME_NS ::add(a, *this);}
	GAIM_RETURN_TYPE operator+=(const CLASSNAME &a);
	GAIM_RETURN_TYPE operator+=(GAIM_FLOAT a);
#endif // GAIM_FUNCTION_ADD

#ifdef GAIM_FUNCTION_SUBSTRACT
	inline GAIM_RETURN_TYPE operator-(const CLASSNAME &a) const {return CLASSNAME_NS ::sub(*this, a);}
	inline GAIM_RETURN_TYPE operator-(GAIM_FLOAT a) const {return CLASSNAME_NS ::add(-a, *this);}
	GAIM_RETURN_TYPE operator-=(const CLASSNAME &a);
	GAIM_RETURN_TYPE operator-=(GAIM_FLOAT a);
#endif // GAIM_FUNCTION_SUBSTRACT

#ifdef GAIM_FUNCTION_NEGATE
	inline GAIM_RETURN_TYPE operator-() const {return CLASSNAME_NS ::negate(*this);}
	inline GAIM_RETURN_TYPE negate() const {return CLASSNAME_NS ::negate(*this);}
#endif //GAIM_FUNCTION_NEGATE


#ifdef GAIM_FUNCTION_FACTOR
	inline int factor(CLASSNAME f[], int versor = 0) const {return GAIM_CLASSNAME::factor((GAIM_CLASSNAME*)f, versor);};
	inline int factorVersor(CLASSNAME f[]) const {return CLASSNAME::factor(f, 1);};
#endif //GAIM_FUNCTION_FACTOR


#ifdef GAIM_FUNCTION_FASTTEMPVAR
	static CLASSNAME &getTemp();	// returns a temporary variable; don't use expressions which require more than MV_MAX_TEMP temporaries
#endif // GAIM_FUNCTION_FASTTEMPVAR

#ifdef GAIM_DRAWING
	/* ********************** drawing ************************/
/* ****************** under construction ************************/

	/*
	sets the color of objects
	*/
	static int setColor(int grade, int idx, float r, float g, float b, float a = 1.0f);
	static int setColor(int grade, int idx, float *rgba);
	static int setColor(int grade, int idx, const char *name, float alpha = 1.0f);

	/*
	Sets the frame used for drawing OpenGL images.
	Specifies to what vectors the x, y and z axis in OpenGL correspond.
	Returns 0 on success, -1 on failure (i.e. when x^y^z is too small)
	*/
	static unsigned int m_Draw3DMode;
	static int setDraw3DMode(unsigned int mode);
	static int setDraw3DFrame(CLASSNAME &x, CLASSNAME &y, CLASSNAME &z);
	void draw3DProject(float *p);
	void draw3DBlade();

protected:
	static CLASSNAME m_Draw3DFrame[3], m_Draw3DTriVector, m_Draw3DTriVectorInverse;
	void draw3DVector();
	void draw3DBiVector();
	void draw3DTriVector();
	void drawBandedDisc(int halfSphere = 0, int colorSkip = 0, int ori = 1);
	static int m_drawLightOn;
	static void drawEnableLighting();
	static void drawDisableLighting();
	static int m_drawCullFaceOn;
	static void drawEnableCullFace();
	static void drawDisableCullFace();

	static float m_color[4][2][4];
	void setColor(int grade, int idx); 	// automatically sets material properties as well



public:
/* ****************** under construction ************************/
	/* ********************** drawing ************************/
#endif //GAIM_DRAWING


	// implicit 'cast to GAIM_FLOATing point' operator
//	operator GAIM_FLOAT () const {return scalar();}

};

#ifdef GAIM_PRODUCT_GP
inline GAIM_RETURN_TYPE gp(const CLASSNAME &a, GAIM_FLOAT b) {return gp(b, a);}
inline GAIM_RETURN_TYPE operator*(GAIM_FLOAT a, const CLASSNAME &b) {return gp(a, b);}
inline GAIM_RETURN_TYPE gp(const GAIM_CLASSNAME &a, GAIM_FLOAT b) {return gp((const CLASSNAME&)a, b);}
inline GAIM_RETURN_TYPE gp(const GAIM_CLASSNAME &a, const CLASSNAME &b) {return gp((const CLASSNAME&)a, b);}
inline GAIM_RETURN_TYPE operator*(const GAIM_CLASSNAME &a, GAIM_FLOAT b) {return gp((const CLASSNAME&)a, b);}
inline GAIM_RETURN_TYPE operator*(const GAIM_CLASSNAME &a, const CLASSNAME &b) {return gp((const CLASSNAME&)a, b);}
#endif // GAIM_PRODUCT_GP

#ifdef GAIM_PRODUCT_GP_EM
inline GAIM_RETURN_TYPE gpem (const CLASSNAME &a, GAIM_FLOAT b) {return GAIM_PRODUCT_GP_EM (b, a);}
inline GAIM_RETURN_TYPE gpem (const GAIM_CLASSNAME &a, GAIM_FLOAT b) {return GAIM_PRODUCT_GP_EM ((const CLASSNAME&)a, b);}
inline GAIM_RETURN_TYPE gpem (const GAIM_CLASSNAME &a, const CLASSNAME &b) {return GAIM_PRODUCT_GP_EM ((const CLASSNAME&)a, b);}
#endif // GAIM_PRODUCT_GP_EM

#ifdef GAIM_PRODUCT_OP
inline GAIM_RETURN_TYPE op(const CLASSNAME &a, GAIM_FLOAT b) {return op(b, a);}
inline GAIM_RETURN_TYPE operator^(GAIM_FLOAT a, const CLASSNAME &b) {return op(a, b);}
inline GAIM_RETURN_TYPE op(const GAIM_CLASSNAME &a, GAIM_FLOAT b) {return op((const CLASSNAME&)a, b);}
inline GAIM_RETURN_TYPE op(const GAIM_CLASSNAME &a, const CLASSNAME &b) {return op((const CLASSNAME&)a, b);}
inline GAIM_RETURN_TYPE operator^(const GAIM_CLASSNAME &a, GAIM_FLOAT b) {return op((const CLASSNAME&)a, b);}
inline GAIM_RETURN_TYPE operator^(const GAIM_CLASSNAME &a, const CLASSNAME &b) {return op((const CLASSNAME&)a, b);}
#endif // GAIM_PRODUCT_OP

#ifdef GAIM_PRODUCT_LCONT
inline GAIM_RETURN_TYPE lcont(const GAIM_CLASSNAME &a, const CLASSNAME &b) {return lcont((const CLASSNAME&)a, b);}
inline GAIM_RETURN_TYPE operator<<(const GAIM_CLASSNAME &a, const CLASSNAME &b) {return lcont((const CLASSNAME&)a, b);}
#endif // GAIM_PRODUCT_LCONT

#ifdef GAIM_PRODUCT_LCONT_EM
inline GAIM_RETURN_TYPE lcem(const GAIM_CLASSNAME &a, const CLASSNAME &b) {return lcem((const CLASSNAME&)a, b);}
#endif // GAIM_PRODUCT_LCONT_EM

#ifdef GAIM_PRODUCT_RCONT
inline GAIM_RETURN_TYPE rcont(const GAIM_CLASSNAME &a, const CLASSNAME &b) {return rcont((const CLASSNAME&)a, b);}
inline GAIM_RETURN_TYPE operator>>(const GAIM_CLASSNAME &a, const CLASSNAME &b) {return rcont((const CLASSNAME&)a, b);}
#endif // GAIM_PRODUCT_RCONT

#ifdef GAIM_PRODUCT_SCP
inline GAIM_RETURN_TYPE scp(const CLASSNAME &a, GAIM_FLOAT b)  {return scp(b, a);}
inline GAIM_RETURN_TYPE operator%(GAIM_FLOAT a, const CLASSNAME &b) {return scp(b, a);}
inline GAIM_RETURN_TYPE scp(const GAIM_CLASSNAME &a, GAIM_FLOAT b)  {return scp(b, (const CLASSNAME&)a);}
inline GAIM_RETURN_TYPE scp(const GAIM_CLASSNAME &a, const CLASSNAME &b)  {return scp((const CLASSNAME&)a, b);}
inline GAIM_RETURN_TYPE  operator%(const GAIM_CLASSNAME &a, GAIM_FLOAT b)  {return scp(b, (const CLASSNAME&)a);}
inline GAIM_RETURN_TYPE  operator%(const GAIM_CLASSNAME &a, const CLASSNAME &b)  {return scp((const CLASSNAME&)a, b);}
#endif // GAIM_PRODUCT_SCP

#ifdef GAIM_PRODUCT_HIP
inline GAIM_RETURN_TYPE hip(const GAIM_CLASSNAME &a, const CLASSNAME &b) {return hip((const CLASSNAME&)a, b);}
inline GAIM_RETURN_TYPE hip(const GAIM_CLASSNAME &a, GAIM_FLOAT b) {return hip((const CLASSNAME&)a, b);}
#endif // GAIM_PRODUCT_HIP

#ifdef GAIM_PRODUCT_MHIP
inline GAIM_RETURN_TYPE mhip(const GAIM_CLASSNAME &a, const CLASSNAME &b) {return mhip((const CLASSNAME&)a, b);}
inline GAIM_RETURN_TYPE mhip(const GAIM_CLASSNAME &a, GAIM_FLOAT b) {return mhip((const CLASSNAME&)a, b);}
#endif // GAIM_PRODUCT_MHIP

#ifdef GAIM_FUNCTION_MEETJOIN
inline GAIM_RETURN_TYPE meet(const GAIM_CLASSNAME &a, const CLASSNAME &b) {return meet((const CLASSNAME&)a, b);}
inline GAIM_RETURN_TYPE join(const GAIM_CLASSNAME &a, const CLASSNAME &b) {return join((const CLASSNAME&)a, b);}
//inline GAIM_RETURN_TYPE operator&(const GAIM_CLASSNAME &a, const CLASSNAME &b) const {return meet((const CLASSNAME&)a, b);}
//inline GAIM_RETURN_TYPE operator|(const GAIM_CLASSNAME &a, const CLASSNAME &b) const {return join((const CLASSNAME&)a, b);}
#endif // GAIM_FUNCTION_MEETJOIN

#ifdef GAIM_FUNCTION_ADD
inline GAIM_RETURN_TYPE add(const CLASSNAME &a, GAIM_FLOAT b) {return add(b, a);}
inline GAIM_RETURN_TYPE operator+(GAIM_FLOAT a, const CLASSNAME &b) {return add(a, b);}
inline GAIM_RETURN_TYPE add(const GAIM_CLASSNAME &a, GAIM_FLOAT b) {return add(b, (const CLASSNAME&)a);}
inline GAIM_RETURN_TYPE operator+(GAIM_FLOAT a, const GAIM_CLASSNAME &b) {return add(a, (const CLASSNAME&)b);}
inline GAIM_RETURN_TYPE operator+(const GAIM_CLASSNAME &a, const CLASSNAME &b) {return add((const CLASSNAME&)a, b);}
#endif // GAIM_FUNCTION_ADD

#ifdef GAIM_FUNCTION_SUBSTRACT
inline GAIM_RETURN_TYPE sub(const CLASSNAME &a, GAIM_FLOAT b) {return add(-b, a);}
inline GAIM_RETURN_TYPE operator-(GAIM_FLOAT a, const CLASSNAME &b) {return sub(a, b);}
inline GAIM_RETURN_TYPE sub(const GAIM_CLASSNAME &a, GAIM_FLOAT b) {return add(-b, (const CLASSNAME&)a);}
inline GAIM_RETURN_TYPE operator-(GAIM_FLOAT a, const GAIM_CLASSNAME &b) {return sub(a, (const CLASSNAME&)b);}
inline GAIM_RETURN_TYPE operator-(const GAIM_CLASSNAME &a, const CLASSNAME &b) {return sub((const CLASSNAME&)a, b);}
#endif // GAIM_FUNCTION_SUBSTRACT


#ifdef GAIM_FUNCTION_NEGATE
GAIM_RETURN_TYPE negate(const CLASSNAME &a);
inline GAIM_RETURN_TYPE negate(const GAIM_CLASSNAME &a) {return negate((const CLASSNAME&)a);}
#endif //GAIM_FUNCTION_NEGATE

#ifdef GAIM_PRODUCT_IGP
inline GAIM_RETURN_TYPE igp(const CLASSNAME &a, const CLASSNAME &b) {return gp(a, b.inverse());}
inline GAIM_RETURN_TYPE igp(const CLASSNAME &a, GAIM_FLOAT b) {return op(invScalar(b), a);}
inline GAIM_RETURN_TYPE igp(GAIM_FLOAT a, const CLASSNAME &b) {return op(a, b.inverse());}
inline GAIM_RETURN_TYPE operator/(GAIM_FLOAT a, const CLASSNAME &b) {return igp(a, b);}
inline GAIM_RETURN_TYPE igp(const GAIM_CLASSNAME &a, const CLASSNAME &b) {return gp((const CLASSNAME&)a, b.inverse());}
inline GAIM_RETURN_TYPE igp(const GAIM_CLASSNAME &a, GAIM_FLOAT b) {return op(invScalar(b), (const CLASSNAME&)a);}
#endif // GAIM_PRODUCT_IGP

#ifdef GAIM_PRODUCT_OM
class CLASSNAME_OM : public GAIM_OM_CLASSNAME {
public:
	CLASSNAME_OM() : GAIM_OM_CLASSNAME() {};
	~CLASSNAME_OM() {};

	CLASSNAME_OM(const CLASSNAME vectorImages[3]) : GAIM_OM_CLASSNAME(vectorImages) {};
	CLASSNAME_OM(const CLASSNAME *vectorImages[3]);
	CLASSNAME_OM(const CLASSNAME &spinor);

	// init using a spinor to create the vector images
	int initSpinor(const CLASSNAME &spinor);

	// init using images under the outermorphism of the basis vectors
	inline int initVectorImages(const CLASSNAME vectorImages[3]) {
		return GAIM_OM_CLASSNAME::initOuterMorphism(vectorImages);
	}
	inline int initVectorImages(const CLASSNAME *vectorImages[3]) {
		return GAIM_OM_CLASSNAME::initOuterMorphism((const GAIM_CLASSNAME**)vectorImages);
	}
};

GAIM_RETURN_TYPE om(const CLASSNAME_OM &L, const CLASSNAME &A);
inline GAIM_RETURN_TYPE operator*(const CLASSNAME_OM &L, const CLASSNAME &A) {return om(L, A);}

#ifdef GAIM_NAMESPACE
}
#endif // GAIM_NAMESPACE

#endif // GAIM_PRODUCT_OM
#endif /* _i2gai_H_*/
