
/*
Gaigen 1.0, Copyright (c) 2001-2010, University of Amsterdam

Copying, use and development for education and research purposes 
permitted as long as this license is not removed from the files.

All rights for commercial use reserved; for more information
contact Daniel Fontijne (fontijne@science.uva.nl)

This software is unsupported.
*/
/*
Source file i2ga.cpp, generated by Gaigen 1.0 on Mon Mar 22 19:10:50 2010
*/




#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <math.h>
#include "i2ga.h"
#ifdef WIN32
#pragma warning( disable : 4996)
#endif

const int i2gai_map_gp_a[128] = {
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  
};
const int i2gai_map_gp_b[128] = {
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  
};
/*const*/ i2gai_optFuncPtr i2gai_func_gp[1 * 1] = { /* pointers to optimized functions for doing 'gp' */
	(i2gai_optFuncPtr)i2gai_general_gp 
};
const int i2gai_resultUsage_gp[1 * 1]  = { /* grade & memory usage of results of 'gp' */
-1  
};

const int i2gai_map_hip_a[128] = {
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  
};
const int i2gai_map_hip_b[128] = {
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  
};
/*const*/ i2gai_optFuncPtr i2gai_func_hip[1 * 1] = { /* pointers to optimized functions for doing 'hip' */
	(i2gai_optFuncPtr)i2gai_general_hip 
};
const int i2gai_resultUsage_hip[1 * 1]  = { /* grade & memory usage of results of 'hip' */
-1  
};

const int i2gai_map_mhip_a[128] = {
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  
};
const int i2gai_map_mhip_b[128] = {
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  
};
/*const*/ i2gai_optFuncPtr i2gai_func_mhip[1 * 1] = { /* pointers to optimized functions for doing 'mhip' */
	(i2gai_optFuncPtr)i2gai_general_mhip 
};
const int i2gai_resultUsage_mhip[1 * 1]  = { /* grade & memory usage of results of 'mhip' */
-1  
};

const int i2gai_map_lcont_a[128] = {
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  
};
const int i2gai_map_lcont_b[128] = {
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  
};
/*const*/ i2gai_optFuncPtr i2gai_func_lcont[1 * 1] = { /* pointers to optimized functions for doing 'lcont' */
	(i2gai_optFuncPtr)i2gai_general_lcont 
};
const int i2gai_resultUsage_lcont[1 * 1]  = { /* grade & memory usage of results of 'lcont' */
-1  
};

const int i2gai_map_rcont_a[128] = {
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  
};
const int i2gai_map_rcont_b[128] = {
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  
};
/*const*/ i2gai_optFuncPtr i2gai_func_rcont[1 * 1] = { /* pointers to optimized functions for doing 'rcont' */
	(i2gai_optFuncPtr)i2gai_general_rcont 
};
const int i2gai_resultUsage_rcont[1 * 1]  = { /* grade & memory usage of results of 'rcont' */
-1  
};

const int i2gai_map_op_a[128] = {
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  
};
const int i2gai_map_op_b[128] = {
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  
};
/*const*/ i2gai_optFuncPtr i2gai_func_op[1 * 1] = { /* pointers to optimized functions for doing 'op' */
	(i2gai_optFuncPtr)i2gai_general_op 
};
const int i2gai_resultUsage_op[1 * 1]  = { /* grade & memory usage of results of 'op' */
-1  
};

const int i2gai_map_scp_a[128] = {
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  
};
const int i2gai_map_scp_b[128] = {
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  
};
/*const*/ i2gai_optFuncPtr i2gai_func_scp[1 * 1] = { /* pointers to optimized functions for doing 'scp' */
	(i2gai_optFuncPtr)i2gai_general_scp 
};
const int i2gai_resultUsage_scp[1 * 1]  = { /* grade & memory usage of results of 'scp' */
-1  
};

const int i2gai_map_gpem_a[128] = {
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  
};
const int i2gai_map_gpem_b[128] = {
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  
};
/*const*/ i2gai_optFuncPtr i2gai_func_gpem[1 * 1] = { /* pointers to optimized functions for doing 'gpem' */
	(i2gai_optFuncPtr)i2gai_general_gpem 
};
const int i2gai_resultUsage_gpem[1 * 1]  = { /* grade & memory usage of results of 'gpem' */
-1  
};

const int i2gai_map_lcem_a[128] = {
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  
};
const int i2gai_map_lcem_b[128] = {
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  
};
/*const*/ i2gai_optFuncPtr i2gai_func_lcem[1 * 1] = { /* pointers to optimized functions for doing 'lcem' */
	(i2gai_optFuncPtr)i2gai_general_lcem 
};
const int i2gai_resultUsage_lcem[1 * 1]  = { /* grade & memory usage of results of 'lcem' */
-1  
};

const int i2gai_map_scpem_a[128] = {
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  
};
const int i2gai_map_scpem_b[128] = {
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  
};
/*const*/ i2gai_optFuncPtr i2gai_func_scpem[1 * 1] = { /* pointers to optimized functions for doing 'scpem' */
	(i2gai_optFuncPtr)i2gai_general_scpem 
};
const int i2gai_resultUsage_scpem[1 * 1]  = { /* grade & memory usage of results of 'scpem' */
-1  
};

int i2gai_expansionTable_gp[] = {
196, 202, 203, 208, 212, 215, 221, 222, 227, 228, 233, 236, 240, 246, 247, 252, 259, 264, 265, 271, 275, 278, 283, 284, 289, 290, 296, 299, 303, 308, 309, 315, 326, 337, 338, 339, 340, 352, 353, 354, 355, 356, 357, 367, 368, 369, 370, 378, 389, 397, 398, 399, 400, 410, 411, 412, 413, 414, 415, 427, 428, 429, 430, 441, 516, 522, 523, 528, 532, 535, 541, 542, 547, 548, 553, 556, 560, 566, 567, 572, 580, 586, 587, 592, 596, 599, 605, 606, 611, 612, 617, 620, 624, 630, 631, 636, 643, 648, 649, 655, 659, 662, 667, 668, 673, 674, 680, 683, 687, 692, 693, 699, 707, 712, 713, 719, 723, 726, 731, 732, 737, 738, 744, 747, 751, 756, 757, 763, 838, 849, 850, 851, 852, 864, 865, 866, 867, 868, 869, 879, 880, 881, 882, 890, 902, 913, 914, 915, 916, 928, 929, 930, 931, 932, 933, 943, 944, 945, 946, 954, 964, 966, 970, 971, 976, 977, 978, 979, 980, 983, 989, 990, 992, 993, 994, 995, 996, 997, 1001, 1004, 1007, 1008, 1009, 1010, 1014, 1015, 1018, 1020, 1027, 1030, 1032, 1033, 1039, 1041, 1042, 1043, 1044, 1046, 1051, 1052, 1056, 1057, 1058, 1059, 1060, 1061, 1064, 1067, 1071, 1072, 1073, 1074, 1076, 1077, 1082, 1083, 1093, 1101, 1102, 1103, 1104, 1114, 1115, 1116, 1117, 1118, 1119, 1131, 1132, 1133, 1134, 1145, 1157, 1165, 1166, 1167, 1168, 1178, 1179, 1180, 1181, 1182, 1183, 1195, 1196, 1197, 1198, 1209, 1220, 1221, 1226, 1227, 1229, 1230, 1231, 1232, 1236, 1239, 1242, 1243, 1244, 1245, 1246, 1247, 1251, 1252, 1257, 1259, 1260, 1261, 1262, 1264, 1270, 1271, 1273, 1276, 1283, 1285, 1288, 1289, 1293, 1294, 1295, 1296, 1299, 1302, 1306, 1307, 1308, 1309, 1310, 1311, 1313, 1314, 1320, 1323, 1324, 1325, 1326, 1327, 1332, 1333, 1337, 1339, 1412, 1418, 1419, 1424, 1428, 1431, 1437, 1438, 1443, 1444, 1449, 1452, 1456, 1462, 1463, 1468, 1475, 1480, 1481, 1487, 1491, 1494, 1499, 1500, 1505, 1506, 1512, 1515, 1519, 1524, 1525, 1531, 1670, 1681, 1682, 1683, 1684, 1696, 1697, 1698, 1699, 1700, 1701, 1711, 1712, 1713, 1714, 1722, 1732, 1734, 1738, 1739, 1744, 1745, 1746, 1747, 1748, 1751, 1757, 1758, 1760, 1761, 1762, 1763, 1764, 1765, 1769, 1772, 1775, 1776, 1777, 1778, 1782, 1783, 1786, 1788, 1796, 1798, 1802, 1803, 1808, 1809, 1810, 1811, 1812, 1815, 1821, 1822, 1824, 1825, 1826, 1827, 1828, 1829, 1833, 1836, 1839, 1840, 1841, 1842, 1846, 1847, 1850, 1852, 1859, 1862, 1864, 1865, 1871, 1873, 1874, 1875, 1876, 1878, 1883, 1884, 1888, 1889, 1890, 1891, 1892, 1893, 1896, 1899, 1903, 1904, 1905, 1906, 1908, 1909, 1914, 1915, 1923, 1926, 1928, 1929, 1935, 1937, 1938, 1939, 1940, 1942, 1947, 1948, 1952, 1953, 1954, 1955, 1956, 1957, 1960, 1963, 1967, 1968, 1969, 1970, 1972, 1973, 1978, 1979, 1990, 2001, 2002, 2003, 2004, 2016, 2017, 2018, 2019, 2020, 2021, 2031, 2032, 2033, 2034, 2042, 2053, 2061, 2062, 2063, 2064, 2074, 2075, 2076, 2077, 2078, 2079, 2091, 2092, 2093, 2094, 2105, 2116, 2117, 2122, 2123, 2125, 2126, 2127, 2128, 2132, 2135, 2138, 2139, 2140, 2141, 2142, 2143, 2147, 2148, 2153, 2155, 2156, 2157, 2158, 2160, 2166, 2167, 2169, 2172, 2180, 2181, 2186, 2187, 2189, 2190, 2191, 2192, 2196, 2199, 2202, 2203, 2204, 2205, 2206, 2207, 2211, 2212, 2217, 2219, 2220, 2221, 2222, 2224, 2230, 2231, 2233, 2236, 2243, 2245, 2248, 2249, 2253, 2254, 2255, 2256, 2259, 2262, 2266, 2267, 2268, 2269, 2270, 2271, 2273, 2274, 2280, 2283, 2284, 2285, 2286, 2287, 2292, 2293, 2297, 2299, 2307, 2309, 2312, 2313, 2317, 2318, 2319, 2320, 2323, 2326, 2330, 2331, 2332, 2333, 2334, 2335, 2337, 2338, 2344, 2347, 2348, 2349, 2350, 2351, 2356, 2357, 2361, 2363, 2373, 2381, 2382, 2383, 2384, 2394, 2395, 2396, 2397, 2398, 2399, 2411, 2412, 2413, 2414, 2425, 2564, 2570, 2571, 2576, 2580, 2583, 2589, 2590, 2595, 2596, 2601, 2604, 2608, 2614, 2615, 2620, 2627, 2632, 2633, 2639, 2643, 2646, 2651, 2652, 2657, 2658, 2664, 2667, 2671, 2676, 2677, 2683, 2756, 2758, 2762, 2763, 2768, 2769, 2770, 2771, 2772, 2775, 2781, 2782, 2784, 2785, 2786, 2787, 2788, 2789, 2793, 2796, 2799, 2800, 2801, 2802, 2806, 2807, 2810, 2812, 2819, 2822, 2824, 2825, 2831, 2833, 2834, 2835, 2836, 2838, 2843, 2844, 2848, 2849, 2850, 2851, 2852, 2853, 2856, 2859, 2863, 2864, 2865, 2866, 2868, 2869, 2874, 2875, 2886, 2897, 2898, 2899, 2900, 2912, 2913, 2914, 2915, 2916, 2917, 2927, 2928, 2929, 2930, 2938, 2950, 2961, 2962, 2963, 2964, 2976, 2977, 2978, 2979, 2980, 2981, 2991, 2992, 2993, 2994, 3002, 3012, 3013, 3018, 3019, 3021, 3022, 3023, 3024, 3028, 3031, 3034, 3035, 3036, 3037, 3038, 3039, 3043, 3044, 3049, 3051, 3052, 3053, 3054, 3056, 3062, 3063, 3065, 3068, 3075, 3077, 3080, 3081, 3085, 3086, 3087, 3088, 3091, 3094, 3098, 3099, 3100, 3101, 3102, 3103, 3105, 3106, 3112, 3115, 3116, 3117, 3118, 3119, 3124, 3125, 3129, 3131, 3141, 3149, 3150, 3151, 3152, 3162, 3163, 3164, 3165, 3166, 3167, 3179, 3180, 3181, 3182, 3193, 3205, 3213, 3214, 3215, 3216, 3226, 3227, 3228, 3229, 3230, 3231, 3243, 3244, 3245, 3246, 3257, 3332, 3338, 3339, 3344, 3348, 3351, 3357, 3358, 3363, 3364, 3369, 3372, 3376, 3382, 3383, 3388, 3396, 3402, 3403, 3408, 3412, 3415, 3421, 3422, 3427, 3428, 3433, 3436, 3440, 3446, 3447, 3452, 3459, 3464, 3465, 3471, 3475, 3478, 3483, 3484, 3489, 3490, 3496, 3499, 3503, 3508, 3509, 3515, 3523, 3528, 3529, 3535, 3539, 3542, 3547, 3548, 3553, 3554, 3560, 3563, 3567, 3572, 3573, 3579, 3654, 3665, 3666, 3667, 3668, 3680, 3681, 3682, 3683, 3684, 3685, 3695, 3696, 3697, 3698, 3706, 3717, 3725, 3726, 3727, 3728, 3738, 3739, 3740, 3741, 3742, 3743, 3755, 3756, 3757, 3758, 3769, 3780, 3786, 3787, 3792, 3796, 3799, 3805, 3806, 3811, 3812, 3817, 3820, 3824, 3830, 3831, 3836, 3843, 3848, 3849, 3855, 3859, 3862, 3867, 3868, 3873, 3874, 3880, 3883, 3887, 3892, 3893, 3899, -1,
0, 65, 130, 195, 260, 325, 390, 455, 520, 585, 650, 715, 780, 845, 910, 975, 1040, 1105, 1170, 1235, 1300, 1365, 1430, 1495, 1560, 1625, 1690, 1755, 1820, 1885, 1950, 2015, 2080, 2145, 2210, 2275, 2340, 2405, 2470, 2535, 2600, 2665, 2730, 2795, 2860, 2925, 2990, 3055, 3120, 3185, 3250, 3315, 3380, 3445, 3510, 3575, 3640, 3705, 3770, 3835, 3900, 3965, 4030, 4095, -1,
1, 64, 135, 200, 266, 333, 401, 450, 515, 598, 644, 727, 792, 837, 922, 987, 1053, 1094, 1184, 1249, 1315, 1382, 1417, 1483, 1548, 1642, 1678, 1743, 1835, 1872, 1964, 2029, 2066, 2131, 2223, 2260, 2352, 2417, 2453, 2547, 2612, 2678, 2713, 2780, 2846, 2911, 3001, 3042, 3108, 3173, 3258, 3303, 3368, 3451, 3497, 3580, 3645, 3694, 3762, 3829, 3895, 3960, 4031, 4094, -1,
2, 4167, 128, 201, 267, 334, 402, 4545, 4630, 579, 4759, 708, 793, 4954, 901, 988, 1054, 5216, 1158, 1250, 1316, 1383, 5512, 5578, 5674, 1612, 5773, 5867, 1807, 5996, 1936, 2030, 6161, 6255, 2195, 6384, 2324, 2418, 6579, 2517, 2613, 2679, 6808, 6875, 6941, 7033, 2975, 7137, 7203, 7290, 3237, 7398, 7483, 3432, 7612, 3561, 3646, 7789, 7857, 7924, 7990, 8063, 4024, 8189, -1,
4100, 74, 139, 192, 204, 4432, 4500, 4567, 4609, 4632, 4674, 4697, 772, 861, 926, 965, 991, 1123, 1188, 1222, 1253, 5481, 1415, 1450, 5642, 5707, 5804, 5837, 5869, 5902, 5934, 2000, 6192, 6225, 6257, 6290, 6322, 2388, 2486, 2551, 2581, 2616, 2711, 2778, 2809, 7005, 7070, 3040, 3066, 7267, 7332, 7420, 7462, 7485, 7527, 7550, 3625, 3692, 3760, 3827, 3839, 8054, 8119, 4092, -1,
4099, 72, 137, 256, 4364, 4431, 4499, 4566, 4737, 664, 4802, 729, 4867, 859, 924, 1029, 5151, 1121, 1186, 1286, 5413, 5480, 1479, 5610, 1544, 1609, 5803, 5965, 1901, 6030, 1966, 6095, 6191, 6353, 2289, 6418, 2354, 6483, 2484, 2549, 2645, 6776, 6806, 2842, 6969, 2907, 2972, 3104, 7226, 3169, 3234, 7419, 7590, 3517, 7655, 3582, 7720, 7787, 7855, 3891, 7999, 3956, 4021, 8187, -1,
4102, 81, 146, 211, 276, 320, 341, 4576, 4641, 4706, 4771, 4836, 4901, 4929, 4966, 4994, 5031, 5059, 5096, 5124, 5161, 1350, 1455, 1520, 1585, 1650, 1671, 1715, 1736, 1780, 1801, 1845, 1866, 1910, 1931, 1975, 1996, 2040, 6545, 6610, 6675, 6740, 6842, 6870, 6907, 6935, 6972, 7000, 7037, 7065, 7102, 3296, 3361, 3426, 3491, 3556, 3621, 3690, 3711, 7919, 7984, 8049, 8114, 4090, -1,
4101, 77, 142, 207, 272, 384, 4501, 4570, 4635, 4700, 4765, 4830, 4895, 5185, 1126, 5250, 1191, 5315, 1256, 5380, 1321, 5445, 1451, 1516, 1581, 1646, 2055, 6195, 2120, 6260, 2185, 6325, 2250, 6390, 2315, 6455, 2380, 6520, 2445, 2510, 2575, 2640, 6841, 7126, 3067, 7191, 3132, 7256, 3197, 7321, 3262, 7386, 7451, 7516, 7581, 7646, 7711, 3754, 7871, 3819, 3884, 3949, 4014, 8185, -1,
4103, 66, 4225, 4310, 4375, 4442, 4512, 448, 521, 4680, 651, 4810, 4906, 846, 5005, 5099, 5164, 1106, 5265, 5359, 5424, 5491, 1411, 1476, 1561, 5720, 1669, 1756, 5915, 1886, 6045, 6137, 2054, 2146, 6305, 2276, 6435, 6522, 2471, 6630, 6715, 6780, 2700, 2767, 2832, 2926, 7085, 3027, 3092, 3186, 7345, 3285, 3381, 7540, 3511, 7670, 7743, 3679, 3749, 3816, 3881, 3966, 8125, 4088, -1,
10, 4164, 4247, 4289, 4312, 349, 419, 459, 512, 524, 583, 618, 4874, 4944, 5036, 5069, 5101, 5204, 5296, 5329, 5361, 1398, 5506, 5529, 1540, 1623, 1694, 1733, 1759, 1818, 1849, 6109, 2084, 2118, 2149, 2208, 2234, 6499, 6569, 6652, 6694, 6717, 6795, 6862, 6894, 2896, 2988, 7122, 7154, 3156, 3248, 3319, 3349, 3384, 3443, 3455, 7734, 7774, 7844, 7911, 7934, 3945, 4028, 8183, -1,
11, 87, 4228, 4290, 4313, 350, 420, 4554, 4615, 4650, 576, 588, 4875, 876, 5008, 5070, 5102, 1136, 5268, 5330, 5362, 1399, 1409, 1432, 5655, 1604, 5789, 5850, 5881, 1797, 1823, 6110, 6179, 6240, 6266, 2182, 2213, 6500, 2492, 6633, 6695, 6718, 2698, 2765, 2797, 7020, 2960, 3025, 3057, 7280, 3220, 7414, 7475, 7487, 3413, 3448, 7735, 3677, 3747, 3814, 3837, 8060, 4009, 4086, -1,
8, 4163, 4246, 4353, 280, 347, 417, 457, 640, 4748, 711, 4842, 776, 4943, 5035, 5133, 1069, 5203, 5295, 5393, 1329, 1396, 5570, 1497, 5635, 5718, 1692, 1861, 5983, 1946, 6073, 2011, 2082, 2246, 6373, 2336, 6458, 2401, 6568, 6651, 6758, 2685, 2697, 6926, 2862, 6991, 7083, 7186, 3122, 7251, 7343, 3317, 3477, 7608, 3571, 7679, 3636, 3676, 3746, 7975, 3902, 8040, 8123, 4085, -1,
9, 86, 4227, 4354, 281, 348, 418, 4552, 4743, 682, 704, 4812, 777, 875, 5007, 5134, 1070, 1135, 5267, 5394, 1330, 1397, 1473, 5592, 1558, 5699, 5787, 5978, 1913, 1925, 6047, 2012, 6177, 6368, 2298, 2310, 6437, 2402, 2491, 6632, 6759, 2686, 6792, 2829, 6957, 2923, 7055, 3089, 7217, 3183, 7315, 7412, 7603, 3519, 3541, 7672, 3637, 7771, 7841, 3878, 7997, 3963, 8104, 8180, -1,
12, 88, 153, 12483, 8452, 351, 421, 490, 12808, 12873, 8842, 8907, 768, 877, 942, 13263, 9232, 1137, 1202, 13523, 9492, 1400, 13718, 9687, 1537, 1602, 1721, 14043, 14108, 10077, 10142, 1989, 2106, 14433, 14498, 10467, 10532, 2374, 2493, 2558, 14888, 10857, 2695, 15083, 11052, 2893, 2958, 15343, 11312, 3153, 3218, 3327, 15668, 15733, 11702, 11767, 3605, 3674, 3744, 16123, 12092, 3942, 4007, 4083, -1,
17, 4166, 4256, 4321, 4387, 4417, 4454, 466, 531, 623, 660, 752, 817, 832, 853, 903, 947, 968, 1012, 1034, 1078, 5457, 5538, 5604, 5669, 5754, 5762, 5799, 5827, 5864, 5910, 5947, 5956, 5993, 6039, 6076, 6104, 6141, 2438, 2528, 2593, 2659, 2738, 2761, 2805, 2827, 2871, 2892, 2936, 2986, 3007, 7378, 7443, 7535, 7572, 7664, 7729, 7769, 7806, 3810, 3876, 3941, 4026, 8178, -1,
18, 96, 4230, 4322, 4388, 4418, 4455, 4561, 4655, 595, 4784, 724, 818, 4935, 4979, 896, 917, 969, 1013, 1035, 1079, 5458, 1441, 1507, 1594, 5733, 1665, 1702, 1750, 1787, 5891, 5928, 1879, 1916, 6020, 6057, 6105, 6142, 6560, 2502, 2594, 2660, 6833, 6856, 6900, 6922, 6966, 7018, 7039, 2956, 3000, 3281, 3375, 7507, 3504, 7636, 7730, 3672, 3709, 7905, 7971, 8058, 4005, 4081, -1,
4116, 4195, 4260, 4294, 4325, 324, 361, 4592, 4625, 4657, 4690, 4722, 788, 842, 886, 907, 951, 960, 972, 981, 1016, 1364, 5536, 5562, 1571, 1636, 1687, 1724, 1729, 1752, 1766, 1789, 1794, 1817, 1831, 1854, 6084, 6121, 2467, 2532, 2566, 2597, 2736, 2759, 2794, 2803, 2815, 6986, 7030, 7051, 7095, 3312, 3345, 3377, 3410, 3442, 7700, 7767, 7804, 3808, 3834, 8035, 8100, 8176, -1,
4115, 4193, 4258, 4358, 293, 323, 360, 4591, 4753, 689, 4818, 754, 4883, 840, 884, 905, 949, 1024, 5132, 1045, 5176, 1363, 5600, 1530, 5665, 5730, 1686, 1723, 1857, 5976, 1894, 6013, 1922, 6041, 1959, 6078, 1987, 2024, 2465, 2530, 2630, 6757, 6831, 2823, 6954, 2867, 6975, 2888, 2932, 2953, 2997, 3311, 3473, 7601, 3538, 7666, 3603, 3670, 3707, 3872, 7994, 3937, 4002, 4079, -1,
13, 4165, 4250, 4315, 4381, 4481, 422, 462, 527, 619, 656, 748, 813, 1088, 5205, 1159, 5299, 1224, 5364, 1290, 5430, 1357, 5532, 5598, 5663, 5753, 6146, 2087, 6211, 2152, 6294, 2235, 6340, 2281, 6423, 2364, 6488, 2429, 6533, 6618, 6683, 6749, 2734, 3017, 7157, 3083, 7223, 3148, 7288, 3242, 7359, 3278, 3343, 3435, 3472, 3564, 3629, 7833, 3774, 7900, 7966, 8031, 8121, 4078, -1,
14, 90, 4229, 4316, 4382, 4482, 423, 4557, 4651, 591, 4780, 720, 814, 5191, 1139, 1152, 5269, 1225, 5365, 1291, 5431, 1358, 1435, 1501, 1593, 5727, 2049, 6182, 2134, 6267, 6275, 2216, 2263, 6396, 6404, 2345, 6489, 2430, 2458, 6597, 6684, 6750, 6829, 7112, 3060, 7178, 3126, 7274, 3199, 3212, 7352, 7373, 7467, 3407, 7596, 3536, 3630, 3736, 7869, 3803, 3869, 3961, 8095, 8173, -1,
4112, 4189, 4254, 4293, 4319, 388, 4521, 4588, 4621, 4653, 4686, 4718, 784, 1098, 5238, 1163, 5303, 1216, 1228, 5333, 5368, 5456, 5530, 5561, 1565, 1630, 2071, 6204, 2113, 2136, 6246, 6269, 2178, 2201, 6311, 6334, 6468, 2409, 6557, 6622, 6661, 6687, 2732, 3015, 3050, 7155, 7167, 7242, 3190, 7307, 3255, 7404, 7437, 7469, 7502, 7534, 3600, 7831, 3772, 7898, 7929, 3933, 3998, 4076, -1,
4111, 4187, 4252, 4357, 287, 387, 4520, 4587, 4749, 685, 4814, 750, 4879, 1096, 5236, 1161, 5301, 1280, 5388, 5397, 1336, 5455, 5594, 1529, 5659, 5724, 2070, 6203, 2241, 6360, 6374, 2301, 2306, 6425, 6439, 2366, 2371, 6504, 6555, 6620, 6725, 2655, 6827, 3079, 7210, 7219, 3135, 3144, 7284, 3209, 7349, 7403, 7565, 3501, 7630, 3566, 7695, 3734, 7867, 7962, 3897, 8027, 8092, 8171, -1,
21, 102, 167, 232, 297, 12613, 8582, 499, 564, 629, 694, 759, 824, 13133, 13198, 13263, 13328, 9297, 9362, 9427, 9492, 1344, 1467, 1532, 1597, 1662, 13978, 14043, 14108, 14173, 14238, 14303, 10272, 10337, 10402, 10467, 10532, 10597, 2433, 2498, 2563, 2628, 2751, 15083, 15148, 15213, 15278, 11247, 11312, 11377, 11442, 3271, 3336, 3401, 3466, 3531, 3596, 15993, 11962, 3798, 3863, 3928, 3993, 4074, -1,
23, 75, 4234, 4295, 4330, 364, 432, 4548, 4610, 4633, 577, 600, 4887, 862, 5021, 5082, 5113, 1124, 5283, 5344, 5370, 1404, 1408, 1420, 5643, 1610, 5776, 5838, 5870, 1805, 1837, 6124, 6164, 6226, 6258, 2193, 2225, 6512, 2487, 6646, 6707, 6719, 2692, 2757, 2783, 7006, 2973, 3014, 3045, 7268, 3235, 7401, 7463, 7486, 3430, 3453, 7740, 3664, 3732, 3797, 3832, 8055, 4022, 4073, -1,
22, 73, 4232, 4359, 298, 363, 431, 4547, 4738, 665, 705, 4824, 790, 860, 5019, 5146, 1081, 1122, 5281, 5408, 1338, 1403, 1472, 5580, 1545, 5704, 5775, 5966, 1902, 1933, 6061, 2027, 6163, 6354, 2290, 2321, 6449, 2415, 2485, 6644, 6771, 2687, 6787, 2821, 6943, 2908, 7067, 3078, 7205, 3170, 7329, 7400, 7591, 3518, 3558, 7677, 3643, 7759, 7827, 3861, 7992, 3957, 8116, 8168, -1,
24, 76, 170, 12488, 8458, 365, 433, 473, 12803, 12886, 8836, 8919, 769, 863, 953, 13275, 9245, 1125, 1210, 13537, 9507, 1405, 13705, 9675, 1536, 1607, 1710, 14031, 14123, 10064, 10156, 1997, 2098, 14419, 14511, 10452, 10544, 2385, 2488, 2559, 14900, 10870, 2690, 15068, 11038, 2885, 2970, 15330, 11300, 3142, 3232, 3326, 15656, 15739, 11689, 11772, 3622, 3662, 3730, 16117, 12087, 3925, 4019, 4071, -1,
25, 4202, 140, 12489, 8459, 366, 434, 4568, 8726, 12867, 12951, 8900, 770, 4985, 927, 13276, 9246, 5242, 1189, 13538, 9508, 1406, 9608, 13770, 5639, 1600, 5805, 9963, 14095, 14188, 10128, 1998, 6193, 10351, 14483, 14576, 10516, 2386, 6591, 2552, 14901, 10871, 6785, 10971, 15133, 7002, 2949, 11233, 15395, 7264, 3206, 7421, 11579, 15720, 15804, 11753, 3623, 7757, 7825, 12020, 16182, 8051, 3989, 8166, -1,
32, 82, 4241, 4335, 4400, 4423, 4467, 4550, 4642, 609, 4772, 739, 826, 4930, 4967, 897, 934, 982, 1019, 1047, 1084, 5472, 1427, 1492, 1586, 5745, 1664, 1685, 1737, 1781, 5896, 5940, 1867, 1911, 6026, 6070, 6122, 6143, 6546, 2513, 2607, 2672, 6821, 6851, 6888, 6916, 6953, 7001, 7038, 2968, 3005, 3270, 3362, 7521, 3492, 7651, 7738, 3660, 3704, 7891, 7956, 8050, 4017, 4069, -1,
4131, 4180, 4272, 4305, 4337, 330, 374, 4580, 4614, 4645, 4704, 4730, 803, 836, 873, 919, 956, 961, 984, 998, 1021, 1379, 5522, 5554, 1556, 1648, 1675, 1719, 1728, 1740, 1749, 1784, 1799, 1834, 1843, 1855, 6090, 6134, 2452, 2544, 2577, 2609, 2724, 2754, 2777, 2791, 2814, 6980, 7017, 7063, 7100, 3300, 3334, 3365, 3424, 3450, 7715, 7755, 7799, 3794, 3826, 8020, 8112, 8164, -1,
4132, 112, 4244, 4306, 4338, 331, 375, 483, 544, 570, 4678, 4709, 804, 4951, 4988, 900, 937, 962, 985, 999, 1022, 1380, 1425, 1457, 5680, 1620, 5770, 5814, 5831, 5866, 5875, 5887, 1792, 1804, 1813, 1848, 6091, 6135, 6576, 2516, 2578, 2610, 6819, 6849, 6872, 6886, 6909, 2903, 2940, 7044, 7081, 7395, 7456, 7482, 3398, 3429, 7716, 3658, 3702, 7889, 7921, 3952, 8084, 4067, -1,
4129, 4179, 4271, 4369, 305, 328, 372, 4578, 4742, 677, 4832, 762, 4897, 835, 872, 918, 955, 1025, 5144, 1062, 5181, 1377, 5586, 1522, 5651, 5743, 1673, 1717, 1856, 5964, 1877, 6008, 1927, 6058, 1971, 6079, 1992, 2036, 2451, 2543, 2641, 6769, 6818, 2818, 6937, 2855, 6974, 2883, 2920, 2966, 3003, 3298, 3462, 7589, 3552, 7674, 3617, 3657, 3701, 3858, 7986, 3923, 4015, 4066, -1,
4130, 111, 4243, 4370, 306, 329, 373, 481, 672, 4794, 4806, 741, 4898, 4950, 4987, 899, 936, 1026, 5145, 1063, 5182, 1378, 1489, 5617, 1583, 5715, 5768, 5812, 5959, 1898, 6003, 1919, 1920, 6028, 1941, 6072, 1993, 2037, 6575, 2515, 2642, 6770, 2721, 6913, 2840, 6950, 2877, 6998, 7035, 2947, 2984, 7393, 7584, 3514, 3526, 7653, 3618, 7752, 7796, 7953, 3889, 8047, 3987, 8161, -1,
4133, 113, 178, 12499, 8468, 332, 376, 4602, 8737, 8802, 12963, 13028, 4870, 4952, 4989, 5017, 5054, 9155, 9192, 13316, 13353, 1381, 13743, 9712, 1553, 1618, 1706, 1727, 14024, 14068, 14089, 14133, 10058, 10102, 10123, 10167, 1984, 2005, 6577, 6642, 10771, 14932, 6816, 10966, 11003, 15127, 15164, 6977, 7014, 7042, 7079, 3322, 15649, 15714, 11683, 11748, 3590, 3655, 3699, 12015, 16176, 8017, 8082, 4064, -1,
26, 78, 4237, 4331, 4396, 4487, 435, 4549, 4636, 603, 4766, 733, 825, 5186, 1127, 1153, 5286, 1238, 5371, 1303, 5436, 1370, 1423, 1488, 1582, 5741, 2048, 6165, 2121, 6261, 6280, 2228, 2251, 6391, 6410, 2358, 6506, 2431, 2446, 6605, 6699, 6764, 6815, 7107, 3048, 7172, 3113, 7257, 3198, 3224, 7357, 7365, 7452, 3419, 7582, 3549, 3641, 3724, 7864, 3791, 3856, 3950, 8109, 8159, -1,
4125, 4176, 4268, 4301, 4333, 394, 4534, 4574, 4613, 4639, 4698, 4729, 797, 1092, 5225, 1175, 5308, 1217, 1240, 5350, 5373, 5469, 5518, 5550, 1552, 1644, 2059, 6199, 2112, 2124, 6229, 6264, 2183, 2218, 6323, 6335, 6474, 2422, 6544, 6636, 6669, 6701, 2718, 3010, 3033, 7143, 7166, 7236, 3177, 7319, 3260, 7390, 7429, 7455, 7514, 7545, 3613, 7819, 3767, 7886, 7918, 3920, 4012, 4062, -1,
4126, 108, 4240, 4302, 4334, 395, 4535, 477, 538, 569, 4677, 4703, 798, 5207, 1148, 1156, 5289, 1218, 1241, 5351, 5374, 5470, 1421, 1453, 5676, 1616, 6154, 2102, 6215, 6250, 2163, 2175, 2176, 2188, 6293, 6328, 6475, 2423, 2476, 6608, 6670, 6702, 6813, 7105, 7128, 3046, 3069, 3159, 7292, 7300, 3241, 3293, 3354, 3385, 7493, 7519, 3614, 3722, 7862, 3789, 3821, 8044, 3984, 8157, -1,
4123, 4175, 4267, 4365, 301, 392, 4532, 4572, 4741, 671, 4826, 761, 4891, 1091, 5224, 1174, 5307, 1281, 5400, 5414, 1341, 5467, 5582, 1518, 5647, 5739, 2057, 6197, 2240, 6348, 6357, 2296, 2311, 6442, 6451, 2367, 2376, 6516, 6543, 6635, 6733, 2669, 6812, 3074, 7193, 7207, 3134, 3139, 7272, 3222, 7355, 7388, 7557, 3487, 7642, 3577, 7707, 3721, 7861, 7950, 3886, 8015, 8107, 8156, -1,
4124, 107, 4239, 4366, 302, 393, 4533, 475, 666, 4793, 4805, 735, 4892, 5206, 1147, 1155, 5288, 1282, 5401, 5415, 1342, 5468, 1485, 5613, 1579, 5711, 6152, 2100, 6343, 2282, 2291, 6399, 2304, 6412, 6421, 2360, 2377, 6517, 2475, 6607, 6734, 2670, 2715, 7169, 3096, 3110, 7229, 7254, 3195, 3203, 7336, 3291, 3482, 7609, 7621, 3551, 7708, 7816, 3764, 3853, 7981, 3947, 8079, 4059, -1,
4127, 109, 174, 12495, 8464, 396, 4536, 4601, 8731, 8796, 12957, 13022, 4869, 5208, 1149, 5273, 1214, 9411, 13544, 13572, 9513, 5471, 13739, 9708, 1549, 1614, 2090, 6207, 14408, 10356, 14473, 10421, 10442, 14582, 10507, 14647, 2368, 6485, 2477, 2542, 14863, 10832, 6810, 11222, 15355, 15383, 11324, 7233, 3174, 7298, 3239, 7417, 11547, 11612, 15773, 15838, 7685, 3719, 7859, 16107, 12076, 3917, 3982, 8154, -1,
38, 85, 179, 244, 310, 12621, 8593, 487, 552, 635, 681, 764, 829, 13125, 13210, 13275, 13341, 9286, 9376, 9441, 9507, 1345, 1461, 1527, 1592, 1663, 13966, 14031, 14123, 14160, 14252, 14317, 10258, 10323, 10415, 10452, 10544, 10609, 2432, 2503, 2568, 2634, 2750, 15068, 15134, 15199, 15289, 11234, 11300, 11365, 11450, 3266, 3331, 3414, 3460, 3543, 3608, 15982, 11954, 3785, 3851, 3916, 4010, 4057, -1,
39, 4211, 149, 245, 311, 12622, 8594, 4582, 4667, 616, 4796, 745, 830, 9050, 13189, 13276, 13342, 13408, 9350, 9442, 9508, 1346, 5556, 5622, 5695, 1656, 9869, 9963, 14095, 10092, 14224, 14318, 14353, 14447, 10387, 14576, 10516, 10610, 6535, 2496, 2569, 2635, 6845, 10971, 11037, 11129, 15263, 15329, 15395, 15482, 11429, 7361, 7446, 3395, 7575, 3524, 3609, 11885, 16049, 7880, 7946, 8042, 3980, 8152, -1,
4137, 118, 183, 213, 248, 8528, 12692, 4604, 4646, 4669, 4711, 4734, 809, 13149, 13214, 13253, 13279, 9315, 9380, 9414, 9445, 5444, 1459, 1471, 5686, 5751, 9900, 9933, 9965, 9998, 10030, 14288, 14384, 14417, 14449, 14482, 14514, 10580, 2442, 2507, 2560, 2572, 2748, 15066, 15097, 11101, 11166, 11232, 11258, 15459, 15524, 7383, 7425, 7448, 7490, 7513, 3588, 15980, 11952, 3783, 3818, 8010, 8075, 4055, -1,
4136, 116, 181, 277, 4408, 8527, 12691, 4603, 4774, 701, 4839, 766, 4904, 13147, 13212, 13317, 9247, 9313, 9378, 9478, 13605, 5443, 1523, 5631, 1588, 1653, 9899, 10061, 14189, 10126, 14254, 10191, 14383, 14545, 10481, 14610, 10546, 14675, 2440, 2505, 2624, 6732, 6843, 15130, 11065, 15195, 15260, 11296, 15418, 11361, 11426, 7382, 7553, 3480, 7618, 3545, 7683, 11883, 16047, 3847, 7978, 3912, 3977, 8150, -1,
4138, 89, 4248, 8406, 12567, 4473, 4538, 460, 12809, 8776, 8843, 13002, 4871, 878, 5037, 9195, 13356, 1138, 5297, 9455, 13616, 5503, 13699, 9668, 1538, 5697, 1695, 14044, 10011, 10078, 14237, 6106, 2085, 14434, 10401, 10468, 14627, 6496, 2494, 6653, 10811, 14972, 2688, 15055, 11024, 2894, 7053, 15315, 11284, 3154, 7313, 3320, 15669, 11636, 11703, 15862, 7731, 3653, 3718, 16104, 12073, 3943, 8102, 4053, -1,
48, 4196, 163, 224, 250, 4439, 4476, 4564, 4626, 4658, 593, 625, 4912, 843, 887, 5002, 5046, 5063, 5098, 5107, 5119, 5488, 5510, 5541, 1572, 5731, 1668, 1705, 1730, 1753, 1767, 1790, 5889, 5912, 5926, 5949, 2007, 2044, 2468, 6627, 6688, 6714, 2708, 2752, 2764, 2773, 2808, 6987, 7031, 2954, 2998, 3284, 3346, 3378, 7505, 7537, 3632, 7748, 7785, 3782, 3813, 8036, 4003, 8148, -1,
47, 4194, 161, 288, 4410, 4438, 4475, 4563, 4754, 690, 721, 4849, 815, 841, 885, 5000, 5044, 5127, 1066, 5171, 1087, 5487, 5574, 1509, 5666, 1633, 1667, 1704, 1858, 5977, 1895, 6014, 6017, 1944, 6054, 1981, 6102, 6139, 2466, 6625, 6752, 2682, 6803, 2816, 6924, 2837, 6968, 2889, 2933, 7048, 7092, 3283, 3474, 7602, 7633, 3569, 7727, 3651, 3688, 3846, 7973, 3938, 8097, 4051, -1,
49, 4197, 4282, 8417, 12579, 4440, 4477, 498, 12819, 12911, 8852, 8944, 785, 844, 888, 938, 959, 13256, 13300, 9226, 9270, 5489, 9634, 13796, 5638, 5728, 5785, 5822, 9923, 9960, 10006, 10043, 14148, 14185, 14231, 14268, 6081, 6118, 2469, 2554, 14881, 10851, 2706, 15049, 15093, 11019, 11063, 2880, 2901, 2951, 2995, 7410, 11539, 11631, 15764, 15856, 7697, 7746, 7783, 16098, 12068, 3910, 4000, 8146, -1,
50, 122, 4261, 8418, 12580, 4441, 4478, 4593, 8751, 12883, 12976, 8916, 786, 4970, 4991, 908, 952, 13257, 13301, 9227, 9271, 5490, 13729, 9699, 1568, 5702, 1688, 1725, 14038, 14075, 9987, 10024, 10071, 10108, 14212, 14249, 6082, 6119, 6586, 2533, 14882, 10852, 6801, 10952, 10996, 15114, 15158, 6983, 7027, 2944, 2965, 3313, 15663, 11603, 11696, 15828, 7698, 3649, 3686, 12001, 16163, 8032, 3974, 4049, -1,
44, 4190, 157, 218, 249, 4503, 444, 4560, 4622, 4654, 589, 621, 4908, 1099, 5239, 5258, 1206, 5319, 5354, 1267, 1279, 1388, 5509, 5535, 1566, 5725, 2052, 6185, 2114, 2137, 6247, 6270, 6273, 6296, 2214, 2237, 2391, 6524, 6558, 2525, 2586, 2617, 2704, 3008, 3020, 7125, 7160, 7243, 3191, 3210, 7350, 7376, 7438, 7470, 3405, 3437, 7724, 7812, 3753, 7877, 7903, 3934, 8093, 4048, -1,
43, 4188, 155, 282, 4409, 4502, 443, 4559, 4750, 686, 717, 4845, 811, 1097, 5237, 5256, 1204, 5383, 1322, 1331, 5439, 1387, 5573, 1503, 5660, 1627, 2051, 6184, 2242, 6361, 6375, 2302, 6401, 2328, 2342, 6461, 6486, 2427, 6556, 2523, 2650, 6777, 6799, 3072, 7180, 7189, 3128, 3145, 7285, 7304, 3252, 7375, 7566, 3502, 3533, 7661, 3627, 3715, 7848, 7941, 3871, 8028, 3995, 8143, -1,
45, 4191, 4281, 8411, 12573, 4504, 445, 494, 12815, 12907, 8848, 8940, 781, 1100, 5240, 1194, 5311, 13512, 9460, 9482, 13622, 1389, 9628, 13790, 5637, 5722, 6169, 2110, 10307, 14440, 10390, 14523, 14532, 10473, 14615, 10556, 6465, 2406, 6559, 6649, 10779, 14941, 2702, 15305, 11253, 11275, 15415, 3136, 7253, 3207, 7347, 3310, 15631, 15723, 11664, 11756, 3597, 7810, 3751, 11996, 16158, 8005, 8090, 4046, -1,
46, 121, 4255, 8412, 12574, 4505, 446, 4589, 8747, 12879, 12972, 8912, 782, 5226, 1151, 1164, 5304, 13513, 9461, 9483, 13623, 1390, 13723, 9693, 1562, 5701, 2072, 6205, 14422, 10363, 10371, 14504, 10455, 14588, 14596, 10537, 6466, 2407, 2489, 6623, 10780, 14942, 6797, 11208, 15348, 15370, 11318, 7239, 3187, 3200, 7317, 7405, 11563, 15695, 15788, 11728, 3598, 3713, 7846, 16091, 12061, 3930, 8069, 8141, -1,
4147, 103, 4262, 4347, 4412, 8538, 12704, 469, 565, 4724, 695, 4854, 4927, 13134, 9101, 9195, 9260, 9298, 13457, 13551, 13616, 5447, 1448, 1513, 1598, 5757, 13957, 14044, 10011, 14174, 10141, 10233, 10246, 10338, 14497, 10468, 14627, 14714, 2434, 6593, 6678, 6743, 2744, 15055, 15120, 15214, 11181, 11219, 11284, 11378, 15537, 3264, 3337, 7496, 3467, 7626, 7722, 15967, 11941, 3779, 3844, 3929, 8088, 4044, -1,
54, 4201, 4284, 4326, 4349, 12637, 8611, 503, 533, 568, 627, 639, 4918, 9040, 9132, 9165, 9197, 13396, 13488, 13521, 13553, 1354, 5543, 5566, 1577, 1660, 13982, 14021, 14047, 14106, 14137, 10205, 10276, 10310, 10341, 10400, 10426, 14691, 6532, 6615, 6657, 6680, 6839, 10958, 10990, 15184, 15276, 15314, 15346, 11348, 11440, 3275, 3328, 3340, 3399, 3434, 7690, 11870, 16036, 7874, 7897, 3908, 3991, 8139, -1,
55, 124, 4265, 4327, 4350, 12638, 8612, 4598, 4659, 4671, 597, 632, 4919, 13164, 9104, 9166, 9198, 9328, 13460, 13522, 13554, 1355, 1446, 1469, 5692, 1641, 9885, 9946, 9977, 14085, 14111, 10206, 14371, 14432, 14458, 10374, 10405, 14692, 2455, 6596, 6658, 6681, 2742, 15053, 15085, 11116, 15248, 11217, 11249, 15472, 11412, 7370, 7431, 7466, 3392, 3404, 7691, 15965, 11939, 3777, 3800, 8023, 3972, 4042, -1,
52, 4200, 4283, 4390, 317, 12635, 8609, 501, 661, 4792, 755, 4863, 820, 9039, 9131, 9229, 13357, 13395, 13487, 13585, 9521, 1352, 5607, 1534, 5672, 5755, 13980, 14149, 10079, 14234, 10169, 14299, 10274, 10438, 14565, 10528, 14650, 10593, 6531, 6614, 6721, 2648, 2741, 11022, 15150, 11087, 11179, 15378, 11314, 15443, 15535, 3273, 3456, 7564, 3527, 7658, 3592, 15964, 11938, 7938, 3865, 8003, 8086, 4041, -1,
53, 123, 4264, 4391, 318, 12636, 8610, 4596, 4787, 703, 725, 4856, 821, 13163, 9103, 9230, 13358, 9327, 13459, 13586, 9522, 1353, 1510, 5629, 1595, 5736, 9883, 10074, 14201, 14213, 10143, 14300, 14369, 14560, 10490, 10502, 14629, 10594, 2454, 6595, 6722, 2649, 6836, 15117, 11053, 15211, 11151, 11281, 15409, 11375, 15507, 7368, 7559, 3498, 3520, 7628, 3593, 11867, 16033, 3841, 7960, 3926, 8067, 8136, -1,
56, 125, 190, 12520, 8489, 12639, 8613, 511, 12852, 12917, 8886, 8951, 789, 13165, 13230, 9167, 13328, 9329, 9394, 13523, 9492, 1356, 13755, 9724, 1574, 1639, 14009, 9947, 10012, 14173, 14238, 14277, 10298, 14433, 14498, 10467, 10532, 10566, 2456, 2521, 14851, 10820, 2739, 10987, 15148, 15181, 15246, 15343, 11312, 11345, 11410, 3306, 15624, 15689, 11658, 11723, 3584, 15962, 11936, 16086, 12055, 3905, 3970, 4039, -1,
58, 114, 4273, 8431, 12592, 4458, 4479, 4581, 8738, 12897, 12964, 8931, 800, 4953, 4990, 920, 957, 13270, 13307, 9239, 9276, 5498, 13715, 9684, 1554, 5713, 1676, 1720, 14025, 14069, 9992, 10036, 10059, 10103, 14218, 14262, 6087, 6131, 6578, 2545, 14895, 10864, 6790, 10947, 10984, 15108, 15145, 6978, 7015, 2945, 2982, 3301, 15650, 11617, 11684, 15843, 7712, 3648, 3669, 11987, 16148, 8018, 3985, 4038, -1,
57, 110, 4269, 8427, 12588, 4522, 447, 4575, 8732, 12891, 12958, 8925, 794, 5209, 1150, 1176, 5309, 13526, 9467, 9495, 13628, 1401, 13711, 9680, 1550, 5709, 2060, 6200, 14409, 10357, 10376, 14516, 10443, 14583, 14602, 10550, 6471, 2419, 2478, 6637, 10795, 14956, 6789, 11203, 15336, 15364, 11305, 7234, 3175, 3201, 7334, 7391, 11548, 15707, 15774, 11741, 3610, 3712, 7829, 16079, 12048, 3918, 8077, 8133, -1,
60, 119, 4278, 4339, 4351, 12652, 8624, 4585, 4647, 4670, 614, 637, 4924, 13150, 9117, 9178, 9209, 9316, 13475, 13536, 13562, 1367, 1429, 1464, 5687, 1654, 9872, 9934, 9966, 14093, 14125, 10220, 14356, 14418, 14450, 10385, 10417, 14704, 2443, 6602, 6663, 6698, 2729, 15045, 15071, 11102, 15261, 11206, 11237, 15460, 11427, 7364, 7426, 7449, 3393, 3416, 7703, 15952, 11924, 3776, 3788, 8011, 3978, 4036, -1,
59, 117, 4276, 4403, 319, 12651, 8623, 4584, 4775, 702, 742, 4861, 827, 13148, 9115, 9242, 13369, 9314, 13473, 13600, 9530, 1366, 1493, 5624, 1589, 5748, 9871, 10062, 14190, 14221, 10157, 14315, 14355, 14546, 10482, 10513, 14641, 10607, 2441, 6600, 6727, 2666, 6824, 15109, 11039, 15196, 11163, 11270, 15397, 11362, 15521, 7363, 7554, 3481, 3521, 7640, 3606, 11855, 16019, 3840, 7948, 3913, 8072, 8131, -1,
61, 120, 191, 12532, 8502, 12653, 8625, 510, 12840, 12923, 8873, 8956, 806, 13151, 13241, 9179, 13341, 9317, 9402, 13537, 9507, 1368, 13749, 9719, 1557, 1651, 13998, 9935, 10027, 14160, 14252, 14285, 10290, 14419, 14511, 10452, 10544, 10577, 2444, 2538, 14856, 10826, 2727, 10972, 15134, 15173, 15258, 15330, 11300, 11334, 11424, 3289, 15619, 15702, 11652, 11735, 3585, 15950, 11922, 16073, 12043, 3904, 3975, 4034, -1,
62, 4223, 184, 12533, 8503, 12654, 8626, 4605, 8763, 12904, 12988, 8937, 807, 9081, 13215, 9180, 13342, 13434, 9381, 13538, 9508, 1369, 9652, 13814, 5683, 1621, 9901, 14059, 9999, 10092, 14224, 14286, 14385, 10351, 14483, 14576, 10516, 10578, 6570, 2508, 14857, 10827, 6822, 15067, 11037, 11098, 15237, 11233, 15395, 15456, 11398, 7384, 11542, 15683, 15767, 11716, 3586, 11853, 16017, 11976, 16138, 8007, 3968, 8129, -1,
4159, 126, 4285, 8443, 12604, 8569, 12730, 504, 12853, 8820, 8887, 13046, 4915, 13166, 9133, 13291, 9260, 9330, 13489, 9455, 13616, 5482, 13736, 9705, 1575, 5734, 13983, 9948, 14107, 14174, 10141, 10202, 10277, 14434, 10401, 10468, 14627, 14688, 2457, 6616, 10774, 14935, 2709, 10959, 15120, 15182, 11149, 15315, 11284, 11346, 15505, 3276, 15625, 11592, 11659, 15818, 7687, 15941, 11910, 16067, 12036, 3906, 8065, 4032, -1
};

const char *i2gai_typeNames[4] = {
	"undefined",
	"blade",
	"versor",
	"multivector"
};
// layer 0 functions are always pure C, unless custom float class if used
extern "C" {

char *i2gai_basisElementNames[64] = {
(char*)"1",
(char*)"e1",
(char*)"e2",
(char*)"no",
(char*)"ni",
(char*)"go",
(char*)"gi",
(char*)"e1^e2",
(char*)"e1^no",
(char*)"e2^no",
(char*)"e1^ni",
(char*)"e2^ni",
(char*)"no^ni",
(char*)"e1^go",
(char*)"e2^go",
(char*)"no^go",
(char*)"ni^go",
(char*)"e1^gi",
(char*)"e2^gi",
(char*)"no^gi",
(char*)"ni^gi",
(char*)"go^gi",
(char*)"e1^e2^no",
(char*)"e1^e2^ni",
(char*)"e1^no^ni",
(char*)"e2^no^ni",
(char*)"e1^e2^go",
(char*)"e1^no^go",
(char*)"e2^no^go",
(char*)"e1^ni^go",
(char*)"e2^ni^go",
(char*)"no^ni^go",
(char*)"e1^e2^gi",
(char*)"e1^no^gi",
(char*)"e2^no^gi",
(char*)"e1^ni^gi",
(char*)"e2^ni^gi",
(char*)"no^ni^gi",
(char*)"e1^go^gi",
(char*)"e2^go^gi",
(char*)"no^go^gi",
(char*)"ni^go^gi",
(char*)"e1^e2^no^ni",
(char*)"e1^e2^no^go",
(char*)"e1^e2^ni^go",
(char*)"e1^no^ni^go",
(char*)"e2^no^ni^go",
(char*)"e1^e2^no^gi",
(char*)"e1^e2^ni^gi",
(char*)"e1^no^ni^gi",
(char*)"e2^no^ni^gi",
(char*)"e1^e2^go^gi",
(char*)"e1^no^go^gi",
(char*)"e2^no^go^gi",
(char*)"e1^ni^go^gi",
(char*)"e2^ni^go^gi",
(char*)"no^ni^go^gi",
(char*)"e1^e2^no^ni^go",
(char*)"e1^e2^no^ni^gi",
(char*)"e1^e2^no^go^gi",
(char*)"e1^e2^ni^go^gi",
(char*)"e1^no^ni^go^gi",
(char*)"e2^no^ni^go^gi",
(char*)"e1^e2^no^ni^go^gi"
};

bool i2gai_basisElementNamesAllocated[64] = {
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false
};

int i2gai_gradeSize[7] = {1, 6, 15, 20, 15, 6, 1};
int i2gai_mvSize[128] = {0, 1, 6, 7, 15, 16, 21, 22, 20, 21, 26, 27, 35, 36, 41, 42, 15, 16, 21, 22, 30, 31, 36, 37, 35, 36, 41, 42, 50, 51, 56, 57, 6, 7, 12, 13, 21, 22, 27, 28, 26, 27, 32, 33, 41, 42, 47, 48, 21, 22, 27, 28, 36, 37, 42, 43, 41, 42, 47, 48, 56, 57, 62, 63, 1, 2, 7, 8, 16, 17, 22, 23, 21, 22, 27, 28, 36, 37, 42, 43, 16, 17, 22, 23, 31, 32, 37, 38, 36, 37, 42, 43, 51, 52, 57, 58, 7, 8, 13, 14, 22, 23, 28, 29, 27, 28, 33, 34, 42, 43, 48, 49, 22, 23, 28, 29, 37, 38, 43, 44, 42, 43, 48, 49, 57, 58, 63, 64};

const int i2gai_bevt0[1] = {-1};
const int i2gai_bevt1[6] = {0, 1, 2, 3, 4, 5};
const int i2gai_bevt2[15] = {0, 0, 1, 0, 1, 2, 0, 1, 2, 3, 0, 1, 2, 3, 4};
const int i2gai_bevt3[20] = {0, 0, 0, 1, 0, 0, 1, 0, 1, 2, 0, 0, 1, 0, 1, 2, 0, 1, 2, 3};
const int i2gai_bevt4[15] = {0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 2};
const int i2gai_bevt5[6] = {0, 0, 0, 0, 0, 1};
const int i2gai_bevt6[1] = {0};
const int *i2gai_bevt[7] = { // bevt = basis element vector table
	i2gai_bevt0,
	i2gai_bevt1,
	i2gai_bevt2,
	i2gai_bevt3,
	i2gai_bevt4,
	i2gai_bevt5,
	i2gai_bevt6
};
const int i2gai_newBevt[64] = { // bevt = basis element vector table
	0, 1, 2, 4, 8, 16, 32, 3, 5, 6, 9, 10, 12, 17, 18, 20, 24, 33, 34, 36, 40, 48, 7, 11, 13, 14, 19, 21, 22, 25, 26, 28, 35, 37, 38, 41, 42, 44, 49, 50, 52, 56, 15, 23, 27, 29, 30, 39, 43, 45, 46, 51, 53, 54, 57, 58, 60, 31, 47, 55, 59, 61, 62, 63
};

const int i2gai_omct[192] = { // omct = Outer Morphism Construction Table
	-1, -1, 0,
	1, -1, 1,
	2, -1, 1,
	3, -1, 1,
	4, -1, 1,
	5, -1, 1,
	6, -1, 1,
	1, 2, 1,
	1, 3, 1,
	2, 3, 1,
	1, 4, 1,
	2, 4, 1,
	3, 4, 1,
	1, 5, 1,
	2, 5, 1,
	3, 5, 1,
	4, 5, 1,
	1, 6, 1,
	2, 6, 1,
	3, 6, 1,
	4, 6, 1,
	5, 6, 1,
	7, 3, 1,
	7, 4, 1,
	8, 4, 1,
	9, 4, 1,
	7, 5, 1,
	8, 5, 1,
	9, 5, 1,
	10, 5, 1,
	11, 5, 1,
	12, 5, 1,
	7, 6, 1,
	8, 6, 1,
	9, 6, 1,
	10, 6, 1,
	11, 6, 1,
	12, 6, 1,
	13, 6, 1,
	14, 6, 1,
	15, 6, 1,
	16, 6, 1,
	22, 4, 1,
	22, 5, 1,
	23, 5, 1,
	24, 5, 1,
	25, 5, 1,
	22, 6, 1,
	23, 6, 1,
	24, 6, 1,
	25, 6, 1,
	26, 6, 1,
	27, 6, 1,
	28, 6, 1,
	29, 6, 1,
	30, 6, 1,
	31, 6, 1,
	42, 5, 1,
	42, 6, 1,
	43, 6, 1,
	44, 6, 1,
	45, 6, 1,
	46, 6, 1,
	57, 6, 1
};
// end of the layer 0 functions
} /* end of 'extern "C"' */



i2gai i2gai::e1(GRADE1, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0);
i2gai i2gai::e2(GRADE1, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0);
i2gai i2gai::no(GRADE1, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0);
i2gai i2gai::ni(GRADE1, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0);
i2gai i2gai::go(GRADE1, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0);
i2gai i2gai::gi(GRADE1, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0);
i2gai *i2gai::bv[6] = {&i2gai::e1, &i2gai::e2, &i2gai::no, &i2gai::ni, &i2gai::go, &i2gai::gi};
i2gai i2gai::I(GRADE6, 1.0);
i2gai i2gai::Ii(GRADE6, -1.0);

const int i2gai::dim = 6;
const int i2gai::nbCoor = 64;

i2gai::i2gai() {
	usage = 0;
	// modification for custom float (december 9 2002)
	i2gai_null(c, 64);
}

i2gai::i2gai(const i2gai &a) {
	usage = 0;
	copy(a);
}

i2gai::i2gai(int gradeUsage, const double *coordinates) {
	usage = 0;
	set(gradeUsage, coordinates);
}

i2gai::~i2gai() {
	setUsage(0);
}

i2gai::i2gai(int grade, double c0) {
	usage = 0;
	set(grade, c0);
}

i2gai::i2gai(int grade, double c0, double c1, double c2, double c3, double c4, double c5) {
	usage = 0;
	set(grade, c0, c1, c2, c3, c4, c5);
}

i2gai::i2gai(int grade, double c0, double c1, double c2, double c3, double c4, double c5, double c6, double c7, double c8, double c9, double c10, double c11, double c12, double c13, double c14) {
	usage = 0;
	set(grade, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14);
}

i2gai::i2gai(int grade, double c0, double c1, double c2, double c3, double c4, double c5, double c6, double c7, double c8, double c9, double c10, double c11, double c12, double c13, double c14, double c15, double c16, double c17, double c18, double c19) {
	usage = 0;
	set(grade, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19);
}

void i2gai::null() {
	setUsage(0);
}

void i2gai::set(int gradeUsage, const double *coordinates) {
	setUsage((i2gai_mvSize[gradeUsage] << 7) | gradeUsage);
	i2gai_copy(c, coordinates, i2gai_mvSize[gradeUsage]);
}

void i2gai::setScalar(const double coordinates[1]) {
	setUsage(129);
	i2gai_copy(c, coordinates, 1);
}

void i2gai::setVector(const double coordinates[6]) {
	setUsage(770);
	i2gai_copy(c, coordinates, 6);
}

void i2gai::set2Vector(const double coordinates[15]) {
	setUsage(1924);
	i2gai_copy(c, coordinates, 15);
}

void i2gai::set3Vector(const double coordinates[20]) {
	setUsage(2568);
	i2gai_copy(c, coordinates, 20);
}

void i2gai::set4Vector(const double coordinates[15]) {
	setUsage(1936);
	i2gai_copy(c, coordinates, 15);
}

void i2gai::set5Vector(const double coordinates[6]) {
	setUsage(800);
	i2gai_copy(c, coordinates, 6);
}

void i2gai::set6Vector(const double coordinates[1]) {
	setUsage(192);
	i2gai_copy(c, coordinates, 1);
}

int i2gai::set(int grade, double c0) {
	setUsage(grade | (i2gai_mvSize[grade] << 7));
	c[0] = c0;
	return 0;
}

int i2gai::set(int grade, double c0, double c1, double c2, double c3, double c4, double c5) {
	setUsage(grade | (i2gai_mvSize[grade] << 7));
	c[0] = c0;
	c[1] = c1;
	c[2] = c2;
	c[3] = c3;
	c[4] = c4;
	c[5] = c5;
	return 0;
}

int i2gai::set(int grade, double c0, double c1, double c2, double c3, double c4, double c5, double c6, double c7, double c8, double c9, double c10, double c11, double c12, double c13, double c14) {
	setUsage(grade | (i2gai_mvSize[grade] << 7));
	c[0] = c0;
	c[1] = c1;
	c[2] = c2;
	c[3] = c3;
	c[4] = c4;
	c[5] = c5;
	c[6] = c6;
	c[7] = c7;
	c[8] = c8;
	c[9] = c9;
	c[10] = c10;
	c[11] = c11;
	c[12] = c12;
	c[13] = c13;
	c[14] = c14;
	return 0;
}

int i2gai::set(int grade, double c0, double c1, double c2, double c3, double c4, double c5, double c6, double c7, double c8, double c9, double c10, double c11, double c12, double c13, double c14, double c15, double c16, double c17, double c18, double c19) {
	setUsage(grade | (i2gai_mvSize[grade] << 7));
	c[0] = c0;
	c[1] = c1;
	c[2] = c2;
	c[3] = c3;
	c[4] = c4;
	c[5] = c5;
	c[6] = c6;
	c[7] = c7;
	c[8] = c8;
	c[9] = c9;
	c[10] = c10;
	c[11] = c11;
	c[12] = c12;
	c[13] = c13;
	c[14] = c14;
	c[15] = c15;
	c[16] = c16;
	c[17] = c17;
	c[18] = c18;
	c[19] = c19;
	return 0;
}

const char *i2gai::fpPrecision = "%2.2f";
const char *i2gai::stringStartDelimiter = "";
const char *i2gai::stringEndDelimiter = "";

int i2gai::setFPPrecision(const char *prec) {
	if (prec == NULL) return -1;
	fpPrecision = prec;
	return 0;
}

int i2gai::setStringDelimiters(char start, char end) {
	if ((start < 0) || (end < 0)) return -1;
	static char startStr[2], endStr[2];

	startStr[0] = start; startStr[1] = 0;
	stringStartDelimiter = startStr;

	endStr[0] = end; endStr[1] = 0;
	stringEndDelimiter = endStr;
	return 0;
}

const char *i2gai::string(const char *prec /*= NULL*/) const {
	// todo: this whole function is not very (mt-)safe
	static char tmpResult[1024]; 
	tmpResult[0] = 0;

	const int maxResult = 16; 
	static char *result[maxResult];
	static int currentResult = 0;

	char *rBuf = tmpResult;
	int i, j, k = 0, ia = 0, gu = gradeUsage(), s = i2gai_mvSize[gu], p = 0, cnt = 0;
	char buf[32];	

	if (prec == NULL) prec = fpPrecision;
	sprintf(buf, "%cs%s%cs%cs", '%', prec, '%', '%');
	rBuf += sprintf(rBuf, "%s", stringStartDelimiter);
	for (i = 0; i <= 6; i++)
		if (gu & (1 << i)) {
			for (j = 0; j < i2gai_gradeSize[i]; j++) {
				if (fabs(c[k]) > 1e-14) {
					cnt++;
					rBuf += sprintf(rBuf, buf, (p) ? " + " : "", float(c[k]), (i) ? "*" : "", (i) ? i2gai_basisElementNames[ia] : "");
					p = 1;
				}
				k++; ia++;
			}
		}
		else ia += i2gai_gradeSize[i];

	if (cnt == 0) rBuf += sprintf(rBuf, "0");
	rBuf += sprintf(rBuf, "%s", stringEndDelimiter);

	k = (int)(strlen(tmpResult) + 1);
	rBuf = result[currentResult] = (char*)realloc(result[currentResult], k);
	currentResult = (currentResult + 1) % maxResult;

	if (rBuf == NULL) {
		printf("Memory allocation failure for %d bytes\n", k);
		return tmpResult; // at least return something...
	}
	else {
		memcpy(rBuf, tmpResult, k);
		return rBuf;
	}
}

void i2gai::print(const char *text /*= NULL*/, const char *prec /*= NULL*/) const {
	fprint(stdout, text, prec);
}

void i2gai::fprint(FILE *F, const char *text /*= NULL*/, const char *prec /*= NULL*/) const {
	if (text) fprintf(F, text);
	fprintf(F, "%s\n", string(prec));
}

int i2gai::renameBasisVector(const char *oldName, const char *newName) {
    unsigned int totalNb = 0;
    for (unsigned int j = 0; j < 64;j++) {
        // count number of occurances of oldName:
        char *ptr = i2gai_basisElementNames[j];
        int nb = 0;
        do {
            ptr = strstr(ptr, oldName);
            
            if (ptr != NULL) {
                nb ++;
                ptr += strlen(oldName);
            }
        } while (ptr);
        totalNb += nb;
        
        // if oldName occured:
        if (nb) {
            // allocate mem for new name
            char *buf = (char*)malloc(
                strlen(i2gai_basisElementNames[j]) + 1 + 
                nb * (strlen(newName) - strlen(oldName)));
            if (buf == NULL) return -1;

            // form new name
            ptr = i2gai_basisElementNames[j];
            char *buf2 = buf, *ptr2 = ptr;
            do {
                ptr = strstr(ptr, oldName);
                if (ptr != NULL) {
                    memcpy(buf2, ptr2, ptr - ptr2);
                    buf2 += ptr - ptr2;
                    
                    strcpy(buf2, newName);
                    buf2 += strlen(newName);
                    
                    ptr += strlen(oldName);        
                    ptr2 = ptr;
                }
                else {
                    strcpy(buf2, ptr2);
                }
            } while (ptr);
            
            // set result:
            if (i2gai_basisElementNamesAllocated[j])
                free(i2gai_basisElementNames[j]);
            i2gai_basisElementNames[j] = buf;
            i2gai_basisElementNamesAllocated[j] = true;
        }
    }
    return (totalNb == 0) ? -1 : 0;
}



void i2gai::copy(const i2gai &a) {
	setUsage(a.usage);
	i2gai_copy(c, a.c, i2gai_mvSize[a.gradeUsage()]);
}

void i2gai::compress(double epsilon /* = 1e-14 */ ) {
	double cc[64];
	int i, j, ia = 0, ib = 0, gu = gradeUsage(), gu2 = 0, f, s;
	for (i = 0; i < 6; i++) {
		if (!(gu & (1 << i))) continue;

		s = i2gai_gradeSize[i];
		j = ia + s;
		f = 0;
		for (; ia < j; ia++)
			if ((c[ia] > epsilon) || (c[ia] < -epsilon)) {f = 1; break;}
		ia = j;
		if (f) {
			i2gai_copy(cc + ib, c + ia - s, s);
			ib += s;
			gu2 |= (1 << i);
		}
	}
	if (gu2 != gu) set(gu2, cc);
}

void i2gai::reverse(const i2gai &a) {
	double *pc[7];
	copy(a);
	if (!(a.gradeUsage() & 76)) return;
	expand( (const double**) pc);
	i2gai_reverse(pc);
}

void i2gai::cliffordConjugate(const i2gai &a) {
	double *pc[7];
	copy(a);
	if (!(a.gradeUsage() & 102)) return;
	expand( (const double**) pc);
	i2gai_cliffordConjugate(pc);
}

void i2gai::gradeInvolution(const i2gai &a) {
	double *pc[7];
	copy(a);
	if (!(a.gradeUsage() & 42)) return;
	expand( (const double**) pc);
	i2gai_involution(pc);
}

void i2gai::negate(const i2gai &a) {
	setUsage(a.usage);
	i2gai_negate(c, a.c, i2gai_mvSize[a.gradeUsage()]);
}

void i2gai::add(const i2gai &a, const i2gai &b) {
	double const *pa[7], *pb[7];
	double *pc[7];
	int gu = a.gradeUsage() | b.gradeUsage();
	setUsage(gu | (i2gai_mvSize[gu] << 7));
	if (a.gradeUsage() == b.gradeUsage()) i2gai_addSameGradeUsage(c, a.c, b.c, memUsage());
	else {
		a.expand(b, pa, pb);
		expand( (const double**) pc);
		i2gai_add(pa, pb, pc);
	}
}

void i2gai::add(double scalar, const i2gai &b) {
	double const *pa[7], *pb[7];
	double *pc[7];
	int gu = GRADE0 | b.gradeUsage();
	setUsage(gu | (i2gai_mvSize[gu] << 7));
	if (GRADE0 == b.gradeUsage()) i2gai_addSameGradeUsage(c, &scalar, b.c, memUsage());
	else {
		memset(pa + 1, 0, sizeof(double*) * 6);
		pa[0] = &scalar;
		b.expand(pb);
		expand( (const double**) pc);
		i2gai_add(pa, pb, pc);
	}
}

void i2gai::sub(const i2gai &a, const i2gai &b) {
	double const *pa[7], *pb[7];
	double *pc[7];
	int gu = a.gradeUsage() | b.gradeUsage();
	setUsage(gu | (i2gai_mvSize[gu] << 7));
	if (a.gradeUsage() == b.gradeUsage()) i2gai_subSameGradeUsage(c, a.c, b.c, memUsage());
	else {
		a.expand(b, pa, pb);
		expand( (const double**) pc);
		i2gai_sub(pa, pb, pc);
	}
}

void i2gai::sub(double scalar, const i2gai &b) {
	double const *pa[7], *pb[7];
	double *pc[7];
	int gu = GRADE0 | b.gradeUsage();
	setUsage(gu | (i2gai_mvSize[gu] << 7));
	if (GRADE0 == b.gradeUsage()) i2gai_subSameGradeUsage(c, &scalar, b.c, memUsage());
	else {
		memset(pa + 1, 0, sizeof(double*) * 6);
		pa[0] = &scalar;
		b.expand(pb);
		expand( (const double**) pc);
		i2gai_sub(pa, pb, pc);
	}
}

// take grade introduced 20020710
void i2gai::takeGrade(const i2gai &a, int gu) {
	int i, gua, s;
	double *bc; 
	const double *ac; 

	// determine what the grage usage 'gu' of the result should be:
	if (gu = ((gua = a.gradeUsage()) & gu)) { // only execute if any grade will be present in the result
		// set the grade usage of the result + allocate memory
		setUsage(gu | (i2gai_mvSize[gu] << 7)); 

		bc = c; ac = a.c; // pointers to the coordinates of source (ac) and result (bc)
		for (i = 1; i <= gu; i = i << 1) { // for each grade that is possibly in the result
			if (gua & i) { // determine if grade is present in source
				s = i2gai_mvSize[i]; // get the size of grade
				if (gu & i) { // determine if grade is present in result
					i2gai_copy(bc, ac, s); // copy coordinates
					bc += s; // increment pointer to result
				}
				ac += s; // increment pointer to source
			}
		}
	}
	else setUsage(0);
}

// added an epsilon value on 2002 07 28
int i2gai::highestGrade(const i2gai &a, double epsilon /* = 1e-14 */) {
	int g = 6, gu = a.gradeUsage(), ia = i2gai_mvSize[gu], size, i;
	const double *cptr;
	do {
		if (gu & (1 << g)) {
			size = i2gai_gradeSize[g];
			ia -= size;
			cptr = a.c + ia;
			for (i = 0; i < size; i++) 
				if (fabs(cptr[i]) > epsilon) {
					set(1 << g, a.c + ia);
					return g;
				}
		}
	} while ((--g)>= 0); // bug fix on 2003 11 16, used to be while ((--g) _>_ 0)
//return -1; // modification on 20020828

	setUsage(0);
	return 0;
}

int i2gai::grade() const {
	int g = 6, gu = gradeUsage(), idx = i2gai_mvSize[gu], size, i;
	const double *cptr;
	do {
		if (gu & (1 << g)) {
			size = i2gai_gradeSize[g];
			idx -= size;
			cptr = c + idx;
			for (i = 0; i < size; i++) if (cptr[i] != (double)0.0) return (gu ^ (1 << g)) ? -1 : g;
		}
	} while ((--g)>0);
	return 0;
}

int i2gai::maxGrade() const { 
	int g = 6, gu = gradeUsage(), idx = i2gai_mvSize[gu], size, i;
	const double *cptr;
	do {
		if (gu & (1 << g)) {
			size = i2gai_gradeSize[g];
			idx -= size;
			cptr = c + idx;
			for (i = 0; i < size; i++) if (cptr[i] != (double)0.0) return g;
		}
	} while ((--g)>0);
	return -1;
}

int i2gai::largestGrade() const {
	int g = 0, gu = gradeUsage(), size;
	double largest = -1.0, tmp;
	int lg = 0;
	const double *cptr = c;
	do {
		if (gu & (1 << g)) {
			size = i2gai_gradeSize[g];
			if ( (tmp = i2gai_norm_a(cptr, size)) > largest) {
				largest = tmp;
				lg = g;
			}
			gu ^= (1 << g);
			
			cptr += size;
		}
	} while (gu && ((++g)<=6));
	return lg;
}




int i2gai::versorInverse(const i2gai &a) {
	i2gai reverse, scalar;
	reverse.reverse(a);
	scalar.scp(a, reverse);
	if ((scalar.c == NULL) || (scalar.c[0] == 0.0f)) {null(); return -1;}
	scalar.c[0] = 1.0f / scalar.c[0];
	op(scalar, reverse);
	return 0;
}

void i2gai::expand(double matrix[], const int table[]) const {
	double val;
	int i, j = 0, t, g = -1, gi = 0, gu = gradeUsage(), ci = 0;
	for (i = -1; i < 64; i++) {
		if (i == -1) val = 0.0f;
		else {
			if (gi == 0) gi = i2gai_gradeSize[++g];
			if (gu & (1 << g)) val = c[ci++];
			else val = 0.0f;
			gi--;
		}
		while ((t = table[j++]) >= 0) {
			if (t & 8192) matrix[t & 4095] += (t & 4096) ? (double)-val : (double)val;
			else matrix[t & 4095] = (t & 4096) ? (double)-val : (double)val;
		}
	}
}

int i2gai::generalInverse(const i2gai &a) {
	static double matrix[4096];
	double *m[64] = {
		matrix + 0,
		matrix + 64,
		matrix + 128,
		matrix + 192,
		matrix + 256,
		matrix + 320,
		matrix + 384,
		matrix + 448,
		matrix + 512,
		matrix + 576,
		matrix + 640,
		matrix + 704,
		matrix + 768,
		matrix + 832,
		matrix + 896,
		matrix + 960,
		matrix + 1024,
		matrix + 1088,
		matrix + 1152,
		matrix + 1216,
		matrix + 1280,
		matrix + 1344,
		matrix + 1408,
		matrix + 1472,
		matrix + 1536,
		matrix + 1600,
		matrix + 1664,
		matrix + 1728,
		matrix + 1792,
		matrix + 1856,
		matrix + 1920,
		matrix + 1984,
		matrix + 2048,
		matrix + 2112,
		matrix + 2176,
		matrix + 2240,
		matrix + 2304,
		matrix + 2368,
		matrix + 2432,
		matrix + 2496,
		matrix + 2560,
		matrix + 2624,
		matrix + 2688,
		matrix + 2752,
		matrix + 2816,
		matrix + 2880,
		matrix + 2944,
		matrix + 3008,
		matrix + 3072,
		matrix + 3136,
		matrix + 3200,
		matrix + 3264,
		matrix + 3328,
		matrix + 3392,
		matrix + 3456,
		matrix + 3520,
		matrix + 3584,
		matrix + 3648,
		matrix + 3712,
		matrix + 3776,
		matrix + 3840,
		matrix + 3904,
		matrix + 3968,
		matrix + 4032

	};
	double maxp, *tmp, mult;
	int pi, i, j, k;
	double inverse[64];
	inverse[0] = 1.0f;

	// modification for custom float (december 9 2002)
	i2gai_null(inverse + 1, 64-1);

	int it = 0;

	a.expand(matrix, i2gai_expansionTable_gp);

	for (i = 0; i < 64; i++) {	// sweep all columns
		pi = i;
		maxp = (double)fabs(m[i][i]);

		for (j = i + 1; j < 64; j++) // find the max pivot
			if ((double)fabs(m[j][i]) > maxp)
				maxp = (double)fabs(m[pi = j][i]);
		if (inverse[pi] != 0.0f) it = 1;
		if (pi != i) { // swap rows
			if (inverse[i] != 0.0f) it = 1;
			tmp = m[pi]; m[pi] = m[i]; m[i] = tmp;
			if (it) maxp = inverse[pi]; inverse[pi] = inverse[i]; inverse[i] = maxp;
		}

		maxp = m[i][i];
		if (maxp == 0.0f) {	// singular matrix
			setUsage(0);
			return -1;
		}

		for (k = 0; k < 64; k++) { // sweep all other rows
			if (k == i) continue;
			mult = -m[k][i] / maxp;
			for (j = i + 1; j < 64; j++) m[k][j] += m[i][j] * mult;
			if (it) inverse[k] += inverse[i] * mult;
		}

		for (j = i+1; j < 64; j++) m[i][j] /= maxp; // divide the pivot row
		if (it) inverse[i] /= maxp;
	}
	set((1 << 7) - 1, inverse);
	return 0;
}

double i2gai::norm_a() const {
	return i2gai_norm_a(c, i2gai_mvSize[gradeUsage()]);
}

double i2gai::norm_b() const {
	i2gai r, s;
	r.reverse(*this);
	s.scp(*this, r);
	return s.scalar();
}

double i2gai::largestCoordinate() const {
	int nc = i2gai_mvSize[gradeUsage()], i;
	double maxC = 0.0, C;
	
	for (i = 0; i < nc; i++) {
		C = fabs(c[i]);
		if (C > maxC) maxC = C;
	}
	
	return maxC;
}

void i2gai::normalize(const i2gai &a, int norm) {
	double tmpC;
	switch(norm) {
	case 1:
		tmpC = 1.0f / (double)sqrt(a.norm_a());
		break;
	case 2:
		tmpC = 1.0f / (double)sqrt(fabs(a.norm_b()));
		break;
	}
	i2gai scalar(GRADE0, tmpC);
	op(a, scalar);
}

int i2gai::project(const i2gai &blade, const i2gai &a) {
	i2gai tmp, bladeInverse;
	bladeInverse.versorInverse(blade);
	tmp.lcont(a, blade);
	lcont(tmp, bladeInverse);
	return 0;
}

int i2gai::projectOntoVersor(const i2gai &versor, const i2gai &a) {
	i2gai tmp, versorInverse;
	versorInverse.versorInverse(versor);
	tmp.lcont(a, versor);
	gp(tmp, versorInverse);
	return 0;
}

int i2gai::reject(const i2gai &blade, const i2gai &a) {
	i2gai tmp, bladeInverse;
	// todo: check if this code is correct
	bladeInverse.versorInverse(blade);
	tmp.op(blade, a);
	lcont(bladeInverse, tmp);
	return 0;
}

int i2gai::versorInverseEM(const i2gai &a) {
	i2gai reverse, scalar;
	reverse.reverse(a);
	scalar.scpem(a, reverse);
	if (scalar.c[0] == 0.0f) return -1;
	scalar.c[0] = 1.0f / scalar.c[0];
	op(scalar, reverse);
	return 0;
}

int i2gai::projectEM(const i2gai &blade, const i2gai &a) {
	i2gai tmp, bladeInverse;
	bladeInverse.versorInverseEM(blade);
	tmp.lcem(a, blade);
	lcem(tmp, bladeInverse);
	return 0;
}

// todo: ensure everything is euclidean...
int i2gai::factor(i2gai factors[], int versor /* = 0 */) const {
	i2gai ca[2], tmp, fi, tmpbv;
	int ga = (versor) ? maxGrade() : grade(), n = 0, i, idx, cca = 0, gu = gradeUsage(), bev;
	double maxC, tmpC, mul, *c2;
	const double *tmpc;
	static double bvc[6] = {1.0, 0.0, 0.0, 0.0, 0.0, 0.0};

	if (ga <= 0) return 0;

	// compute the multiplication factor require to make every factor of the same order of magnitude
	mul = (double)pow((double)sqrt((double)norm_a()), 1.0 / (double)ga);

	// setup current 'a'
	ca[0].copy(*this);

	// get the coordinate array for grade 'ga'
	tmpc = coordinates(1 << ga);

	// find out the maximum coordinate
	maxC = (double)fabs(tmpc[idx = 0]);
	for (i = 1; i < i2gai_gradeSize[ga]; i++) 
		if ( (tmpC = (double)fabs(ca[cca].c[i])) > maxC) {maxC = tmpC;idx = i;}

	// find out which basis vectors we have to project onto the blade
	idx += i2gai_mvSize[0xff >> (8 - ga)];
	bev = i2gai_newBevt[idx];

	// setup a basis vector
	tmpbv.setVector(bvc);
	c2 = tmpbv.c;
	idx = 0;

	i = 1;
	for (; ga > 1; ga--) {
		// find the next coordinate
		do { // note: the first coordinate is always skipped; this is note a bug 
			c2[idx++] = 0.0; // direct manipulation of 'bv'; hack
			c2[idx] = 1.0; // direct manipulation of 'bv'; hack
			i <<= 1;
		} while (!(bev & i));

		tmp.projectEM(ca[cca], tmpbv);
		factors[n].op(mul, tmp); // make all factors approximatelly the same size

		// remove the factor from the blade
		fi.versorInverseEM(factors[n++]); 
		if (versor) ca[cca ^ 1].gpem(fi, ca[cca]);
		else ca[cca ^ 1].lcem(fi, ca[cca]);
		cca ^= 1;
	}

	factors[n++].takeGrade(ca[cca], GRADE1);	// the last factor is equal to the remaining vector

	return n;
}


int i2gai::deltaProduct(const i2gai &a, const i2gai &b) {
	i2gai mv1;
	mv1.gpem(a, b);
	return this->highestGrade(mv1);
}

int i2gai::join(const i2gai &a, const i2gai &b, int algorithm /*= 1*/) {
	i2gai d, factors[6];
	int gj, ga = a.grade(), gb = b.grade(), gd;
	i2gai ca, cb;

	// if we are not handed homogeneous multivectors, take the grade parts with the largest norm
	if (ga < 0) {
		ga = a.largestGrade();
		ca.takeGrade(a, 1 << ga);
	}
	else ca.copy(a);

	if (gb < 0) {
		gb = b.largestGrade();
		cb.takeGrade(b, 1 << gb);
	}
	else cb.copy(b);

	// determine the grade of the join
	if (ga == 0) { // then the join is equal to b
		op(ca, cb); return gb;
	}
	else if (gb == 0) { // then the join is equal to a
		op(cb, ca); return ga;
	}
	else { // the join must be computed
		gd = d.deltaProduct(ca, cb);
		gj = (ga + gb + gd) >> 1;
		return (algorithm == 1) 
			? joinAlg1(ca, cb, ga, gb, gj)
			: joinAlg2(ca, cb, ga, gb, gj);
	}
}

int i2gai::meet(const i2gai &a, const i2gai &b, int algorithm /*= 1*/) {
	i2gai d, factors[6], j, jinv;
	int ga = a.grade(), gb = b.grade(), gd;

	i2gai ca, cb;

	// if we are not handed homogeneous multivectors, take the grade parts with the largest norm
	if (ga < 0) {
		ga = a.largestGrade();
		ca.takeGrade(a, 1 << ga);
	}
	else ca.copy(a);

	if (gb < 0) {
		gb = b.largestGrade();
		cb.takeGrade(b, 1 << gb);
	}
	else cb.copy(b);

	// compute delta product, join, ->meet
	gd = d.deltaProduct(ca, cb);
	j.join(ca, cb, algorithm);
	if (jinv.versorInverse(j)) {
		null();
		return 0;
	}
	lcem(d, jinv);
	return (ga + gb - gd) >> 1;
}

// todo: ensure everything is euclidean...
int i2gai::joinAlg2(const i2gai &a, const i2gai &b, int ga, int gb, int gj) {
	i2gai mv1, factors[6];
	int cg, lg, nf; // gj = grade join, gd = grade delta product

	// check for pseudoscalar case:
	if (gj == 6) {
		copy(I);
		return gj;
	}
	
	/*
	we pick the highest-dimension blade to start with,
	and factor the other blade
	*/
	i2gai res[7];
	int factorsTried[7];
	double largestNorm = -1.0f, nm;
	if (ga > gb) {
		if ( (nf = b.factor(factors)) != gb) return -1;	// should never happen
		lg = cg = ga;
		res[cg].copy(a);
	}
	else {
		if ( (nf = a.factor(factors)) != ga) return -1;	// should never happen
		lg = cg = gb;
		res[cg].copy(b);
	}

	// modification for bug of type 'join(e1, e1) = 0' (instead of e1) // 2003 10 28
	if (cg == gj) {	// if we have arrived at the grade of the join:
		copy(res[cg]);
		return gj;
	}

	/*
	Wegde as much factors as we need to get the right grade 
	*/
	factorsTried[cg] = 0;
	while (1) {
		// should we lower the current grade, and try the next factor?
		while (factorsTried[cg] >= nf) cg--;
		if (cg < lg) break;

		// wegde a factor to the result
		res[cg + 1].op(res[cg], factors[factorsTried[cg]]);
		factorsTried[cg + 1] = ++(factorsTried[cg]);
		cg++;

		if (cg == gj) {	// if we have arrived at the grade of the join:
			if ( (nm = res[cg].norm_a()) > largestNorm) {
				largestNorm = nm;
				copy(res[cg]);
			}
			cg--;
		}
	}

	return gj;
}

int i2gai::joinAlg1(const i2gai &a, const i2gai &b, int ga, int gb, int gj) {
	i2gai mv1, b1, b2, factors[6];
	int i, rg, gs; // gj = grade join, gd = grade delta product, rg = required grade, gs = grade size

	// check for pseudoscalar case:
	if (gj == 6) {
		copy(I);
		return gj;
	}

	/* we pick the highest-dimension blade (b1) to start with */
	i2gai be, pbe, tmp; // be = basis element, pbe = projected basis element
	double v1[20];
	double largestNorm = -1.0f, nm;
	if (ga > gb) {
		b1.copy(a);
		rg = gj - ga;
		b2.copy(b);
	}
	else {
		b1.copy(b);
		rg = gj - gb;
		b2.copy(a);
	}

	// project all possible basis elements of grade 'rg' onto blade b2; wegde them with b1
	gs = i2gai_gradeSize[rg];

	// modification for bug of type 'join(e1, e1) = 0' (instead of e1) // 2003 10 28
	if (gs == 0) { // nothing to do, since 'b1' already has the require grade
		copy(b1);
		return gj;
	}
	
	// modification for custom float (december 9 2002)
	i2gai_null(v1, gs);

	be.set(1 << rg, v1);
	for (i = 0; i < gs; i++) {
		be.c[i] = 1.0f;	// hack
		if (i) be.c[i-1] = 0.0f; // hack
		pbe.projectEM(b2, be);
		tmp.op(b1, pbe);
		if ( (nm = tmp.norm_a()) > largestNorm) {
			largestNorm = nm;
			copy(tmp);
		}
	}

	return gj;
}


int i2gai::random(int grade, double scale, int versor) {

	scale *= (double)2.0;

	// compute how many vector we have to multiply/wegd
	int nb = -1;
	while (grade) {
		grade >>= 1;
		nb++;
	}
	if (nb < 0) return -1;
	else if (nb == 0) {
		setScalar(scale * ((double)rand() / (double)2147483647 - (double)0.5));
	}
	else {
		int i, j, ct = 0;
		i2gai rv, tmp[2];
		double v[6], scalar = (double)1.0;

		tmp[0].setScalar(&scalar);
		for (i = 0; i < nb; i++) {
			// create a random vector
			for (j = 0; j < 6; j++)
				v[j] = scale * ((double)rand() / (double)2147483647 - (double)0.5);
			rv.setVector(v);

			// multiply/wegde it to the result
			if (versor) tmp[ct ^ 1].gp(tmp[ct], rv);
			else tmp[ct ^ 1].op(tmp[ct], rv);

			ct ^= 1;
		}

		copy(tmp[ct]);
	}

	return 0;
}

int i2gai::reciprocalFrame(i2gai f[], const i2gai e[], int nbVectors) {
	int cb = 0, i, err, ca, j;
	double scalar = 1.0f;
	i2gai B[2], Bi, tmp, einv, A[2];

	if ((nbVectors <= 0) || (nbVectors > 6)) return 0;

	// build the blade which is the pseudoscalar for the frame 
	B[cb].copy(e[0]);
	for (i = 1; i < nbVectors; i++) {
		B[cb^1].op(B[cb], e[i]);
		cb ^= 1;
	}

	// computer the inverse of the frame
	if (err = Bi.versorInverse(B[cb])) return err;

	// compute the reciprocal vectors
	for (i = 0; i < nbVectors; i++) {
		ca = 0;

		// compute te right scalar factor
		scalar = (i & 1) ? -1.0f : 1.0f;
		A[ca].setScalar(&scalar);

		// compute the blade, with omission of vector e[i]
		for (j = 0; j < nbVectors; j++) {
			if (j == i) continue;
			A[ca^1].op(A[ca], e[j]);
			ca ^= 1;
		}

		// compute reciprocal vector f[i]
		f[i].lcont(A[ca], Bi);
	}

	return 0;
}

int i2gai::mvType(int *grade /*= NULL*/, double epsilon /* = 1e-14 */) const {
// this code fails on 'e1 + (e2 ^ e3)' (says it versor, while it isn't)
	// a = *this
	// compute versor inverse of input
	if (grade) *grade = 0;

	i2gai reverse, scalar, ai;
	reverse.reverse(*this);
	scalar.scpem(*this, reverse); 
	if ((scalar.c == NULL) || (scalar.c[0] == 0.0f)) return GA_MULTIVECTOR;
	scalar.c[0] = 1.0f / scalar.c[0];
	ai.op(scalar, reverse);

	// check if ai * a = 1
	i2gai mv1, mv2, mv3;
	mv1.gpem(ai, *this); 
	mv1.compress(epsilon);
	if (mv1.gradeUsage() > GRADE0) return GA_MULTIVECTOR;
	if ((mv1.gradeUsage() == 0) || (mv1.c[0] < 1.0f - epsilon) || (mv1.c[0] > 1.0f + epsilon)) 
		return GA_MULTIVECTOR;

	// check if a * ai = 1
	mv1.gpem(*this, ai); 
	mv1.compress(epsilon);
	if (mv1.gradeUsage() > GRADE0) return GA_MULTIVECTOR;
	if ((mv1.gradeUsage() == 0) || (mv1.c[0] < 1.0f - epsilon) || (mv1.c[0] > 1.0f + epsilon)) 
		return GA_MULTIVECTOR;

	// test if ai * x * a is of the same grade as 'x' for all basis vectors
	int i, j, g;
	for (i = 0; i < 6; i++) { 
		mv1.gpem(ai, *i2gai::bv[i]);  // todo: EUCLIDEAN?
		mv2.gpem(mv1, *this);  
		mv2.compress(epsilon);
		if (mv2.gradeUsage() & (0xffff ^ GRADE1)) return GA_MULTIVECTOR;
	}

	// normalize 'a' (this is to make sure we don't misqualify 'small' (<epsilon) versors as blades
	scalar.setScalar(sqrt(fabs(scalar.c[0])));
	ai.op(scalar, *this);

	// test if a is of a single grade
	ai.compress(epsilon);
	i = ai.gradeUsage(); j = 0;
	g = GRADE0;
	while (i) {
		if (grade && (i & 1)) *grade = g;
		j += i & 1;
		i >>= 1;
		g <<= 1;
	}
	return (j <= 1) ? GA_BLADE : GA_VERSOR;
}

static int memberOf(char c, const char *set) { 
	int i = 0;
	while (set[i]) {
		if (c == set[i]) return 1;
		i++;
	}
	return 0;
}

int i2gai::parseString(const char *str, const i2ga_ben *ben /*= NULL*/) {
	int idx = 0, pmCnt, beCnt = 0;
	const int strLength = 256;
	double scalar;
	int floatStart, floatEnd, bvStart, bvEnd, i;
	i2gai blade, bv, BE, tmp;
	int stage = 0;
	char floatStr[strLength], bvStr[strLength];

	i2ga_ben defaultBen;
	if (ben == NULL) ben = &defaultBen;

	null();

	if (ben->m_startDelimiter) {
		// the first character found must be equal to m_startDelimiter
		while (str[idx] <= ' ') { // skip space until something happens
			if (str[idx] == 0) return -1; // nothing read
			idx++;
		}
		if (str[idx] != ben->m_startDelimiter) return -1; // first character is not the m_startDelimiter
		idx++;
	}

	for (;;) {
		blade.setScalar((double)1.0);
		scalar = (double)1;

		while (str[idx] <= ' ') { // skip space until something happens
			if (str[idx] == 0) return (ben->m_endDelimiter) ? -1 : idx; // done or error
			idx ++;
		}

		i = idx;
		pmCnt = 0; // plus minus count
		for (;;) { // parse [+|-]+
			if (str[idx] == '+') {scalar *= (double)+1; pmCnt++;}
			else if (str[idx] == '-') {scalar *= (double)-1; pmCnt++;}
			else if (memberOf(str[idx], "0123456789.")) break; // start of the float
			else if ((str[idx] > 0) && (str[idx] <= ' ')); // skip space
			else break;
			idx++;
		}
		if (beCnt && (!pmCnt)) return -1;

		if (memberOf(str[idx], "0123456789.")) { // parse float and '*' or '^'
			// parse the float
			floatStart = idx;
			while (memberOf(str[idx],  "0123456789.eE") ||
				(idx && ((str[idx-1] == 'e') || (str[idx-1] == 'E')) && ((str[idx] == '-') || (str[idx] == '+'))))  idx++;
			floatEnd = idx;
			memcpy(floatStr, str + floatStart, floatEnd - floatStart);
			floatStr[floatEnd - floatStart] = 0;
			if (floatEnd - floatStart <= 0) return -1;
			scalar *= (double)atof(floatStr);

			while (str[idx] <= ' ') { // skip space until something happens
				if (str[idx] == 0) {
					tmp.copy(*this); add(scalar, tmp);
					return (ben->m_endDelimiter) ? -1 : idx; // done or error
				}
				idx++;
			}

			// check if next char is +,-,* or 'ben->m_endDelimiter'
			if ((str[idx] == '+') || (str[idx] == '-')) {
				tmp.copy(*this); add(scalar, tmp);
				beCnt++;
				continue;
			}
			else if (ben->m_endDelimiter && (str[idx] == ben->m_endDelimiter)) { // end delimiter
				tmp.copy(*this); add(scalar, tmp);
				return idx+1;
			}
			else if ((str[idx] != '*') && (str[idx] != '^')) return -1; // must be either +,-, ^ or *
			else idx++; // skip over '*' or '^'

			while (str[idx] <= ' ') { // skip space until something happens
				if (str[idx] == 0) return -1; // error
				idx++;
			}
		}

		for (;;) { // parse a basis element ex ^ ey ^ ez
			bvStart = idx; // find the start and end of the basis vector name
			while ((str[idx] > ' ') && (str[idx] != '-') && (str[idx] != '+') && (str[idx] != '^') && (str[idx] != ben->m_endDelimiter)) idx ++;
			bvEnd = idx;

			// copy name, parse it 
			if ((bvEnd - bvStart + 1) >= strLength) return -1; // error (string too long)
			memcpy(bvStr, str + bvStart, bvEnd - bvStart);
			bvStr[bvEnd - bvStart] = 0;
			if (ben->lookupName(bvStr, BE) < 0) return -1; // basis vector name is invalid

			tmp.copy(blade); blade.op(tmp, BE); // wedge the basis element to the blade

			while (str[idx] <= ' ') { // skip space until something happens
				if ((str[idx] == 0) || (str[idx] == ben->m_endDelimiter))  break;
				idx++;
			}
			
			// next char must be a wedge, or this is the end of the blade
			if (str[idx] != '^') break;
			idx++;
		}

		tmp.op(scalar, blade);
		blade.copy(*this);
		add(blade, tmp);
		beCnt++;

		if (str[idx] == ben->m_endDelimiter) return idx + 1;

	}
	return idx; // the function never arrives here?
}

void i2gai::om(const i2gai &a, const i2gai_om &om) {
	int ia = 0;
	setUsage(a.usage);

	if (gradeUsage() & 1) {
		i2gai_opt_om_01x01(om.c + 0, a.c + ia, c + ia);
		ia += 1;
	}

	if (gradeUsage() & 2) {
		i2gai_opt_om_06x06(om.c + 1, a.c + ia, c + ia);
		ia += 6;
	}

	if (gradeUsage() & 4) {
		i2gai_opt_om_0Fx0F(om.c + 37, a.c + ia, c + ia);
		ia += 15;
	}

	if (gradeUsage() & 8) {
		i2gai_opt_om_14x14(om.c + 262, a.c + ia, c + ia);
		ia += 20;
	}

	if (gradeUsage() & 16) {
		i2gai_opt_om_0Fx0F(om.c + 662, a.c + ia, c + ia);
		ia += 15;
	}

	if (gradeUsage() & 32) {
		i2gai_opt_om_06x06(om.c + 887, a.c + ia, c + ia);
		ia += 6;
	}

	if (gradeUsage() & 64) {
		i2gai_opt_om_01x01(om.c + 923, a.c + ia, c + ia);
		ia += 1;
	}

}

void i2gai::expand(const double *pa[7]) const {
	int ia = 0;
	int i, j = 1;
	for (i = 0; i < 7; i++) {
		if (gradeUsage() & j) {
			pa[i] = c + ia;
			ia += i2gai_gradeSize[i];
		}
		else pa[i] = NULL;
		j <<= 1;
	}
}

void i2gai::expand2i(const i2gai &b, double const *pa[7], double const *pb[7]) const {
	int ia = 0;
	int i, j = 1;
	for (i = 0; i < 7; i++) {
		if (gradeUsage() & j) {
			pa[i] = c + ia;
			pb[i] = b.c + ia;
			ia += i2gai_gradeSize[i];
		}
		else pa[i] = pb[i] = NULL;
		j <<= 1;
	}
}

void i2gai::expand(const i2gai &b, double const *pa[7], double const *pb[7]) const {
	int ia = 0, ib = 0;
	int i, j = 1;
	for (i = 0; i < 7; i++) {
		if (gradeUsage() & j) {
			pa[i] = c + ia;
			ia += i2gai_gradeSize[i];
		}
		else pa[i] = NULL;
		if (b.gradeUsage() & j) {
			pb[i] = b.c + ib;
			ib += i2gai_gradeSize[i];
		}
		else pb[i] = NULL;
		j <<= 1;
	}
}

void i2gai::compress(double coordinates[64]) {
	int i, j, k, l, s, u;
	double cc[64];
	l = k = u = 0;
	for (i = 0; i < 7; i++) {
		s = i2gai_gradeSize[i];
		for (j = 0; j < s; j++)
			if (coordinates[k + j] != 0.0f) {
				u |= (1 << i);
				i2gai_copy(cc + l, coordinates + k, s);
				l += s;
				break;
			}
		k += s;
	}
	setUsage(u | (l << 7));
	i2gai_copy(c, cc, l);
}

const double *i2gai::coordinates(int grade) const {
	int ia = 0;
	int i, j = 1, gu = gradeUsage();
	static const double null[64] = {0}; // temp test for Brian Bouta problem
	for (i = 0; i < 7; i++) {
		if (j == grade) return (gu & j) ? c + ia : null;
		if (gu & j) ia += i2gai_gradeSize[i];
		j <<= 1;
	}
	return null;
}

int i2gai::fastDual(const i2gai &a) {
	setUsage(a.usage);
	int gua = a.gradeUsage(), gud = 0;
	int ia = i2gai_mvSize[gua], id = 0;
	const double *ca = a.c;
	double *cd = c;
	if (gua & GRADE6) {
		gud |= GRADE0;
		ia -= i2gai_gradeSize[6];
		cd[id + 0] = ca[ia + 0];
		id += i2gai_gradeSize[0];
	}
	if (gua & GRADE5) {
		gud |= GRADE1;
		ia -= i2gai_gradeSize[5];
		cd[id + 4] = ca[ia + 0];
		cd[id + 5] = -ca[ia + 1];
		cd[id + 2] = ca[ia + 2];
		cd[id + 3] = -ca[ia + 3];
		cd[id + 1] = -ca[ia + 4];
		cd[id + 0] = ca[ia + 5];
		id += i2gai_gradeSize[1];
	}
	if (gua & GRADE4) {
		gud |= GRADE2;
		ia -= i2gai_gradeSize[4];
		cd[id + 14] = ca[ia + 0];
		cd[id + 8] = ca[ia + 1];
		cd[id + 9] = -ca[ia + 2];
		cd[id + 7] = -ca[ia + 3];
		cd[id + 6] = ca[ia + 4];
		cd[id + 12] = -ca[ia + 5];
		cd[id + 13] = ca[ia + 6];
		cd[id + 11] = ca[ia + 7];
		cd[id + 10] = -ca[ia + 8];
		cd[id + 5] = ca[ia + 9];
		cd[id + 2] = -ca[ia + 10];
		cd[id + 1] = ca[ia + 11];
		cd[id + 4] = ca[ia + 12];
		cd[id + 3] = -ca[ia + 13];
		cd[id + 0] = -ca[ia + 14];
		id += i2gai_gradeSize[2];
	}
	if (gua & GRADE3) {
		gud |= GRADE3;
		ia -= i2gai_gradeSize[3];
		cd[id + 18] = ca[ia + 0];
		cd[id + 19] = -ca[ia + 1];
		cd[id + 17] = -ca[ia + 2];
		cd[id + 16] = ca[ia + 3];
		cd[id + 9] = ca[ia + 4];
		cd[id + 6] = -ca[ia + 5];
		cd[id + 5] = ca[ia + 6];
		cd[id + 8] = ca[ia + 7];
		cd[id + 7] = -ca[ia + 8];
		cd[id + 4] = -ca[ia + 9];
		cd[id + 15] = -ca[ia + 10];
		cd[id + 12] = ca[ia + 11];
		cd[id + 11] = -ca[ia + 12];
		cd[id + 14] = -ca[ia + 13];
		cd[id + 13] = ca[ia + 14];
		cd[id + 10] = ca[ia + 15];
		cd[id + 3] = -ca[ia + 16];
		cd[id + 2] = ca[ia + 17];
		cd[id + 0] = -ca[ia + 18];
		cd[id + 1] = ca[ia + 19];
		id += i2gai_gradeSize[3];
	}
	if (gua & GRADE2) {
		gud |= GRADE4;
		ia -= i2gai_gradeSize[2];
		cd[id + 14] = ca[ia + 0];
		cd[id + 11] = -ca[ia + 1];
		cd[id + 10] = ca[ia + 2];
		cd[id + 13] = ca[ia + 3];
		cd[id + 12] = -ca[ia + 4];
		cd[id + 9] = -ca[ia + 5];
		cd[id + 4] = -ca[ia + 6];
		cd[id + 3] = ca[ia + 7];
		cd[id + 1] = -ca[ia + 8];
		cd[id + 2] = ca[ia + 9];
		cd[id + 8] = ca[ia + 10];
		cd[id + 7] = -ca[ia + 11];
		cd[id + 5] = ca[ia + 12];
		cd[id + 6] = -ca[ia + 13];
		cd[id + 0] = -ca[ia + 14];
		id += i2gai_gradeSize[4];
	}
	if (gua & GRADE1) {
		gud |= GRADE5;
		ia -= i2gai_gradeSize[1];
		cd[id + 5] = -ca[ia + 0];
		cd[id + 4] = ca[ia + 1];
		cd[id + 2] = -ca[ia + 2];
		cd[id + 3] = ca[ia + 3];
		cd[id + 0] = -ca[ia + 4];
		cd[id + 1] = ca[ia + 5];
		id += i2gai_gradeSize[5];
	}
	if (gua & GRADE0) {
		gud |= GRADE6;
		ia -= i2gai_gradeSize[0];
		cd[id + 0] = -ca[ia + 0];
		id += i2gai_gradeSize[6];
	}

	usage = gud | (usage ^ gua);
	return 0;
}

void i2gai::gp(const i2gai &a, const i2gai &b) {
	double const *pa[7], *pb[7];
	double cc[64];
	int u, i = i2gai_map_gp_a[a.gradeUsage()] | i2gai_map_gp_b[b.gradeUsage()];

	if ( (u = i2gai_resultUsage_gp[i]) >= 0) {
		setUsage(u);
		i2gai_func_gp[i](a.c, b.c, c);
	}
	else {
		a.expand(b, pa, pb);
		((i2gai_genFuncPtr)i2gai_func_gp[i])(pa, pb, cc);
		compress(cc);
	}
}

void i2gai::hip(const i2gai &a, const i2gai &b) {
	double const *pa[7], *pb[7];
	double cc[64];
	int u, i = i2gai_map_hip_a[a.gradeUsage()] | i2gai_map_hip_b[b.gradeUsage()];

	if ( (u = i2gai_resultUsage_hip[i]) >= 0) {
		setUsage(u);
		i2gai_func_hip[i](a.c, b.c, c);
	}
	else {
		a.expand(b, pa, pb);
		((i2gai_genFuncPtr)i2gai_func_hip[i])(pa, pb, cc);
		compress(cc);
	}
}

void i2gai::mhip(const i2gai &a, const i2gai &b) {
	double const *pa[7], *pb[7];
	double cc[64];
	int u, i = i2gai_map_mhip_a[a.gradeUsage()] | i2gai_map_mhip_b[b.gradeUsage()];

	if ( (u = i2gai_resultUsage_mhip[i]) >= 0) {
		setUsage(u);
		i2gai_func_mhip[i](a.c, b.c, c);
	}
	else {
		a.expand(b, pa, pb);
		((i2gai_genFuncPtr)i2gai_func_mhip[i])(pa, pb, cc);
		compress(cc);
	}
}

void i2gai::lcont(const i2gai &a, const i2gai &b) {
	double const *pa[7], *pb[7];
	double cc[64];
	int u, i = i2gai_map_lcont_a[a.gradeUsage()] | i2gai_map_lcont_b[b.gradeUsage()];

	if ( (u = i2gai_resultUsage_lcont[i]) >= 0) {
		setUsage(u);
		i2gai_func_lcont[i](a.c, b.c, c);
	}
	else {
		a.expand(b, pa, pb);
		((i2gai_genFuncPtr)i2gai_func_lcont[i])(pa, pb, cc);
		compress(cc);
	}
}

void i2gai::rcont(const i2gai &a, const i2gai &b) {
	double const *pa[7], *pb[7];
	double cc[64];
	int u, i = i2gai_map_rcont_a[a.gradeUsage()] | i2gai_map_rcont_b[b.gradeUsage()];

	if ( (u = i2gai_resultUsage_rcont[i]) >= 0) {
		setUsage(u);
		i2gai_func_rcont[i](a.c, b.c, c);
	}
	else {
		a.expand(b, pa, pb);
		((i2gai_genFuncPtr)i2gai_func_rcont[i])(pa, pb, cc);
		compress(cc);
	}
}

void i2gai::op(const i2gai &a, const i2gai &b) {
	double const *pa[7], *pb[7];
	double cc[64];
	int u, i = i2gai_map_op_a[a.gradeUsage()] | i2gai_map_op_b[b.gradeUsage()];

	if ( (u = i2gai_resultUsage_op[i]) >= 0) {
		setUsage(u);
		i2gai_func_op[i](a.c, b.c, c);
	}
	else {
		a.expand(b, pa, pb);
		((i2gai_genFuncPtr)i2gai_func_op[i])(pa, pb, cc);
		compress(cc);
	}
}

void i2gai::op(double scalar, const i2gai &b) {
	double const *pa[7], *pb[7];
	double cc[64];
	int u, i = i2gai_map_op_a[GRADE0] | i2gai_map_op_b[b.gradeUsage()];

	if ( (u = i2gai_resultUsage_op[i]) >= 0) {
		setUsage(u);
		i2gai_func_op[i](&scalar, b.c, c);
	}
	else {
		b.expand(pb);
		memset(pa + 1, 0, sizeof(double*) * 6);
		pa[0] = &scalar;
		((i2gai_genFuncPtr)i2gai_func_op[i])(pa, pb, cc);
		compress(cc);
	}
}

void i2gai::scp(const i2gai &a, const i2gai &b) {
	double const *pa[7], *pb[7];
	double cc[64];
	int u, i = i2gai_map_scp_a[a.gradeUsage()] | i2gai_map_scp_b[b.gradeUsage()];

	if ( (u = i2gai_resultUsage_scp[i]) >= 0) {
		setUsage(u);
		i2gai_func_scp[i](a.c, b.c, c);
	}
	else {
		a.expand(b, pa, pb);
		((i2gai_genFuncPtr)i2gai_func_scp[i])(pa, pb, cc);
		compress(cc);
	}
}

void i2gai::gpem(const i2gai &a, const i2gai &b) {
	double const *pa[7], *pb[7];
	double cc[64];
	int u, i = i2gai_map_gpem_a[a.gradeUsage()] | i2gai_map_gpem_b[b.gradeUsage()];

	if ( (u = i2gai_resultUsage_gpem[i]) >= 0) {
		setUsage(u);
		i2gai_func_gpem[i](a.c, b.c, c);
	}
	else {
		a.expand(b, pa, pb);
		((i2gai_genFuncPtr)i2gai_func_gpem[i])(pa, pb, cc);
		compress(cc);
	}
}

void i2gai::lcem(const i2gai &a, const i2gai &b) {
	double const *pa[7], *pb[7];
	double cc[64];
	int u, i = i2gai_map_lcem_a[a.gradeUsage()] | i2gai_map_lcem_b[b.gradeUsage()];

	if ( (u = i2gai_resultUsage_lcem[i]) >= 0) {
		setUsage(u);
		i2gai_func_lcem[i](a.c, b.c, c);
	}
	else {
		a.expand(b, pa, pb);
		((i2gai_genFuncPtr)i2gai_func_lcem[i])(pa, pb, cc);
		compress(cc);
	}
}

void i2gai::scpem(const i2gai &a, const i2gai &b) {
	double const *pa[7], *pb[7];
	double cc[64];
	int u, i = i2gai_map_scpem_a[a.gradeUsage()] | i2gai_map_scpem_b[b.gradeUsage()];

	if ( (u = i2gai_resultUsage_scpem[i]) >= 0) {
		setUsage(u);
		i2gai_func_scpem[i](a.c, b.c, c);
	}
	else {
		a.expand(b, pa, pb);
		((i2gai_genFuncPtr)i2gai_func_scpem[i])(pa, pb, cc);
		compress(cc);
	}
}
void i2gai_opt_zero_result(const double *a, const double *b, double *c) {};

int i2gai::resetProfile() {
	return 0;
}
int i2gai::printProfile(float threshold /* = 2.0 */) {
	return 0;
}
int i2gai::saveProfile(const char *filename /*  = NULL */) {
	return 0;
}

i2gai_om::i2gai_om() {
	// modification for custom float (december 9 2002)
	i2gai_null(c, 924);
}

i2gai_om::~i2gai_om() {
}

i2gai_om::i2gai_om(const i2gai vectorImages[6]) {
	initOuterMorphism(vectorImages);
}
i2gai_om::i2gai_om(const i2gai *vectorImages[6]) {
	initOuterMorphism(vectorImages);
}

int i2gai_om::initOuterMorphism(const i2gai vectorImages[6]) {
	const i2gai *vi[6];
	int i;
	for (i = 0; i < 6; i++)
		vi[i] = vectorImages + i;
	return initOuterMorphism(vi);
}

int i2gai_om::initOuterMorphism(const i2gai *vectorImages[6]) {
	int beComputed[64], i, j, k, ic, gs, bei;	// be = Basis Element
	i2gai be[64];
	double scalar = 1.0f;
	const double *bec;

	// set all vectors
	for (i = 1; i <= 6; i++) {
		be[i].takeGrade(*(vectorImages[i-1]), GRADE1);
		beComputed[i] = 1;
	}

	// compute all the other basis elements
	memset(beComputed + 6 + 1, 0, sizeof(int) * (64 - 6 - 1));
	for (i = 6 + 1; i < 64; i++)
		computeBE(be, beComputed, i);

	// insert all coordinates into the matrix
	ic = 1;
	bei = 1;
	for (i = 1; i <= 6; i++) {
		gs = i2gai_gradeSize[i];
		for (j = 0; j < gs; j++) {
			bec = be[bei].coordinates(1 << i);
			for (k = 0; k < gs; k++) {
				c[ic + k * gs] = bec[k];
			}
			ic++;
			bei++;
		}
		ic += gs * (gs-1);
	}
	return 0;
}

int i2gai_om::computeBE(i2gai be[64], int beComputed[64], int idx) {
	int i, j, err;
	i2gai tmp;

	if (!beComputed[i = i2gai_omct[idx * 3 + 0]])
		if (err = computeBE(be, beComputed, i)) return err;
	if (!beComputed[j = i2gai_omct[idx * 3 + 1]])
		if (err = computeBE(be, beComputed, j)) return err;

	if (i2gai_omct[idx * 3 + 2] < 0) {
		tmp.negate(be[i]);
		be[idx].op(tmp, be[j]);
	}
	else {
		be[idx].op(be[i], be[j]);
	}

	beComputed[idx] = 1;

	return 0;
}

int i2gai_om::initSpinor2(const i2gai &Sp) {
	int i;
	i2gai Spi, vectorImages[3], tmp, tmp2;
	Spi.versorInverse(Sp);

	for (i = 0; i < 6; i++) {
		tmp.gp(Sp, *(i2gai::bv[i]));
		tmp2.gp(tmp, Spi);
		vectorImages[i].takeGrade(tmp2, GRADE1);
	}
	
	return initOuterMorphism(vectorImages);
}

i2gai_be::i2gai_be(const char *name, const i2gai &mv) {
	initToNothing();

	if (name) m_name = strdup(name);
	m_mv.copy(mv);
}

i2gai_be::~i2gai_be() {
	if (m_name) free(m_name);
	initToNothing();
}

void i2gai_be::initToNothing() {
	m_name = NULL;
	m_mv.null();
}

int i2gai_be::compareName(const char *name)  const {
	if ((name == NULL) || (m_name == NULL)) return 0;
	return (!strcmp(name, m_name));
}

i2ga_ben::i2ga_ben() {
	initToNothing();
	setDefaults();
}

i2ga_ben::i2ga_ben(char startDelimiter, char endDelimiter) {
	initToNothing();
	setDefaults();
	setDelimiters(startDelimiter, endDelimiter);
}

i2ga_ben::~i2ga_ben() {
	removeAll();
	initToNothing();
}

void i2ga_ben::initToNothing() {
	m_ben = NULL;
	m_nbBen = 0;
	m_startDelimiter = m_endDelimiter = 0;
}

int i2ga_ben::removeAll() {
	int i;
	if (m_ben) {
		for (i = 0; i < m_nbBen; i++)
			if (m_ben[i]) delete m_ben[i];
		free(m_ben);
	}
	m_ben = NULL;
	m_nbBen = 0;
	return 0;
}

int i2ga_ben::addName(const char *name, const i2gai &mv) {
	i2gai tmpMv;
	if (lookupName(name, tmpMv) == 0) return -1; // already present in list
	
	if ( (m_ben = (i2gai_be**)realloc(m_ben, sizeof(i2gai_be*) * (m_nbBen + 1))) == NULL) {
		printf("i2ga_ben::addName(): memory allocation failure for '%d' bytes\n", sizeof(i2gai_be*) * (m_nbBen + 1));
		return -1;
	}

	if ( (m_ben[m_nbBen] = new i2gai_be(name, mv)) == NULL) {
		printf("i2ga_ben::addName(): memory allocation failure for '%d' bytes\n", sizeof(i2gai_be));
		return -1;
	}

	m_nbBen++;

	return 0;
}

int i2ga_ben::removeName(const char *name) {
	int i;

	for (i = 0; i < m_nbBen; i++)
		if (m_ben[i]->compareName(name)) {
			delete m_ben[i];
			m_ben[i] = m_ben[m_nbBen - 1];
			m_nbBen--;
			i--;
		}

	return 0;
}

int i2ga_ben::lookupName(const char *name, i2gai &mv) const {
	int i;

	for (i = 0; i < m_nbBen; i++)
		if (m_ben[i]->compareName(name)) {
			mv.copy(m_ben[i]->m_mv);
			return 0;
		}

	return -1;
}

int i2ga_ben::setDelimiters(char startDelimiter, char endDelimiter) {
	if ((startDelimiter < 0) || (endDelimiter < 0)) return -1;
	m_startDelimiter = startDelimiter;
	m_endDelimiter = endDelimiter;
	return 0;
}

int i2ga_ben::setDefaults() {
	int err;
	removeAll();
	m_startDelimiter = m_endDelimiter = 0;
	if (err = addName("e1", i2gai::e1)) return err;
	if (err = addName("e2", i2gai::e2)) return err;
	if (err = addName("no", i2gai::no)) return err;
	if (err = addName("ni", i2gai::ni)) return err;
	if (err = addName("go", i2gai::go)) return err;
	if (err = addName("gi", i2gai::gi)) return err;
	return 0;
}


//Merging /usr/local/include/gaigen/gaigenhl.cpp into generated code:

// DO NOT TRY TO COMPILE THIS FILE DIRECTLY.
// IT IS MEANT TO BE INCLUDED BY GENERATED CODE!

/*
 *
 * Gaigen, Copyright (c) 2001-2004, University of Amsterdam
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *      * Redistributions of source code must retain the above copyright
 *        notice, this list of conditions and the following disclaimer.
 *      * Redistributions in binary form must reproduce the above copyright
 *        notice, this list of conditions and the following disclaimer in
 *        the documentation and/or other materials provided with the
 *        distribution.
 *      * Neither the name of the University of Amsterdam nor the names of its
 *        contributors may be used to endorse or promote products derived
 *        from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
 * CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
 * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 */


#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#ifdef GAIM_NAMESPACE
namespace CLASSNAME_NS {
#endif // GAIM_NAMESPACE

CLASSNAME::CLASSNAME() {

}
/*
CLASSNAME::CLASSNAME(GAIM_CLASSNAME &a) {
	copy(a);
}
*/
CLASSNAME::~CLASSNAME() {

}

GAIM_RETURN_TYPE CLASSNAME::operator=(const CLASSNAME &a) {
	copy(a);
	return *this;
}

GAIM_RETURN_TYPE CLASSNAME::operator=(GAIM_FLOAT f) {
	set(GRADE0, &f);
	return *this;
}

#ifdef GAIM_FUNCTION_FASTTEMPVAR
GAIM_RETURN_TYPE CLASSNAME::getTemp() {
	// gets a temporary variable (based on Stroustup (heaven help you if you write an expression which requires more than MV_MAX_TEMP temporaries))
	static int idx = 0;
	static CLASSNAME *temp = NULL;
	if (!temp) {
		int i;
		temp = new CLASSNAME[MV_MAX_TEMP];
		for (i = 0; i < MV_MAX_TEMP; i++) {
			temp[i].setUsage(0xf | (0x7 << 4));
			temp[i].setUsage(0);
		}
	}
//	printf("Temp idx = %d\n", idx);
	if (idx == MV_MAX_TEMP) idx = 0;
	return temp[idx++];
}
#endif // GAIM_FUNCTION_FASTTEMPVAR

#ifdef GAIM_FUNCTION_TAKEGRADE
GAIM_RETURN_TYPE CLASSNAME::grade(int g) const {
	GAIM_RETURN_VAR(result);
//	GAIM_RETURN_VAR(result);
	result.takeGrade(*this, g);
	return result;
}
#endif // GAIM_FUNCTION_TAKEGRADE


#ifdef GAIM_FUNCTION_REVERSE
GAIM_RETURN_TYPE CLASSNAME::operator~() const {
	GAIM_RETURN_VAR(result);
	((GAIM_CLASSNAME&)result).reverse(*this);
	return result;
}
#endif // GAIM_FUNCTION_REVERSE

#ifdef GAIM_FUNCTION_CLIFFORDCONJUGATE
GAIM_RETURN_TYPE CLASSNAME::operator--() const {
	GAIM_RETURN_VAR(result);
	((GAIM_CLASSNAME&)result).cliffordConjugate(*this);
	return result;
}
#endif // GAIM_FUNCTION_CLIFFORDCONJUGATE

#ifdef GAIM_FUNCTION_GRADEINVOLUTION
GAIM_RETURN_TYPE CLASSNAME::operator++() const {
	GAIM_RETURN_VAR(result);
	((GAIM_CLASSNAME&)result).gradeInvolution(*this);
	return result;
}
#endif // GAIM_FUNCTION_GRADEINVOLUTION

#ifdef GAIM_PRODUCT_GP
GAIM_RETURN_TYPE CLASSNAME::operator*=(const CLASSNAME &a) {
	CLASSNAME tmp;
	tmp.gp(*this, a);
	this->copy(tmp);
	return *this;
}
GAIM_RETURN_TYPE CLASSNAME::operator*=(GAIM_FLOAT a) {
	CLASSNAME tmp;
	tmp.op(a, *this);
	this->copy(tmp);
	return *this;
}
GAIM_RETURN_TYPE gp(const CLASSNAME &a, const CLASSNAME &b) {
	GAIM_RETURN_VAR(result);
	result.gp(a, b);
	return result;
}
GAIM_RETURN_TYPE gp(GAIM_FLOAT a, const CLASSNAME &b) {
	GAIM_RETURN_VAR(result);
	result.op(a, b);
	return result;
}

#define USE_NEW_EXP

#ifdef USE_OLD_EXP
GAIM_RETURN_TYPE CLASSNAME::exp(int order /*= 9*/) const {
	int i, div = 1;
	GAIM_RETURN_VAR(result);

	result.setScalar(1.0);
	if (order == 0) return result;

	CLASSNAME tmp(*this);

	for (i = 1; i < order; i++) {
		result += tmp * (GAIM_FLOAT)(1.0 / (GAIM_FLOAT)div);

		if (i < order-1) {
			div *= (i+1);
			tmp *= *this;
		}
	}

	return result;
}
#endif /* USE_OLD_EXP */

#ifdef USE_NEW_EXP
GAIM_RETURN_TYPE CLASSNAME::exp(int order /*= 9*/) const {
	/*
	Improved version of exp thanks to Robert Valkenburg & students
	*/
    int i;
    CLASSNAME result;

    result.setScalar(1.0);
    if (order == 0) {
        GAIM_RETURN_VAR(r);
        r = result;
        return r;
    }

    // scale by power of 2 so that its norm is < 1
    unsigned long max = (unsigned long)largestCoordinate();
    unsigned long scale=1;
    if (max > 1) scale <<= 1;
    while (max)
    {
        max >>= 1;
        scale <<= 1;
    }

    CLASSNAME scaled = (*this) / (GAIM_FLOAT)(scale);

    // taylor approximation
    CLASSNAME tmp;

    tmp.setScalar(1.0);
    for (i = 1; i < order; i++) {
        tmp = tmp*scaled/(GAIM_FLOAT)(i);
        result += tmp;
    }

    // undo scaling
    while (scale > 1)
    {
        result *= result;
        scale >>= 1;
    }
    GAIM_RETURN_VAR(r);
    r = result;
    return r;
}
#endif /* USE_NEW_EXP */


#ifndef GAIM_FUNCTION_FASTDUAL
GAIM_RETURN_TYPE CLASSNAME::dual() const {
	GAIM_RETURN_VAR(result);
	result.gp(*this, Ii);
	return result;
}
#endif // GAIM_FUNCTION_FASTDUAL

#endif // GAIM_PRODUCT_GP

#ifdef GAIM_PRODUCT_GP_EM
GAIM_RETURN_TYPE gpem (const CLASSNAME &a, const CLASSNAME &b) {
	GAIM_RETURN_VAR(result);
	result. GAIM_PRODUCT_GP_EM (a, b);
	return result;
}
GAIM_RETURN_TYPE gpem (GAIM_FLOAT a, const CLASSNAME &b) {
	GAIM_RETURN_VAR(result);
	result.op(a, b);
	return result;
}
#endif // GAIM_PRODUCT_GP_EM


#ifdef GAIM_FUNCTION_FASTDUAL
GAIM_RETURN_TYPE CLASSNAME::fastDual() const {
	GAIM_RETURN_VAR(result);
	((GAIM_CLASSNAME&)result).fastDual(*this);
	return result;
}
#endif // GAIM_FUNCTION_FASTDUAL


#ifdef GAIM_FUNCTION_VERSORINVERSE
GAIM_RETURN_TYPE CLASSNAME::versorInverse() const {
	GAIM_RETURN_VAR(result);
	result.versorInverse(*this);
	return result;
}
#endif
#ifdef GAIM_FUNCTION_LOUNESTOINVERSE
GAIM_RETURN_TYPE CLASSNAME::lounestoInverse() const {
	GAIM_RETURN_VAR(result);
	result.lounestoInverse(*this);
	return result;
}
#endif
#ifdef GAIM_FUNCTION_GENERALINVERSE
GAIM_RETURN_TYPE CLASSNAME::generalInverse() const {
	GAIM_RETURN_VAR(result);
	result.generalInverse(*this);
	return result;
}
#endif

#ifdef GAIM_PRODUCT_IGP
GAIM_RETURN_TYPE CLASSNAME::inverse() const {
	GAIM_RETURN_VAR(result);
	result.inverse(*this);
	return result;
}

GAIM_RETURN_TYPE CLASSNAME::operator/=(const CLASSNAME &a) {
	CLASSNAME tmp, tmp2;
	tmp2.inverse(a);
	tmp.gp(*this, tmp2);
	this->copy(tmp);
	return *this;
}
GAIM_RETURN_TYPE CLASSNAME::operator/=(GAIM_FLOAT a) {
	CLASSNAME tmp;
	tmp.op(1.0f / a, *this);
	this->copy(tmp);
	return *this;
}
#endif // GAIM_PRODUCT_IGP

#ifdef GAIM_PRODUCT_SCP
GAIM_RETURN_TYPE CLASSNAME::operator%=(const CLASSNAME &a) {
	CLASSNAME tmp;
	tmp.scp(*this, a);
	this->copy(tmp);
	return *this;
}
GAIM_RETURN_TYPE CLASSNAME::operator%=(GAIM_FLOAT a) {
	GAIM_FLOAT f = scalar() * a;
	setScalar(&f);
	return *this;
}
GAIM_RETURN_TYPE scp(const CLASSNAME &a, const CLASSNAME &b) {
	GAIM_RETURN_VAR(result);
	result.scp(a, b);
	return result;
}
GAIM_RETURN_TYPE scp(GAIM_FLOAT a, const CLASSNAME &b) {
	GAIM_RETURN_VAR(result);
	result.set(GRADE0, mulScalar(a, b.scalar()));
	return result;
}
#endif // GAIM_PRODUCT_SCP

#ifdef GAIM_PRODUCT_LCONT
GAIM_RETURN_TYPE lcont(const CLASSNAME &a, const CLASSNAME &b) {
	GAIM_RETURN_VAR(result);
	result.lcont(a, b);
	return result;
}
GAIM_RETURN_TYPE CLASSNAME::operator<<=(const CLASSNAME &a) {
	CLASSNAME tmp;
	tmp.lcont(*this, a);
	this->copy(tmp);
	return *this;
}
#endif // GAIM_PRODUCT_LCONT

#ifdef GAIM_PRODUCT_LCONT_EM
GAIM_RETURN_TYPE lcem(const CLASSNAME &a, const CLASSNAME &b) {
	GAIM_RETURN_VAR(result);
	result. GAIM_PRODUCT_LCONT_EM (a, b);
	return result;
}
#endif // GAIM_PRODUCT_LCONT_EM

#ifdef GAIM_PRODUCT_RCONT
GAIM_RETURN_TYPE rcont(const CLASSNAME &a, const CLASSNAME &b) {
	GAIM_RETURN_VAR(result);
	result.rcont(a, b);
	return result;
}
GAIM_RETURN_TYPE CLASSNAME::operator>>=(const CLASSNAME &a) {
	CLASSNAME tmp;
	tmp.rcont(*this, a);
	this->copy(tmp);
	return *this;
}
#endif // GAIM_PRODUCT_RCONT

#ifdef GAIM_PRODUCT_HIP
GAIM_RETURN_TYPE hip(const CLASSNAME &a, const CLASSNAME &b) {
	GAIM_RETURN_VAR(result);
	result.hip(a, b);
	return result;
}
GAIM_RETURN_TYPE hip(GAIM_FLOAT a, const CLASSNAME &b) {
	GAIM_RETURN_VAR(result);
	CLASSNAME _a(a);
	result.hip(_a, b);
	return result;
}
GAIM_RETURN_TYPE hip(const CLASSNAME &a, GAIM_FLOAT b) {
	GAIM_RETURN_VAR(result);
	CLASSNAME _b(b);
	result.hip(a, _b);
	return result;
}
#endif // GAIM_PRODUCT_HIP

#ifdef GAIM_PRODUCT_MHIP
GAIM_RETURN_TYPE mhip(const CLASSNAME &a, const CLASSNAME &b) { // GAIM_RETURN_TYPE used to read CLASSNAME & (modified 10-10-2002)
	GAIM_RETURN_VAR(result);
	result.mhip(a, b);
	return result;
}
GAIM_RETURN_TYPE mhip(GAIM_FLOAT a, const CLASSNAME &b) {
	GAIM_RETURN_VAR(result);
	CLASSNAME _a(a);
	result.mhip(_a, b);
	return result;
}
GAIM_RETURN_TYPE mhip(const CLASSNAME &a, GAIM_FLOAT b) {
	GAIM_RETURN_VAR(result);
	CLASSNAME _b(b);
	result.mhip(a, _b);
	return result;
}
#endif // GAIM_PRODUCT_MHIP


#ifdef GAIM_PRODUCT_OP
GAIM_RETURN_TYPE op(GAIM_FLOAT a, const CLASSNAME &b) {
	GAIM_RETURN_VAR(result);
	result.op(a, b);
	return result;
}
GAIM_RETURN_TYPE op(const CLASSNAME &a, const CLASSNAME &b) {
	GAIM_RETURN_VAR(result);
	result.op(a, b);
	return result;
}
GAIM_RETURN_TYPE CLASSNAME::operator^=(const CLASSNAME &a) {
	CLASSNAME tmp;
	tmp.op(*this, a);
	this->copy(tmp);
	return *this;
}
GAIM_RETURN_TYPE CLASSNAME::operator^=(GAIM_FLOAT a) {
	CLASSNAME tmp;
	tmp.op(a, *this);
	this->copy(tmp);
	return *this;
}
#endif // GAIM_PRODUCT_OP

#ifdef GAIM_FUNCTION_MEETJOIN
GAIM_RETURN_TYPE meet(const CLASSNAME &a, const CLASSNAME &b) {
	GAIM_RETURN_VAR(result);
	result.meet(a, b);
	return result;
}

GAIM_RETURN_TYPE join(const CLASSNAME &a, const CLASSNAME &b) {
	GAIM_RETURN_VAR(result);
	result.join(a, b);
	return result;
}

#endif // GAIM_FUNCTION_MEETJOIN


#ifdef GAIM_FUNCTION_ADD
GAIM_RETURN_TYPE add(const CLASSNAME &a, const CLASSNAME &b) {
	GAIM_RETURN_VAR(result);
	result.add(a, b);
	return result;
}
GAIM_RETURN_TYPE add(GAIM_FLOAT a, const CLASSNAME &b) {
	GAIM_RETURN_VAR(result);
	result.add(a, b);
	return result;
}
GAIM_RETURN_TYPE CLASSNAME::operator+=(const CLASSNAME &a) {
	CLASSNAME tmp;
	tmp.add(*this, a);
	this->copy(tmp);
	return *this;
}
GAIM_RETURN_TYPE CLASSNAME::operator+=(GAIM_FLOAT a) {
	CLASSNAME tmp;
	tmp.add(a, *this);
	this->copy(tmp);
	return *this;
}
#endif // GAIM_FUNCTION_ADD

#ifdef GAIM_FUNCTION_SUBSTRACT
GAIM_RETURN_TYPE sub(const CLASSNAME &a, const CLASSNAME &b) {
	GAIM_RETURN_VAR(result);
	result.sub(a, b);
	return result;
}
GAIM_RETURN_TYPE sub(GAIM_FLOAT a, const CLASSNAME &b) {
	GAIM_RETURN_VAR(result);
	result.sub(a, b);
	return result;
}
GAIM_RETURN_TYPE CLASSNAME::operator-=(const CLASSNAME &a) {
	CLASSNAME tmp;
	tmp.sub(*this, a);
	this->copy(tmp);
	return *this;
}
GAIM_RETURN_TYPE CLASSNAME::operator-=(GAIM_FLOAT a) {
	CLASSNAME tmp;
	tmp.add(a, *this);
	this->copy(tmp);
	return *this;
}
#endif // GAIM_FUNCTION_SUBSTRACT

#ifdef GAIM_FUNCTION_NEGATE
GAIM_RETURN_TYPE negate(const CLASSNAME &a) {
	GAIM_RETURN_VAR(result);
	((GAIM_CLASSNAME&)result).negate(a);
	return result;
}
#endif //GAIM_FUNCTION_NEGATE



#ifdef GAIM_FUNCTION_NORMALIZE
GAIM_RETURN_TYPE CLASSNAME::normal(int norm /* = 1 */) const {
	GAIM_RETURN_VAR(result);
	result.normalize(*this, norm);
	return result;
}
#endif // GAIM_FUNCTION_NORMALIZE


#ifdef GAIM_PRODUCT_OM
CLASSNAME_OM::CLASSNAME_OM(const CLASSNAME *vectorImages[3]) {
	initVectorImages(vectorImages);
}

CLASSNAME_OM::CLASSNAME_OM(const CLASSNAME &spinor) {
	initSpinor(spinor);
}


int CLASSNAME_OM::initSpinor(const CLASSNAME &spinor) {
	CLASSNAME si(spinor.inverse()), v, vi[GA_MAX_DIM];
	GAIM_FLOAT coordinates[GA_MAX_DIM];
	int i;

	memset(coordinates, 0, sizeof(GAIM_FLOAT) * GA_MAX_DIM);

	for (i = 0; i < CLASSNAME::dim; i++) {
		coordinates[i] = 1.0;
		if (i > 0) coordinates[i-1] = 0.0;
		v.setVector(coordinates);
		vi[i] = ((spinor * v) * si)(GRADE1);

	}
	return initVectorImages(vi);
}


GAIM_RETURN_TYPE om(const CLASSNAME_OM &om, const CLASSNAME &a) {
	GAIM_RETURN_VAR(result);

	result.om(a, om);

	return result;
}


#ifdef GAIM_NAMESPACE
}
#endif // GAIM_NAMESPACE


#endif // GAIM_PRODUCT_OM


