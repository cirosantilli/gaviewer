
/*
Gaigen 1.0, Copyright (c) 2001-2010, University of Amsterdam

Copying, use and development for education and research purposes 
permitted as long as this license is not removed from the files.

All rights for commercial use reserved; for more information
contact Daniel Fontijne (fontijne@science.uva.nl)

This software is unsupported.
*/
/*
Source file p3ga.cpp, generated by Gaigen 1.0 on Mon Mar 22 19:10:50 2010
*/




#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <math.h>
#include "p3ga.h"
#ifdef WIN32
#pragma warning( disable : 4996)
#endif

int p3gai_expansionTable_gp[] = {
-1,
0, 17, 34, 51, 68, 85, 102, 119, 136, 153, 170, 187, 204, 221, 238, 255, -1,
1, 16, 39, 310, 72, 94, 355, 114, 132, 157, 428, 191, 458, 217, 229, 251, -1,
2, 279, 32, 53, 73, 83, 110, 369, 397, 148, 171, 186, 207, 472, 230, 252, -1,
3, 22, 293, 48, 74, 338, 97, 126, 140, 411, 164, 441, 200, 223, 231, 253, -1,
4, 280, 297, 314, 64, 91, 108, 125, 385, 402, 419, 181, 198, 215, 495, 510, -1,
261, 286, 35, 306, 331, 80, 103, 374, 399, 154, 425, 180, 205, 476, 225, 248, -1,
262, 275, 302, 49, 332, 343, 96, 117, 394, 415, 168, 445, 196, 219, 226, 249, -1,
263, 18, 289, 318, 333, 86, 357, 112, 137, 408, 431, 188, 459, 212, 227, 250, -1,
264, 20, 45, 316, 321, 351, 106, 377, 128, 151, 422, 446, 195, 466, 235, 245, -1,
265, 285, 36, 59, 322, 346, 367, 120, 391, 144, 165, 435, 462, 209, 236, 246, -1,
266, 28, 299, 52, 323, 89, 360, 383, 134, 405, 160, 178, 449, 478, 237, 247, -1,
267, 31, 298, 57, 325, 84, 109, 380, 142, 403, 162, 176, 199, 470, 488, 497, -1,
268, 26, 47, 312, 326, 349, 100, 123, 131, 158, 417, 439, 192, 213, 489, 498, -1,
269, 281, 40, 63, 327, 92, 363, 116, 386, 145, 174, 182, 453, 208, 490, 499, -1,
270, 277, 294, 311, 335, 81, 98, 115, 395, 412, 429, 184, 201, 218, 224, 244, -1,
15, 283, 300, 317, 78, 344, 361, 378, 389, 406, 423, 433, 450, 467, 228, 240, -1
};

const char *p3gai_typeNames[4] = {
	"undefined",
	"blade",
	"versor",
	"multivector"
};
// layer 0 functions are always pure C, unless custom float class if used
extern "C" {

char *p3gai_basisElementNames[16] = {
(char*)"1",
(char*)"e1",
(char*)"e2",
(char*)"e3",
(char*)"e0",
(char*)"e2^e3",
(char*)"e3^e1",
(char*)"e1^e2",
(char*)"e1^e0",
(char*)"e2^e0",
(char*)"e3^e0",
(char*)"e2^e3^e0",
(char*)"e3^e1^e0",
(char*)"e1^e2^e0",
(char*)"e1^e2^e3",
(char*)"e1^e2^e3^e0"
};

bool p3gai_basisElementNamesAllocated[16] = {
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false
};

int p3gai_gradeSize[5] = {1, 4, 6, 4, 1};
int p3gai_mvSize[32] = {0, 1, 4, 5, 6, 7, 10, 11, 4, 5, 8, 9, 10, 11, 14, 15, 1, 2, 5, 6, 7, 8, 11, 12, 5, 6, 9, 10, 11, 12, 15, 16};

const int p3gai_bevt0[1] = {-1};
const int p3gai_bevt1[4] = {0, 1, 2, 3};
const int p3gai_bevt2[6] = {1, 2, 0, 0, 1, 2};
const int p3gai_bevt3[4] = {1, 2, 0, 0};
const int p3gai_bevt4[1] = {0};
const int *p3gai_bevt[5] = { // bevt = basis element vector table
	p3gai_bevt0,
	p3gai_bevt1,
	p3gai_bevt2,
	p3gai_bevt3,
	p3gai_bevt4
};
const int p3gai_newBevt[16] = { // bevt = basis element vector table
	0, 1, 2, 4, 8, 6, 5, 3, 9, 10, 12, 14, 13, 11, 7, 15
};

const int p3gai_omct[48] = { // omct = Outer Morphism Construction Table
	-1, -1, 0,
	1, -1, 1,
	2, -1, 1,
	3, -1, 1,
	4, -1, 1,
	2, 3, 1,
	1, 3, -1,
	1, 2, 1,
	1, 4, 1,
	2, 4, 1,
	3, 4, 1,
	5, 4, 1,
	6, 4, 1,
	7, 4, 1,
	5, 1, 1,
	11, 1, -1
};
// end of the layer 0 functions
} /* end of 'extern "C"' */



p3gai p3gai::e1(GRADE1, 1.0, 0.0, 0.0, 0.0);
p3gai p3gai::e2(GRADE1, 0.0, 1.0, 0.0, 0.0);
p3gai p3gai::e3(GRADE1, 0.0, 0.0, 1.0, 0.0);
p3gai p3gai::e0(GRADE1, 0.0, 0.0, 0.0, 1.0);
p3gai *p3gai::bv[4] = {&p3gai::e1, &p3gai::e2, &p3gai::e3, &p3gai::e0};
p3gai p3gai::I(GRADE4, 1.0);
p3gai p3gai::Ii(GRADE4, 1.0);

const int p3gai::dim = 4;
const int p3gai::nbCoor = 16;

p3gai::p3gai() {
	usage = 0;
	c = NULL;
}

p3gai::p3gai(const p3gai &a) {
	usage = 0;
	copy(a);
}

p3gai::p3gai(int gradeUsage, const double *coordinates) {
	usage = 0;
	set(gradeUsage, coordinates);
}

p3gai::~p3gai() {
	setUsage(0);
}

p3gai::p3gai(int grade, double c0) {
	usage = 0;
	set(grade, c0);
}

p3gai::p3gai(int grade, double c0, double c1, double c2, double c3) {
	usage = 0;
	set(grade, c0, c1, c2, c3);
}

p3gai::p3gai(int grade, double c0, double c1, double c2, double c3, double c4, double c5) {
	usage = 0;
	set(grade, c0, c1, c2, c3, c4, c5);
}

void p3gai::null() {
	setUsage(0);
}

void p3gai::set(int gradeUsage, const double *coordinates) {
	setUsage((p3gai_mvSize[gradeUsage] << 5) | gradeUsage);
	p3gai_copy(c, coordinates, p3gai_mvSize[gradeUsage]);
}

void p3gai::setScalar(const double coordinates[1]) {
	setUsage(33);
	p3gai_copy(c, coordinates, 1);
}

void p3gai::setVector(const double coordinates[4]) {
	setUsage(130);
	p3gai_copy(c, coordinates, 4);
}

void p3gai::set2Vector(const double coordinates[6]) {
	setUsage(196);
	p3gai_copy(c, coordinates, 6);
}

void p3gai::set3Vector(const double coordinates[4]) {
	setUsage(136);
	p3gai_copy(c, coordinates, 4);
}

void p3gai::set4Vector(const double coordinates[1]) {
	setUsage(48);
	p3gai_copy(c, coordinates, 1);
}

int p3gai::set(int grade, double c0) {
	setUsage(grade | (p3gai_mvSize[grade] << 5));
	c[0] = c0;
	return 0;
}

int p3gai::set(int grade, double c0, double c1, double c2, double c3) {
	setUsage(grade | (p3gai_mvSize[grade] << 5));
	c[0] = c0;
	c[1] = c1;
	c[2] = c2;
	c[3] = c3;
	return 0;
}

int p3gai::set(int grade, double c0, double c1, double c2, double c3, double c4, double c5) {
	setUsage(grade | (p3gai_mvSize[grade] << 5));
	c[0] = c0;
	c[1] = c1;
	c[2] = c2;
	c[3] = c3;
	c[4] = c4;
	c[5] = c5;
	return 0;
}

const char *p3gai::fpPrecision = "%2.2f";
const char *p3gai::stringStartDelimiter = "";
const char *p3gai::stringEndDelimiter = "";

int p3gai::setFPPrecision(const char *prec) {
	if (prec == NULL) return -1;
	fpPrecision = prec;
	return 0;
}

int p3gai::setStringDelimiters(char start, char end) {
	if ((start < 0) || (end < 0)) return -1;
	static char startStr[2], endStr[2];

	startStr[0] = start; startStr[1] = 0;
	stringStartDelimiter = startStr;

	endStr[0] = end; endStr[1] = 0;
	stringEndDelimiter = endStr;
	return 0;
}

const char *p3gai::string(const char *prec /*= NULL*/) const {
	// todo: this whole function is not very (mt-)safe
	static char tmpResult[1024]; 
	tmpResult[0] = 0;

	const int maxResult = 16; 
	static char *result[maxResult];
	static int currentResult = 0;

	char *rBuf = tmpResult;
	int i, j, k = 0, ia = 0, gu = gradeUsage(), s = p3gai_mvSize[gu], p = 0, cnt = 0;
	char buf[32];	

	if (prec == NULL) prec = fpPrecision;
	sprintf(buf, "%cs%s%cs%cs", '%', prec, '%', '%');
	rBuf += sprintf(rBuf, "%s", stringStartDelimiter);
	for (i = 0; i <= 4; i++)
		if (gu & (1 << i)) {
			for (j = 0; j < p3gai_gradeSize[i]; j++) {
				if (fabs(c[k]) > 1e-14) {
					cnt++;
					rBuf += sprintf(rBuf, buf, (p) ? " + " : "", float(c[k]), (i) ? "*" : "", (i) ? p3gai_basisElementNames[ia] : "");
					p = 1;
				}
				k++; ia++;
			}
		}
		else ia += p3gai_gradeSize[i];

	if (cnt == 0) rBuf += sprintf(rBuf, "0");
	rBuf += sprintf(rBuf, "%s", stringEndDelimiter);

	k = (int)(strlen(tmpResult) + 1);
	rBuf = result[currentResult] = (char*)realloc(result[currentResult], k);
	currentResult = (currentResult + 1) % maxResult;

	if (rBuf == NULL) {
		printf("Memory allocation failure for %d bytes\n", k);
		return tmpResult; // at least return something...
	}
	else {
		memcpy(rBuf, tmpResult, k);
		return rBuf;
	}
}

void p3gai::print(const char *text /*= NULL*/, const char *prec /*= NULL*/) const {
	fprint(stdout, text, prec);
}

void p3gai::fprint(FILE *F, const char *text /*= NULL*/, const char *prec /*= NULL*/) const {
	if (text) fprintf(F, text);
	fprintf(F, "%s\n", string(prec));
}

int p3gai::renameBasisVector(const char *oldName, const char *newName) {
    unsigned int totalNb = 0;
    for (unsigned int j = 0; j < 16;j++) {
        // count number of occurances of oldName:
        char *ptr = p3gai_basisElementNames[j];
        int nb = 0;
        do {
            ptr = strstr(ptr, oldName);
            
            if (ptr != NULL) {
                nb ++;
                ptr += strlen(oldName);
            }
        } while (ptr);
        totalNb += nb;
        
        // if oldName occured:
        if (nb) {
            // allocate mem for new name
            char *buf = (char*)malloc(
                strlen(p3gai_basisElementNames[j]) + 1 + 
                nb * (strlen(newName) - strlen(oldName)));
            if (buf == NULL) return -1;

            // form new name
            ptr = p3gai_basisElementNames[j];
            char *buf2 = buf, *ptr2 = ptr;
            do {
                ptr = strstr(ptr, oldName);
                if (ptr != NULL) {
                    memcpy(buf2, ptr2, ptr - ptr2);
                    buf2 += ptr - ptr2;
                    
                    strcpy(buf2, newName);
                    buf2 += strlen(newName);
                    
                    ptr += strlen(oldName);        
                    ptr2 = ptr;
                }
                else {
                    strcpy(buf2, ptr2);
                }
            } while (ptr);
            
            // set result:
            if (p3gai_basisElementNamesAllocated[j])
                free(p3gai_basisElementNames[j]);
            p3gai_basisElementNames[j] = buf;
            p3gai_basisElementNamesAllocated[j] = true;
        }
    }
    return (totalNb == 0) ? -1 : 0;
}



int p3gai::nbBlocksAvailable[16 + 1];
int p3gai::maxBlocksAvailable[16 + 1];
double **p3gai::blocks[16 + 1];

void p3gai::doubleMaxBlocks(int n) {
	maxBlocksAvailable[n] = (maxBlocksAvailable[n]) ? maxBlocksAvailable[n] * 2 : 2;
	blocks[n] = (double**)realloc(blocks[n], sizeof(double*) * maxBlocksAvailable[n]);  // todo: check mem alloc
}

void p3gai::addBlocks(int n) {
	const int nb = 128; // nb = just a constant
	int i;
	double *newBlocks = (double*)calloc(sizeof(double) * n, nb);	// todo: check mem alloc
	while (maxBlocksAvailable[n] < nbBlocksAvailable[n] + nb) doubleMaxBlocks(n);
	for (i = 0; i < nb; i++)
		blocks[n][nbBlocksAvailable[n]++] = newBlocks + i * n;
}

void p3gai::setUsage(int u) {
	int n1, n2;

	n1 = memUsage();
	n2 = u >> (4 + 1);
	usage = u;
	if (n1 == n2) return;
	if (n1) {	// free old mem
		if (maxBlocksAvailable[n1] == nbBlocksAvailable[n1]) doubleMaxBlocks(n1);
		blocks[n1][nbBlocksAvailable[n1]] = c;
		nbBlocksAvailable[n1]++;
	}
	if (n2) {	// alloc new mem
		if (!nbBlocksAvailable[n2]) addBlocks(n2);
		nbBlocksAvailable[n2]--;
		c = blocks[n2][nbBlocksAvailable[n2]];
	}
}

void p3gai::copy(const p3gai &a) {
	setUsage(a.usage);
	p3gai_copy(c, a.c, p3gai_mvSize[a.gradeUsage()]);
}

void p3gai::compress(double epsilon /* = 1e-14 */ ) {
	double cc[16];
	int i, j, ia = 0, ib = 0, gu = gradeUsage(), gu2 = 0, f, s;
	for (i = 0; i < 6; i++) {
		if (!(gu & (1 << i))) continue;

		s = p3gai_gradeSize[i];
		j = ia + s;
		f = 0;
		for (; ia < j; ia++)
			if ((c[ia] > epsilon) || (c[ia] < -epsilon)) {f = 1; break;}
		ia = j;
		if (f) {
			p3gai_copy(cc + ib, c + ia - s, s);
			ib += s;
			gu2 |= (1 << i);
		}
	}
	if (gu2 != gu) set(gu2, cc);
}

void p3gai::reverse(const p3gai &a) {
	double *pc[5];
	copy(a);
	if (!(a.gradeUsage() & 12)) return;
	expand( (const double**) pc);
	p3gai_reverse(pc);
}

void p3gai::cliffordConjugate(const p3gai &a) {
	double *pc[5];
	copy(a);
	if (!(a.gradeUsage() & 6)) return;
	expand( (const double**) pc);
	p3gai_cliffordConjugate(pc);
}

void p3gai::gradeInvolution(const p3gai &a) {
	double *pc[5];
	copy(a);
	if (!(a.gradeUsage() & 10)) return;
	expand( (const double**) pc);
	p3gai_involution(pc);
}

void p3gai::negate(const p3gai &a) {
	setUsage(a.usage);
	p3gai_negate(c, a.c, p3gai_mvSize[a.gradeUsage()]);
}

void p3gai::add(const p3gai &a, const p3gai &b) {
	double const *pa[5], *pb[5];
	double *pc[5];
	int gu = a.gradeUsage() | b.gradeUsage();
	setUsage(gu | (p3gai_mvSize[gu] << 5));
	if (a.gradeUsage() == b.gradeUsage()) p3gai_addSameGradeUsage(c, a.c, b.c, memUsage());
	else {
		a.expand(b, pa, pb);
		expand( (const double**) pc);
		p3gai_add(pa, pb, pc);
	}
}

void p3gai::add(double scalar, const p3gai &b) {
	double const *pa[5], *pb[5];
	double *pc[5];
	int gu = GRADE0 | b.gradeUsage();
	setUsage(gu | (p3gai_mvSize[gu] << 5));
	if (GRADE0 == b.gradeUsage()) p3gai_addSameGradeUsage(c, &scalar, b.c, memUsage());
	else {
		memset(pa + 1, 0, sizeof(double*) * 4);
		pa[0] = &scalar;
		b.expand(pb);
		expand( (const double**) pc);
		p3gai_add(pa, pb, pc);
	}
}

void p3gai::sub(const p3gai &a, const p3gai &b) {
	double const *pa[5], *pb[5];
	double *pc[5];
	int gu = a.gradeUsage() | b.gradeUsage();
	setUsage(gu | (p3gai_mvSize[gu] << 5));
	if (a.gradeUsage() == b.gradeUsage()) p3gai_subSameGradeUsage(c, a.c, b.c, memUsage());
	else {
		a.expand(b, pa, pb);
		expand( (const double**) pc);
		p3gai_sub(pa, pb, pc);
	}
}

void p3gai::sub(double scalar, const p3gai &b) {
	double const *pa[5], *pb[5];
	double *pc[5];
	int gu = GRADE0 | b.gradeUsage();
	setUsage(gu | (p3gai_mvSize[gu] << 5));
	if (GRADE0 == b.gradeUsage()) p3gai_subSameGradeUsage(c, &scalar, b.c, memUsage());
	else {
		memset(pa + 1, 0, sizeof(double*) * 4);
		pa[0] = &scalar;
		b.expand(pb);
		expand( (const double**) pc);
		p3gai_sub(pa, pb, pc);
	}
}

// take grade introduced 20020710
void p3gai::takeGrade(const p3gai &a, int gu) {
	int i, gua, s;
	double *bc; 
	const double *ac; 

	// determine what the grage usage 'gu' of the result should be:
	if (gu = ((gua = a.gradeUsage()) & gu)) { // only execute if any grade will be present in the result
		// set the grade usage of the result + allocate memory
		setUsage(gu | (p3gai_mvSize[gu] << 5)); 

		bc = c; ac = a.c; // pointers to the coordinates of source (ac) and result (bc)
		for (i = 1; i <= gu; i = i << 1) { // for each grade that is possibly in the result
			if (gua & i) { // determine if grade is present in source
				s = p3gai_mvSize[i]; // get the size of grade
				if (gu & i) { // determine if grade is present in result
					p3gai_copy(bc, ac, s); // copy coordinates
					bc += s; // increment pointer to result
				}
				ac += s; // increment pointer to source
			}
		}
	}
	else setUsage(0);
}

// added an epsilon value on 2002 07 28
int p3gai::highestGrade(const p3gai &a, double epsilon /* = 1e-14 */) {
	int g = 4, gu = a.gradeUsage(), ia = p3gai_mvSize[gu], size, i;
	const double *cptr;
	do {
		if (gu & (1 << g)) {
			size = p3gai_gradeSize[g];
			ia -= size;
			cptr = a.c + ia;
			for (i = 0; i < size; i++) 
				if (fabs(cptr[i]) > epsilon) {
					set(1 << g, a.c + ia);
					return g;
				}
		}
	} while ((--g)>= 0); // bug fix on 2003 11 16, used to be while ((--g) _>_ 0)
//return -1; // modification on 20020828

	setUsage(0);
	return 0;
}

int p3gai::grade() const {
	int g = 4, gu = gradeUsage(), idx = p3gai_mvSize[gu], size, i;
	const double *cptr;
	do {
		if (gu & (1 << g)) {
			size = p3gai_gradeSize[g];
			idx -= size;
			cptr = c + idx;
			for (i = 0; i < size; i++) if (cptr[i] != (double)0.0) return (gu ^ (1 << g)) ? -1 : g;
		}
	} while ((--g)>0);
	return 0;
}

int p3gai::maxGrade() const { 
	int g = 4, gu = gradeUsage(), idx = p3gai_mvSize[gu], size, i;
	const double *cptr;
	do {
		if (gu & (1 << g)) {
			size = p3gai_gradeSize[g];
			idx -= size;
			cptr = c + idx;
			for (i = 0; i < size; i++) if (cptr[i] != (double)0.0) return g;
		}
	} while ((--g)>0);
	return -1;
}

int p3gai::largestGrade() const {
	int g = 0, gu = gradeUsage(), size;
	double largest = -1.0, tmp;
	int lg = 0;
	const double *cptr = c;
	do {
		if (gu & (1 << g)) {
			size = p3gai_gradeSize[g];
			if ( (tmp = p3gai_norm_a(cptr, size)) > largest) {
				largest = tmp;
				lg = g;
			}
			gu ^= (1 << g);
			
			cptr += size;
		}
	} while (gu && ((++g)<=4));
	return lg;
}




int p3gai::versorInverse(const p3gai &a) {
	p3gai reverse, scalar;
	reverse.reverse(a);
	scalar.scp(a, reverse);
	if ((scalar.c == NULL) || (scalar.c[0] == 0.0f)) {null(); return -1;}
	scalar.c[0] = 1.0f / scalar.c[0];
	op(scalar, reverse);
	return 0;
}

void p3gai::expand(double matrix[], const int table[]) const {
	double val;
	int i, j = 0, t, g = -1, gi = 0, gu = gradeUsage(), ci = 0;
	for (i = -1; i < 16; i++) {
		if (i == -1) val = 0.0f;
		else {
			if (gi == 0) gi = p3gai_gradeSize[++g];
			if (gu & (1 << g)) val = c[ci++];
			else val = 0.0f;
			gi--;
		}
		while ((t = table[j++]) >= 0) {
			if (t & 512) matrix[t & 255] += (t & 256) ? (double)-val : (double)val;
			else matrix[t & 255] = (t & 256) ? (double)-val : (double)val;
		}
	}
}

int p3gai::generalInverse(const p3gai &a) {
	static double matrix[256];
	double *m[16] = {
		matrix + 0,
		matrix + 16,
		matrix + 32,
		matrix + 48,
		matrix + 64,
		matrix + 80,
		matrix + 96,
		matrix + 112,
		matrix + 128,
		matrix + 144,
		matrix + 160,
		matrix + 176,
		matrix + 192,
		matrix + 208,
		matrix + 224,
		matrix + 240

	};
	double maxp, *tmp, mult;
	int pi, i, j, k;
	double inverse[16];
	inverse[0] = 1.0f;

	// modification for custom float (december 9 2002)
	p3gai_null(inverse + 1, 16-1);

	int it = 0;

	a.expand(matrix, p3gai_expansionTable_gp);

	for (i = 0; i < 16; i++) {	// sweep all columns
		pi = i;
		maxp = (double)fabs(m[i][i]);

		for (j = i + 1; j < 16; j++) // find the max pivot
			if ((double)fabs(m[j][i]) > maxp)
				maxp = (double)fabs(m[pi = j][i]);
		if (inverse[pi] != 0.0f) it = 1;
		if (pi != i) { // swap rows
			if (inverse[i] != 0.0f) it = 1;
			tmp = m[pi]; m[pi] = m[i]; m[i] = tmp;
			if (it) maxp = inverse[pi]; inverse[pi] = inverse[i]; inverse[i] = maxp;
		}

		maxp = m[i][i];
		if (maxp == 0.0f) {	// singular matrix
			setUsage(0);
			return -1;
		}

		for (k = 0; k < 16; k++) { // sweep all other rows
			if (k == i) continue;
			mult = -m[k][i] / maxp;
			for (j = i + 1; j < 16; j++) m[k][j] += m[i][j] * mult;
			if (it) inverse[k] += inverse[i] * mult;
		}

		for (j = i+1; j < 16; j++) m[i][j] /= maxp; // divide the pivot row
		if (it) inverse[i] /= maxp;
	}
	set((1 << 5) - 1, inverse);
	return 0;
}

double p3gai::norm_a() const {
	return p3gai_norm_a(c, p3gai_mvSize[gradeUsage()]);
}

double p3gai::norm_b() const {
	p3gai r, s;
	r.reverse(*this);
	s.scp(*this, r);
	return s.scalar();
}

double p3gai::largestCoordinate() const {
	int nc = p3gai_mvSize[gradeUsage()], i;
	double maxC = 0.0, C;
	
	for (i = 0; i < nc; i++) {
		C = fabs(c[i]);
		if (C > maxC) maxC = C;
	}
	
	return maxC;
}

void p3gai::normalize(const p3gai &a, int norm) {
	double tmpC;
	switch(norm) {
	case 1:
		tmpC = 1.0f / (double)sqrt(a.norm_a());
		break;
	case 2:
		tmpC = 1.0f / (double)sqrt(fabs(a.norm_b()));
		break;
	}
	p3gai scalar(GRADE0, tmpC);
	op(a, scalar);
}

int p3gai::project(const p3gai &blade, const p3gai &a) {
	p3gai tmp, bladeInverse;
	bladeInverse.versorInverse(blade);
	tmp.lcont(a, blade);
	lcont(tmp, bladeInverse);
	return 0;
}

int p3gai::projectOntoVersor(const p3gai &versor, const p3gai &a) {
	p3gai tmp, versorInverse;
	versorInverse.versorInverse(versor);
	tmp.lcont(a, versor);
	gp(tmp, versorInverse);
	return 0;
}

int p3gai::reject(const p3gai &blade, const p3gai &a) {
	p3gai tmp, bladeInverse;
	// todo: check if this code is correct
	bladeInverse.versorInverse(blade);
	tmp.op(blade, a);
	lcont(bladeInverse, tmp);
	return 0;
}

// todo: ensure everything is euclidean...
int p3gai::factor(p3gai factors[], int versor /* = 0 */) const {
	p3gai ca[2], tmp, fi, tmpbv;
	int ga = (versor) ? maxGrade() : grade(), n = 0, i, idx, cca = 0, gu = gradeUsage(), bev;
	double maxC, tmpC, mul, *c2;
	const double *tmpc;
	static double bvc[4] = {1.0, 0.0, 0.0, 0.0};

	if (ga <= 0) return 0;

	// compute the multiplication factor require to make every factor of the same order of magnitude
	mul = (double)pow((double)sqrt((double)norm_a()), 1.0 / (double)ga);

	// setup current 'a'
	ca[0].copy(*this);

	// get the coordinate array for grade 'ga'
	tmpc = coordinates(1 << ga);

	// find out the maximum coordinate
	maxC = (double)fabs(tmpc[idx = 0]);
	for (i = 1; i < p3gai_gradeSize[ga]; i++) 
		if ( (tmpC = (double)fabs(ca[cca].c[i])) > maxC) {maxC = tmpC;idx = i;}

	// find out which basis vectors we have to project onto the blade
	idx += p3gai_mvSize[0xff >> (8 - ga)];
	bev = p3gai_newBevt[idx];

	// setup a basis vector
	tmpbv.setVector(bvc);
	c2 = tmpbv.c;
	idx = 0;

	i = 1;
	for (; ga > 1; ga--) {
		// find the next coordinate
		do { // note: the first coordinate is always skipped; this is note a bug 
			c2[idx++] = 0.0; // direct manipulation of 'bv'; hack
			c2[idx] = 1.0; // direct manipulation of 'bv'; hack
			i <<= 1;
		} while (!(bev & i));

		tmp.project(ca[cca], tmpbv);
		factors[n].op(mul, tmp); // make all factors approximatelly the same size

		// remove the factor from the blade
		fi.versorInverse(factors[n++]); 
		if (versor) ca[cca ^ 1].gp(fi, ca[cca]);
		else ca[cca ^ 1].lcont(fi, ca[cca]);
		cca ^= 1;
	}

	factors[n++].takeGrade(ca[cca], GRADE1);	// the last factor is equal to the remaining vector

	return n;
}


int p3gai::deltaProduct(const p3gai &a, const p3gai &b) {
	p3gai mv1;
	mv1.gp(a, b);
	return this->highestGrade(mv1);
}

int p3gai::join(const p3gai &a, const p3gai &b, int algorithm /*= 1*/) {
	p3gai d, factors[4];
	int gj, ga = a.grade(), gb = b.grade(), gd;
	p3gai ca, cb;

	// if we are not handed homogeneous multivectors, take the grade parts with the largest norm
	if (ga < 0) {
		ga = a.largestGrade();
		ca.takeGrade(a, 1 << ga);
	}
	else ca.copy(a);

	if (gb < 0) {
		gb = b.largestGrade();
		cb.takeGrade(b, 1 << gb);
	}
	else cb.copy(b);

	// determine the grade of the join
	if (ga == 0) { // then the join is equal to b
		op(ca, cb); return gb;
	}
	else if (gb == 0) { // then the join is equal to a
		op(cb, ca); return ga;
	}
	else { // the join must be computed
		gd = d.deltaProduct(ca, cb);
		gj = (ga + gb + gd) >> 1;
		return (algorithm == 1) 
			? joinAlg1(ca, cb, ga, gb, gj)
			: joinAlg2(ca, cb, ga, gb, gj);
	}
}

int p3gai::meet(const p3gai &a, const p3gai &b, int algorithm /*= 1*/) {
	p3gai d, factors[4], j, jinv;
	int ga = a.grade(), gb = b.grade(), gd;

	p3gai ca, cb;

	// if we are not handed homogeneous multivectors, take the grade parts with the largest norm
	if (ga < 0) {
		ga = a.largestGrade();
		ca.takeGrade(a, 1 << ga);
	}
	else ca.copy(a);

	if (gb < 0) {
		gb = b.largestGrade();
		cb.takeGrade(b, 1 << gb);
	}
	else cb.copy(b);

	// compute delta product, join, ->meet
	gd = d.deltaProduct(ca, cb);
	j.join(ca, cb, algorithm);
	if (jinv.versorInverse(j)) {
		null();
		return 0;
	}
	lcont(d, jinv);
	return (ga + gb - gd) >> 1;
}

// todo: ensure everything is euclidean...
int p3gai::joinAlg2(const p3gai &a, const p3gai &b, int ga, int gb, int gj) {
	p3gai mv1, factors[4];
	int cg, lg, nf; // gj = grade join, gd = grade delta product

	// check for pseudoscalar case:
	if (gj == 4) {
		copy(I);
		return gj;
	}
	
	/*
	we pick the highest-dimension blade to start with,
	and factor the other blade
	*/
	p3gai res[5];
	int factorsTried[5];
	double largestNorm = -1.0f, nm;
	if (ga > gb) {
		if ( (nf = b.factor(factors)) != gb) return -1;	// should never happen
		lg = cg = ga;
		res[cg].copy(a);
	}
	else {
		if ( (nf = a.factor(factors)) != ga) return -1;	// should never happen
		lg = cg = gb;
		res[cg].copy(b);
	}

	// modification for bug of type 'join(e1, e1) = 0' (instead of e1) // 2003 10 28
	if (cg == gj) {	// if we have arrived at the grade of the join:
		copy(res[cg]);
		return gj;
	}

	/*
	Wegde as much factors as we need to get the right grade 
	*/
	factorsTried[cg] = 0;
	while (1) {
		// should we lower the current grade, and try the next factor?
		while (factorsTried[cg] >= nf) cg--;
		if (cg < lg) break;

		// wegde a factor to the result
		res[cg + 1].op(res[cg], factors[factorsTried[cg]]);
		factorsTried[cg + 1] = ++(factorsTried[cg]);
		cg++;

		if (cg == gj) {	// if we have arrived at the grade of the join:
			if ( (nm = res[cg].norm_a()) > largestNorm) {
				largestNorm = nm;
				copy(res[cg]);
			}
			cg--;
		}
	}

	return gj;
}

int p3gai::joinAlg1(const p3gai &a, const p3gai &b, int ga, int gb, int gj) {
	p3gai mv1, b1, b2, factors[4];
	int i, rg, gs; // gj = grade join, gd = grade delta product, rg = required grade, gs = grade size

	// check for pseudoscalar case:
	if (gj == 4) {
		copy(I);
		return gj;
	}

	/* we pick the highest-dimension blade (b1) to start with */
	p3gai be, pbe, tmp; // be = basis element, pbe = projected basis element
	double v1[6];
	double largestNorm = -1.0f, nm;
	if (ga > gb) {
		b1.copy(a);
		rg = gj - ga;
		b2.copy(b);
	}
	else {
		b1.copy(b);
		rg = gj - gb;
		b2.copy(a);
	}

	// project all possible basis elements of grade 'rg' onto blade b2; wegde them with b1
	gs = p3gai_gradeSize[rg];

	// modification for bug of type 'join(e1, e1) = 0' (instead of e1) // 2003 10 28
	if (gs == 0) { // nothing to do, since 'b1' already has the require grade
		copy(b1);
		return gj;
	}
	
	// modification for custom float (december 9 2002)
	p3gai_null(v1, gs);

	be.set(1 << rg, v1);
	for (i = 0; i < gs; i++) {
		be.c[i] = 1.0f;	// hack
		if (i) be.c[i-1] = 0.0f; // hack
		pbe.project(b2, be);
		tmp.op(b1, pbe);
		if ( (nm = tmp.norm_a()) > largestNorm) {
			largestNorm = nm;
			copy(tmp);
		}
	}

	return gj;
}


int p3gai::random(int grade, double scale, int versor) {

	scale *= (double)2.0;

	// compute how many vector we have to multiply/wegd
	int nb = -1;
	while (grade) {
		grade >>= 1;
		nb++;
	}
	if (nb < 0) return -1;
	else if (nb == 0) {
		setScalar(scale * ((double)rand() / (double)2147483647 - (double)0.5));
	}
	else {
		int i, j, ct = 0;
		p3gai rv, tmp[2];
		double v[4], scalar = (double)1.0;

		tmp[0].setScalar(&scalar);
		for (i = 0; i < nb; i++) {
			// create a random vector
			for (j = 0; j < 4; j++)
				v[j] = scale * ((double)rand() / (double)2147483647 - (double)0.5);
			rv.setVector(v);

			// multiply/wegde it to the result
			if (versor) tmp[ct ^ 1].gp(tmp[ct], rv);
			else tmp[ct ^ 1].op(tmp[ct], rv);

			ct ^= 1;
		}

		copy(tmp[ct]);
	}

	return 0;
}

int p3gai::reciprocalFrame(p3gai f[], const p3gai e[], int nbVectors) {
	int cb = 0, i, err, ca, j;
	double scalar = 1.0f;
	p3gai B[2], Bi, tmp, einv, A[2];

	if ((nbVectors <= 0) || (nbVectors > 4)) return 0;

	// build the blade which is the pseudoscalar for the frame 
	B[cb].copy(e[0]);
	for (i = 1; i < nbVectors; i++) {
		B[cb^1].op(B[cb], e[i]);
		cb ^= 1;
	}

	// computer the inverse of the frame
	if (err = Bi.versorInverse(B[cb])) return err;

	// compute the reciprocal vectors
	for (i = 0; i < nbVectors; i++) {
		ca = 0;

		// compute te right scalar factor
		scalar = (i & 1) ? -1.0f : 1.0f;
		A[ca].setScalar(&scalar);

		// compute the blade, with omission of vector e[i]
		for (j = 0; j < nbVectors; j++) {
			if (j == i) continue;
			A[ca^1].op(A[ca], e[j]);
			ca ^= 1;
		}

		// compute reciprocal vector f[i]
		f[i].lcont(A[ca], Bi);
	}

	return 0;
}

int p3gai::mvType(int *grade /*= NULL*/, double epsilon /* = 1e-14 */) const {
// this code fails on 'e1 + (e2 ^ e3)' (says it versor, while it isn't)
	// a = *this
	// compute versor inverse of input
	if (grade) *grade = 0;

	p3gai reverse, scalar, ai;
	reverse.reverse(*this);
	scalar.scp(*this, reverse); 
	if ((scalar.c == NULL) || (scalar.c[0] == 0.0f)) return GA_MULTIVECTOR;
	scalar.c[0] = 1.0f / scalar.c[0];
	ai.op(scalar, reverse);

	// check if ai * a = 1
	p3gai mv1, mv2, mv3;
	mv1.gp(ai, *this); 
	mv1.compress(epsilon);
	if (mv1.gradeUsage() > GRADE0) return GA_MULTIVECTOR;
	if ((mv1.gradeUsage() == 0) || (mv1.c[0] < 1.0f - epsilon) || (mv1.c[0] > 1.0f + epsilon)) 
		return GA_MULTIVECTOR;

	// check if a * ai = 1
	mv1.gp(*this, ai); 
	mv1.compress(epsilon);
	if (mv1.gradeUsage() > GRADE0) return GA_MULTIVECTOR;
	if ((mv1.gradeUsage() == 0) || (mv1.c[0] < 1.0f - epsilon) || (mv1.c[0] > 1.0f + epsilon)) 
		return GA_MULTIVECTOR;

	// test if ai * x * a is of the same grade as 'x' for all basis vectors
	int i, j, g;
	for (i = 0; i < 4; i++) { 
		mv1.gp(ai, *p3gai::bv[i]);  // todo: EUCLIDEAN?
		mv2.gp(mv1, *this);  
		mv2.compress(epsilon);
		if (mv2.gradeUsage() & (0xffff ^ GRADE1)) return GA_MULTIVECTOR;
	}

	// normalize 'a' (this is to make sure we don't misqualify 'small' (<epsilon) versors as blades
	scalar.setScalar(sqrt(fabs(scalar.c[0])));
	ai.op(scalar, *this);

	// test if a is of a single grade
	ai.compress(epsilon);
	i = ai.gradeUsage(); j = 0;
	g = GRADE0;
	while (i) {
		if (grade && (i & 1)) *grade = g;
		j += i & 1;
		i >>= 1;
		g <<= 1;
	}
	return (j <= 1) ? GA_BLADE : GA_VERSOR;
}

static int memberOf(char c, const char *set) { 
	int i = 0;
	while (set[i]) {
		if (c == set[i]) return 1;
		i++;
	}
	return 0;
}

int p3gai::parseString(const char *str, const p3ga_ben *ben /*= NULL*/) {
	int idx = 0, pmCnt, beCnt = 0;
	const int strLength = 256;
	double scalar;
	int floatStart, floatEnd, bvStart, bvEnd, i;
	p3gai blade, bv, BE, tmp;
	int stage = 0;
	char floatStr[strLength], bvStr[strLength];

	p3ga_ben defaultBen;
	if (ben == NULL) ben = &defaultBen;

	null();

	if (ben->m_startDelimiter) {
		// the first character found must be equal to m_startDelimiter
		while (str[idx] <= ' ') { // skip space until something happens
			if (str[idx] == 0) return -1; // nothing read
			idx++;
		}
		if (str[idx] != ben->m_startDelimiter) return -1; // first character is not the m_startDelimiter
		idx++;
	}

	for (;;) {
		blade.setScalar((double)1.0);
		scalar = (double)1;

		while (str[idx] <= ' ') { // skip space until something happens
			if (str[idx] == 0) return (ben->m_endDelimiter) ? -1 : idx; // done or error
			idx ++;
		}

		i = idx;
		pmCnt = 0; // plus minus count
		for (;;) { // parse [+|-]+
			if (str[idx] == '+') {scalar *= (double)+1; pmCnt++;}
			else if (str[idx] == '-') {scalar *= (double)-1; pmCnt++;}
			else if (memberOf(str[idx], "0123456789.")) break; // start of the float
			else if ((str[idx] > 0) && (str[idx] <= ' ')); // skip space
			else break;
			idx++;
		}
		if (beCnt && (!pmCnt)) return -1;

		if (memberOf(str[idx], "0123456789.")) { // parse float and '*' or '^'
			// parse the float
			floatStart = idx;
			while (memberOf(str[idx],  "0123456789.eE") ||
				(idx && ((str[idx-1] == 'e') || (str[idx-1] == 'E')) && ((str[idx] == '-') || (str[idx] == '+'))))  idx++;
			floatEnd = idx;
			memcpy(floatStr, str + floatStart, floatEnd - floatStart);
			floatStr[floatEnd - floatStart] = 0;
			if (floatEnd - floatStart <= 0) return -1;
			scalar *= (double)atof(floatStr);

			while (str[idx] <= ' ') { // skip space until something happens
				if (str[idx] == 0) {
					tmp.copy(*this); add(scalar, tmp);
					return (ben->m_endDelimiter) ? -1 : idx; // done or error
				}
				idx++;
			}

			// check if next char is +,-,* or 'ben->m_endDelimiter'
			if ((str[idx] == '+') || (str[idx] == '-')) {
				tmp.copy(*this); add(scalar, tmp);
				beCnt++;
				continue;
			}
			else if (ben->m_endDelimiter && (str[idx] == ben->m_endDelimiter)) { // end delimiter
				tmp.copy(*this); add(scalar, tmp);
				return idx+1;
			}
			else if ((str[idx] != '*') && (str[idx] != '^')) return -1; // must be either +,-, ^ or *
			else idx++; // skip over '*' or '^'

			while (str[idx] <= ' ') { // skip space until something happens
				if (str[idx] == 0) return -1; // error
				idx++;
			}
		}

		for (;;) { // parse a basis element ex ^ ey ^ ez
			bvStart = idx; // find the start and end of the basis vector name
			while ((str[idx] > ' ') && (str[idx] != '-') && (str[idx] != '+') && (str[idx] != '^') && (str[idx] != ben->m_endDelimiter)) idx ++;
			bvEnd = idx;

			// copy name, parse it 
			if ((bvEnd - bvStart + 1) >= strLength) return -1; // error (string too long)
			memcpy(bvStr, str + bvStart, bvEnd - bvStart);
			bvStr[bvEnd - bvStart] = 0;
			if (ben->lookupName(bvStr, BE) < 0) return -1; // basis vector name is invalid

			tmp.copy(blade); blade.op(tmp, BE); // wedge the basis element to the blade

			while (str[idx] <= ' ') { // skip space until something happens
				if ((str[idx] == 0) || (str[idx] == ben->m_endDelimiter))  break;
				idx++;
			}
			
			// next char must be a wedge, or this is the end of the blade
			if (str[idx] != '^') break;
			idx++;
		}

		tmp.op(scalar, blade);
		blade.copy(*this);
		add(blade, tmp);
		beCnt++;

		if (str[idx] == ben->m_endDelimiter) return idx + 1;

	}
	return idx; // the function never arrives here?
}

void p3gai::om(const p3gai &a, const p3gai_om &om) {
	int ia = 0;
	setUsage(a.usage);

	if (gradeUsage() & 1) {
		p3gai_opt_om_01x01(om.c + 0, a.c + ia, c + ia);
		ia += 1;
	}

	if (gradeUsage() & 2) {
		p3gai_opt_om_04x04(om.c + 1, a.c + ia, c + ia);
		ia += 4;
	}

	if (gradeUsage() & 4) {
		p3gai_opt_om_06x06(om.c + 17, a.c + ia, c + ia);
		ia += 6;
	}

	if (gradeUsage() & 8) {
		p3gai_opt_om_04x04(om.c + 53, a.c + ia, c + ia);
		ia += 4;
	}

	if (gradeUsage() & 16) {
		p3gai_opt_om_01x01(om.c + 69, a.c + ia, c + ia);
		ia += 1;
	}

}

void p3gai::expand(const double *pa[5]) const {
	int ia = 0;
	int i, j = 1;
	for (i = 0; i < 5; i++) {
		if (gradeUsage() & j) {
			pa[i] = c + ia;
			ia += p3gai_gradeSize[i];
		}
		else pa[i] = NULL;
		j <<= 1;
	}
}

void p3gai::expand2i(const p3gai &b, double const *pa[5], double const *pb[5]) const {
	int ia = 0;
	int i, j = 1;
	for (i = 0; i < 5; i++) {
		if (gradeUsage() & j) {
			pa[i] = c + ia;
			pb[i] = b.c + ia;
			ia += p3gai_gradeSize[i];
		}
		else pa[i] = pb[i] = NULL;
		j <<= 1;
	}
}

void p3gai::expand(const p3gai &b, double const *pa[5], double const *pb[5]) const {
	int ia = 0, ib = 0;
	int i, j = 1;
	for (i = 0; i < 5; i++) {
		if (gradeUsage() & j) {
			pa[i] = c + ia;
			ia += p3gai_gradeSize[i];
		}
		else pa[i] = NULL;
		if (b.gradeUsage() & j) {
			pb[i] = b.c + ib;
			ib += p3gai_gradeSize[i];
		}
		else pb[i] = NULL;
		j <<= 1;
	}
}

void p3gai::compress(double coordinates[16]) {
	int i, j, k, l, s, u;
	double cc[16];
	l = k = u = 0;
	for (i = 0; i < 5; i++) {
		s = p3gai_gradeSize[i];
		for (j = 0; j < s; j++)
			if (coordinates[k + j] != 0.0f) {
				u |= (1 << i);
				p3gai_copy(cc + l, coordinates + k, s);
				l += s;
				break;
			}
		k += s;
	}
	setUsage(u | (l << 5));
	p3gai_copy(c, cc, l);
}

const double *p3gai::coordinates(int grade) const {
	int ia = 0;
	int i, j = 1, gu = gradeUsage();
	static const double null[16] = {0}; // temp test for Brian Bouta problem
	for (i = 0; i < 5; i++) {
		if (j == grade) return (gu & j) ? c + ia : null;
		if (gu & j) ia += p3gai_gradeSize[i];
		j <<= 1;
	}
	return null;
}

int p3gai::fastDual(const p3gai &a) {
	setUsage(a.usage);
	int gua = a.gradeUsage(), gud = 0;
	int ia = p3gai_mvSize[gua], id = 0;
	const double *ca = a.c;
	double *cd = c;
	if (gua & GRADE4) {
		gud |= GRADE0;
		ia -= p3gai_gradeSize[4];
		cd[id + 0] = ca[ia + 0];
		id += p3gai_gradeSize[0];
	}
	if (gua & GRADE3) {
		gud |= GRADE1;
		ia -= p3gai_gradeSize[3];
		cd[id + 0] = ca[ia + 0];
		cd[id + 1] = ca[ia + 1];
		cd[id + 2] = ca[ia + 2];
		cd[id + 3] = -ca[ia + 3];
		id += p3gai_gradeSize[1];
	}
	if (gua & GRADE2) {
		gud |= GRADE2;
		ia -= p3gai_gradeSize[2];
		cd[id + 3] = -ca[ia + 0];
		cd[id + 4] = -ca[ia + 1];
		cd[id + 5] = -ca[ia + 2];
		cd[id + 0] = -ca[ia + 3];
		cd[id + 1] = -ca[ia + 4];
		cd[id + 2] = -ca[ia + 5];
		id += p3gai_gradeSize[2];
	}
	if (gua & GRADE1) {
		gud |= GRADE3;
		ia -= p3gai_gradeSize[1];
		cd[id + 0] = ca[ia + 0];
		cd[id + 1] = ca[ia + 1];
		cd[id + 2] = ca[ia + 2];
		cd[id + 3] = -ca[ia + 3];
		id += p3gai_gradeSize[3];
	}
	if (gua & GRADE0) {
		gud |= GRADE4;
		ia -= p3gai_gradeSize[0];
		cd[id + 0] = ca[ia + 0];
		id += p3gai_gradeSize[4];
	}

	usage = gud | (usage ^ gua);
	return 0;
}

void p3gai::gp(const p3gai &a, const p3gai &b) {

	double const *pa[5], *pb[5];
	double cc[16];
	a.expand(b, pa, pb);
	p3gai_general_gp(pa, pb, cc);
	compress(cc);
}

void p3gai::lcont(const p3gai &a, const p3gai &b) {

	double const *pa[5], *pb[5];
	double cc[16];
	a.expand(b, pa, pb);
	p3gai_general_lcont(pa, pb, cc);
	compress(cc);
}

void p3gai::op(const p3gai &a, const p3gai &b) {

	double const *pa[5], *pb[5];
	double cc[16];
	a.expand(b, pa, pb);
	p3gai_general_op(pa, pb, cc);
	compress(cc);
}

void p3gai::op(double a, const p3gai &b) {

	double const *pa[5], *pb[5];
	double cc[16];
	b.expand(pb);
	memset(pa + 1, 0, sizeof(double*) * 4);
	pa[0] = &a;
	p3gai_general_op(pa, pb, cc);
	compress(cc);
}

void p3gai::scp(const p3gai &a, const p3gai &b) {

	double const *pa[5], *pb[5];
	double cc[16];
	a.expand(b, pa, pb);
	p3gai_general_scp(pa, pb, cc);
	compress(cc);
}

void p3gai::hip(const p3gai &a, const p3gai &b) {

	double const *pa[5], *pb[5];
	double cc[16];
	a.expand(b, pa, pb);
	p3gai_general_hip(pa, pb, cc);
	compress(cc);
}

void p3gai::mhip(const p3gai &a, const p3gai &b) {

	double const *pa[5], *pb[5];
	double cc[16];
	a.expand(b, pa, pb);
	p3gai_general_mhip(pa, pb, cc);
	compress(cc);
}

void p3gai::rcont(const p3gai &a, const p3gai &b) {

	double const *pa[5], *pb[5];
	double cc[16];
	a.expand(b, pa, pb);
	p3gai_general_rcont(pa, pb, cc);
	compress(cc);
}
void p3gai_opt_zero_result(const double *a, const double *b, double *c) {};

int p3gai::resetProfile() {
	return 0;
}
int p3gai::printProfile(float threshold /* = 2.0 */) {
	return 0;
}
int p3gai::saveProfile(const char *filename /*  = NULL */) {
	return 0;
}

p3gai_om::p3gai_om() {
	// modification for custom float (december 9 2002)
	p3gai_null(c, 70);
}

p3gai_om::~p3gai_om() {
}

p3gai_om::p3gai_om(const p3gai vectorImages[4]) {
	initOuterMorphism(vectorImages);
}
p3gai_om::p3gai_om(const p3gai *vectorImages[4]) {
	initOuterMorphism(vectorImages);
}

int p3gai_om::initOuterMorphism(const p3gai vectorImages[4]) {
	const p3gai *vi[4];
	int i;
	for (i = 0; i < 4; i++)
		vi[i] = vectorImages + i;
	return initOuterMorphism(vi);
}

int p3gai_om::initOuterMorphism(const p3gai *vectorImages[4]) {
	int beComputed[16], i, j, k, ic, gs, bei;	// be = Basis Element
	p3gai be[16];
	double scalar = 1.0f;
	const double *bec;

	// set all vectors
	for (i = 1; i <= 4; i++) {
		be[i].takeGrade(*(vectorImages[i-1]), GRADE1);
		beComputed[i] = 1;
	}

	// compute all the other basis elements
	memset(beComputed + 4 + 1, 0, sizeof(int) * (16 - 4 - 1));
	for (i = 4 + 1; i < 16; i++)
		computeBE(be, beComputed, i);

	// insert all coordinates into the matrix
	ic = 1;
	bei = 1;
	for (i = 1; i <= 4; i++) {
		gs = p3gai_gradeSize[i];
		for (j = 0; j < gs; j++) {
			bec = be[bei].coordinates(1 << i);
			for (k = 0; k < gs; k++) {
				c[ic + k * gs] = bec[k];
			}
			ic++;
			bei++;
		}
		ic += gs * (gs-1);
	}
	return 0;
}

int p3gai_om::computeBE(p3gai be[16], int beComputed[16], int idx) {
	int i, j, err;
	p3gai tmp;

	if (!beComputed[i = p3gai_omct[idx * 3 + 0]])
		if (err = computeBE(be, beComputed, i)) return err;
	if (!beComputed[j = p3gai_omct[idx * 3 + 1]])
		if (err = computeBE(be, beComputed, j)) return err;

	if (p3gai_omct[idx * 3 + 2] < 0) {
		tmp.negate(be[i]);
		be[idx].op(tmp, be[j]);
	}
	else {
		be[idx].op(be[i], be[j]);
	}

	beComputed[idx] = 1;

	return 0;
}

int p3gai_om::initSpinor2(const p3gai &Sp) {
	int i;
	p3gai Spi, vectorImages[3], tmp, tmp2;
	Spi.versorInverse(Sp);

	for (i = 0; i < 4; i++) {
		tmp.gp(Sp, *(p3gai::bv[i]));
		tmp2.gp(tmp, Spi);
		vectorImages[i].takeGrade(tmp2, GRADE1);
	}
	
	return initOuterMorphism(vectorImages);
}

p3gai_be::p3gai_be(const char *name, const p3gai &mv) {
	initToNothing();

	if (name) m_name = strdup(name);
	m_mv.copy(mv);
}

p3gai_be::~p3gai_be() {
	if (m_name) free(m_name);
	initToNothing();
}

void p3gai_be::initToNothing() {
	m_name = NULL;
	m_mv.null();
}

int p3gai_be::compareName(const char *name)  const {
	if ((name == NULL) || (m_name == NULL)) return 0;
	return (!strcmp(name, m_name));
}

p3ga_ben::p3ga_ben() {
	initToNothing();
	setDefaults();
}

p3ga_ben::p3ga_ben(char startDelimiter, char endDelimiter) {
	initToNothing();
	setDefaults();
	setDelimiters(startDelimiter, endDelimiter);
}

p3ga_ben::~p3ga_ben() {
	removeAll();
	initToNothing();
}

void p3ga_ben::initToNothing() {
	m_ben = NULL;
	m_nbBen = 0;
	m_startDelimiter = m_endDelimiter = 0;
}

int p3ga_ben::removeAll() {
	int i;
	if (m_ben) {
		for (i = 0; i < m_nbBen; i++)
			if (m_ben[i]) delete m_ben[i];
		free(m_ben);
	}
	m_ben = NULL;
	m_nbBen = 0;
	return 0;
}

int p3ga_ben::addName(const char *name, const p3gai &mv) {
	p3gai tmpMv;
	if (lookupName(name, tmpMv) == 0) return -1; // already present in list
	
	if ( (m_ben = (p3gai_be**)realloc(m_ben, sizeof(p3gai_be*) * (m_nbBen + 1))) == NULL) {
		printf("p3ga_ben::addName(): memory allocation failure for '%d' bytes\n", sizeof(p3gai_be*) * (m_nbBen + 1));
		return -1;
	}

	if ( (m_ben[m_nbBen] = new p3gai_be(name, mv)) == NULL) {
		printf("p3ga_ben::addName(): memory allocation failure for '%d' bytes\n", sizeof(p3gai_be));
		return -1;
	}

	m_nbBen++;

	return 0;
}

int p3ga_ben::removeName(const char *name) {
	int i;

	for (i = 0; i < m_nbBen; i++)
		if (m_ben[i]->compareName(name)) {
			delete m_ben[i];
			m_ben[i] = m_ben[m_nbBen - 1];
			m_nbBen--;
			i--;
		}

	return 0;
}

int p3ga_ben::lookupName(const char *name, p3gai &mv) const {
	int i;

	for (i = 0; i < m_nbBen; i++)
		if (m_ben[i]->compareName(name)) {
			mv.copy(m_ben[i]->m_mv);
			return 0;
		}

	return -1;
}

int p3ga_ben::setDelimiters(char startDelimiter, char endDelimiter) {
	if ((startDelimiter < 0) || (endDelimiter < 0)) return -1;
	m_startDelimiter = startDelimiter;
	m_endDelimiter = endDelimiter;
	return 0;
}

int p3ga_ben::setDefaults() {
	int err;
	removeAll();
	m_startDelimiter = m_endDelimiter = 0;
	if (err = addName("e1", p3gai::e1)) return err;
	if (err = addName("e2", p3gai::e2)) return err;
	if (err = addName("e3", p3gai::e3)) return err;
	if (err = addName("e0", p3gai::e0)) return err;
	return 0;
}


//Merging /usr/local/include/gaigen/gaigenhl.cpp into generated code:

// DO NOT TRY TO COMPILE THIS FILE DIRECTLY.
// IT IS MEANT TO BE INCLUDED BY GENERATED CODE!

/*
 *
 * Gaigen, Copyright (c) 2001-2004, University of Amsterdam
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *      * Redistributions of source code must retain the above copyright
 *        notice, this list of conditions and the following disclaimer.
 *      * Redistributions in binary form must reproduce the above copyright
 *        notice, this list of conditions and the following disclaimer in
 *        the documentation and/or other materials provided with the
 *        distribution.
 *      * Neither the name of the University of Amsterdam nor the names of its
 *        contributors may be used to endorse or promote products derived
 *        from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
 * CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
 * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 */


#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#ifdef GAIM_NAMESPACE
namespace CLASSNAME_NS {
#endif // GAIM_NAMESPACE

CLASSNAME::CLASSNAME() {

}
/*
CLASSNAME::CLASSNAME(GAIM_CLASSNAME &a) {
	copy(a);
}
*/
CLASSNAME::~CLASSNAME() {

}

GAIM_RETURN_TYPE CLASSNAME::operator=(const CLASSNAME &a) {
	copy(a);
	return *this;
}

GAIM_RETURN_TYPE CLASSNAME::operator=(GAIM_FLOAT f) {
	set(GRADE0, &f);
	return *this;
}

#ifdef GAIM_FUNCTION_FASTTEMPVAR
GAIM_RETURN_TYPE CLASSNAME::getTemp() {
	// gets a temporary variable (based on Stroustup (heaven help you if you write an expression which requires more than MV_MAX_TEMP temporaries))
	static int idx = 0;
	static CLASSNAME *temp = NULL;
	if (!temp) {
		int i;
		temp = new CLASSNAME[MV_MAX_TEMP];
		for (i = 0; i < MV_MAX_TEMP; i++) {
			temp[i].setUsage(0xf | (0x7 << 4));
			temp[i].setUsage(0);
		}
	}
//	printf("Temp idx = %d\n", idx);
	if (idx == MV_MAX_TEMP) idx = 0;
	return temp[idx++];
}
#endif // GAIM_FUNCTION_FASTTEMPVAR

#ifdef GAIM_FUNCTION_TAKEGRADE
GAIM_RETURN_TYPE CLASSNAME::grade(int g) const {
	GAIM_RETURN_VAR(result);
//	GAIM_RETURN_VAR(result);
	result.takeGrade(*this, g);
	return result;
}
#endif // GAIM_FUNCTION_TAKEGRADE


#ifdef GAIM_FUNCTION_REVERSE
GAIM_RETURN_TYPE CLASSNAME::operator~() const {
	GAIM_RETURN_VAR(result);
	((GAIM_CLASSNAME&)result).reverse(*this);
	return result;
}
#endif // GAIM_FUNCTION_REVERSE

#ifdef GAIM_FUNCTION_CLIFFORDCONJUGATE
GAIM_RETURN_TYPE CLASSNAME::operator--() const {
	GAIM_RETURN_VAR(result);
	((GAIM_CLASSNAME&)result).cliffordConjugate(*this);
	return result;
}
#endif // GAIM_FUNCTION_CLIFFORDCONJUGATE

#ifdef GAIM_FUNCTION_GRADEINVOLUTION
GAIM_RETURN_TYPE CLASSNAME::operator++() const {
	GAIM_RETURN_VAR(result);
	((GAIM_CLASSNAME&)result).gradeInvolution(*this);
	return result;
}
#endif // GAIM_FUNCTION_GRADEINVOLUTION

#ifdef GAIM_PRODUCT_GP
GAIM_RETURN_TYPE CLASSNAME::operator*=(const CLASSNAME &a) {
	CLASSNAME tmp;
	tmp.gp(*this, a);
	this->copy(tmp);
	return *this;
}
GAIM_RETURN_TYPE CLASSNAME::operator*=(GAIM_FLOAT a) {
	CLASSNAME tmp;
	tmp.op(a, *this);
	this->copy(tmp);
	return *this;
}
GAIM_RETURN_TYPE gp(const CLASSNAME &a, const CLASSNAME &b) {
	GAIM_RETURN_VAR(result);
	result.gp(a, b);
	return result;
}
GAIM_RETURN_TYPE gp(GAIM_FLOAT a, const CLASSNAME &b) {
	GAIM_RETURN_VAR(result);
	result.op(a, b);
	return result;
}

#define USE_NEW_EXP

#ifdef USE_OLD_EXP
GAIM_RETURN_TYPE CLASSNAME::exp(int order /*= 9*/) const {
	int i, div = 1;
	GAIM_RETURN_VAR(result);

	result.setScalar(1.0);
	if (order == 0) return result;

	CLASSNAME tmp(*this);

	for (i = 1; i < order; i++) {
		result += tmp * (GAIM_FLOAT)(1.0 / (GAIM_FLOAT)div);

		if (i < order-1) {
			div *= (i+1);
			tmp *= *this;
		}
	}

	return result;
}
#endif /* USE_OLD_EXP */

#ifdef USE_NEW_EXP
GAIM_RETURN_TYPE CLASSNAME::exp(int order /*= 9*/) const {
	/*
	Improved version of exp thanks to Robert Valkenburg & students
	*/
    int i;
    CLASSNAME result;

    result.setScalar(1.0);
    if (order == 0) {
        GAIM_RETURN_VAR(r);
        r = result;
        return r;
    }

    // scale by power of 2 so that its norm is < 1
    unsigned long max = (unsigned long)largestCoordinate();
    unsigned long scale=1;
    if (max > 1) scale <<= 1;
    while (max)
    {
        max >>= 1;
        scale <<= 1;
    }

    CLASSNAME scaled = (*this) / (GAIM_FLOAT)(scale);

    // taylor approximation
    CLASSNAME tmp;

    tmp.setScalar(1.0);
    for (i = 1; i < order; i++) {
        tmp = tmp*scaled/(GAIM_FLOAT)(i);
        result += tmp;
    }

    // undo scaling
    while (scale > 1)
    {
        result *= result;
        scale >>= 1;
    }
    GAIM_RETURN_VAR(r);
    r = result;
    return r;
}
#endif /* USE_NEW_EXP */


#ifndef GAIM_FUNCTION_FASTDUAL
GAIM_RETURN_TYPE CLASSNAME::dual() const {
	GAIM_RETURN_VAR(result);
	result.gp(*this, Ii);
	return result;
}
#endif // GAIM_FUNCTION_FASTDUAL

#endif // GAIM_PRODUCT_GP

#ifdef GAIM_PRODUCT_GP_EM
GAIM_RETURN_TYPE gpem (const CLASSNAME &a, const CLASSNAME &b) {
	GAIM_RETURN_VAR(result);
	result. GAIM_PRODUCT_GP_EM (a, b);
	return result;
}
GAIM_RETURN_TYPE gpem (GAIM_FLOAT a, const CLASSNAME &b) {
	GAIM_RETURN_VAR(result);
	result.op(a, b);
	return result;
}
#endif // GAIM_PRODUCT_GP_EM


#ifdef GAIM_FUNCTION_FASTDUAL
GAIM_RETURN_TYPE CLASSNAME::fastDual() const {
	GAIM_RETURN_VAR(result);
	((GAIM_CLASSNAME&)result).fastDual(*this);
	return result;
}
#endif // GAIM_FUNCTION_FASTDUAL


#ifdef GAIM_FUNCTION_VERSORINVERSE
GAIM_RETURN_TYPE CLASSNAME::versorInverse() const {
	GAIM_RETURN_VAR(result);
	result.versorInverse(*this);
	return result;
}
#endif
#ifdef GAIM_FUNCTION_LOUNESTOINVERSE
GAIM_RETURN_TYPE CLASSNAME::lounestoInverse() const {
	GAIM_RETURN_VAR(result);
	result.lounestoInverse(*this);
	return result;
}
#endif
#ifdef GAIM_FUNCTION_GENERALINVERSE
GAIM_RETURN_TYPE CLASSNAME::generalInverse() const {
	GAIM_RETURN_VAR(result);
	result.generalInverse(*this);
	return result;
}
#endif

#ifdef GAIM_PRODUCT_IGP
GAIM_RETURN_TYPE CLASSNAME::inverse() const {
	GAIM_RETURN_VAR(result);
	result.inverse(*this);
	return result;
}

GAIM_RETURN_TYPE CLASSNAME::operator/=(const CLASSNAME &a) {
	CLASSNAME tmp, tmp2;
	tmp2.inverse(a);
	tmp.gp(*this, tmp2);
	this->copy(tmp);
	return *this;
}
GAIM_RETURN_TYPE CLASSNAME::operator/=(GAIM_FLOAT a) {
	CLASSNAME tmp;
	tmp.op(1.0f / a, *this);
	this->copy(tmp);
	return *this;
}
#endif // GAIM_PRODUCT_IGP

#ifdef GAIM_PRODUCT_SCP
GAIM_RETURN_TYPE CLASSNAME::operator%=(const CLASSNAME &a) {
	CLASSNAME tmp;
	tmp.scp(*this, a);
	this->copy(tmp);
	return *this;
}
GAIM_RETURN_TYPE CLASSNAME::operator%=(GAIM_FLOAT a) {
	GAIM_FLOAT f = scalar() * a;
	setScalar(&f);
	return *this;
}
GAIM_RETURN_TYPE scp(const CLASSNAME &a, const CLASSNAME &b) {
	GAIM_RETURN_VAR(result);
	result.scp(a, b);
	return result;
}
GAIM_RETURN_TYPE scp(GAIM_FLOAT a, const CLASSNAME &b) {
	GAIM_RETURN_VAR(result);
	result.set(GRADE0, mulScalar(a, b.scalar()));
	return result;
}
#endif // GAIM_PRODUCT_SCP

#ifdef GAIM_PRODUCT_LCONT
GAIM_RETURN_TYPE lcont(const CLASSNAME &a, const CLASSNAME &b) {
	GAIM_RETURN_VAR(result);
	result.lcont(a, b);
	return result;
}
GAIM_RETURN_TYPE CLASSNAME::operator<<=(const CLASSNAME &a) {
	CLASSNAME tmp;
	tmp.lcont(*this, a);
	this->copy(tmp);
	return *this;
}
#endif // GAIM_PRODUCT_LCONT

#ifdef GAIM_PRODUCT_LCONT_EM
GAIM_RETURN_TYPE lcem(const CLASSNAME &a, const CLASSNAME &b) {
	GAIM_RETURN_VAR(result);
	result. GAIM_PRODUCT_LCONT_EM (a, b);
	return result;
}
#endif // GAIM_PRODUCT_LCONT_EM

#ifdef GAIM_PRODUCT_RCONT
GAIM_RETURN_TYPE rcont(const CLASSNAME &a, const CLASSNAME &b) {
	GAIM_RETURN_VAR(result);
	result.rcont(a, b);
	return result;
}
GAIM_RETURN_TYPE CLASSNAME::operator>>=(const CLASSNAME &a) {
	CLASSNAME tmp;
	tmp.rcont(*this, a);
	this->copy(tmp);
	return *this;
}
#endif // GAIM_PRODUCT_RCONT

#ifdef GAIM_PRODUCT_HIP
GAIM_RETURN_TYPE hip(const CLASSNAME &a, const CLASSNAME &b) {
	GAIM_RETURN_VAR(result);
	result.hip(a, b);
	return result;
}
GAIM_RETURN_TYPE hip(GAIM_FLOAT a, const CLASSNAME &b) {
	GAIM_RETURN_VAR(result);
	CLASSNAME _a(a);
	result.hip(_a, b);
	return result;
}
GAIM_RETURN_TYPE hip(const CLASSNAME &a, GAIM_FLOAT b) {
	GAIM_RETURN_VAR(result);
	CLASSNAME _b(b);
	result.hip(a, _b);
	return result;
}
#endif // GAIM_PRODUCT_HIP

#ifdef GAIM_PRODUCT_MHIP
GAIM_RETURN_TYPE mhip(const CLASSNAME &a, const CLASSNAME &b) { // GAIM_RETURN_TYPE used to read CLASSNAME & (modified 10-10-2002)
	GAIM_RETURN_VAR(result);
	result.mhip(a, b);
	return result;
}
GAIM_RETURN_TYPE mhip(GAIM_FLOAT a, const CLASSNAME &b) {
	GAIM_RETURN_VAR(result);
	CLASSNAME _a(a);
	result.mhip(_a, b);
	return result;
}
GAIM_RETURN_TYPE mhip(const CLASSNAME &a, GAIM_FLOAT b) {
	GAIM_RETURN_VAR(result);
	CLASSNAME _b(b);
	result.mhip(a, _b);
	return result;
}
#endif // GAIM_PRODUCT_MHIP


#ifdef GAIM_PRODUCT_OP
GAIM_RETURN_TYPE op(GAIM_FLOAT a, const CLASSNAME &b) {
	GAIM_RETURN_VAR(result);
	result.op(a, b);
	return result;
}
GAIM_RETURN_TYPE op(const CLASSNAME &a, const CLASSNAME &b) {
	GAIM_RETURN_VAR(result);
	result.op(a, b);
	return result;
}
GAIM_RETURN_TYPE CLASSNAME::operator^=(const CLASSNAME &a) {
	CLASSNAME tmp;
	tmp.op(*this, a);
	this->copy(tmp);
	return *this;
}
GAIM_RETURN_TYPE CLASSNAME::operator^=(GAIM_FLOAT a) {
	CLASSNAME tmp;
	tmp.op(a, *this);
	this->copy(tmp);
	return *this;
}
#endif // GAIM_PRODUCT_OP

#ifdef GAIM_FUNCTION_MEETJOIN
GAIM_RETURN_TYPE meet(const CLASSNAME &a, const CLASSNAME &b) {
	GAIM_RETURN_VAR(result);
	result.meet(a, b);
	return result;
}

GAIM_RETURN_TYPE join(const CLASSNAME &a, const CLASSNAME &b) {
	GAIM_RETURN_VAR(result);
	result.join(a, b);
	return result;
}

#endif // GAIM_FUNCTION_MEETJOIN


#ifdef GAIM_FUNCTION_ADD
GAIM_RETURN_TYPE add(const CLASSNAME &a, const CLASSNAME &b) {
	GAIM_RETURN_VAR(result);
	result.add(a, b);
	return result;
}
GAIM_RETURN_TYPE add(GAIM_FLOAT a, const CLASSNAME &b) {
	GAIM_RETURN_VAR(result);
	result.add(a, b);
	return result;
}
GAIM_RETURN_TYPE CLASSNAME::operator+=(const CLASSNAME &a) {
	CLASSNAME tmp;
	tmp.add(*this, a);
	this->copy(tmp);
	return *this;
}
GAIM_RETURN_TYPE CLASSNAME::operator+=(GAIM_FLOAT a) {
	CLASSNAME tmp;
	tmp.add(a, *this);
	this->copy(tmp);
	return *this;
}
#endif // GAIM_FUNCTION_ADD

#ifdef GAIM_FUNCTION_SUBSTRACT
GAIM_RETURN_TYPE sub(const CLASSNAME &a, const CLASSNAME &b) {
	GAIM_RETURN_VAR(result);
	result.sub(a, b);
	return result;
}
GAIM_RETURN_TYPE sub(GAIM_FLOAT a, const CLASSNAME &b) {
	GAIM_RETURN_VAR(result);
	result.sub(a, b);
	return result;
}
GAIM_RETURN_TYPE CLASSNAME::operator-=(const CLASSNAME &a) {
	CLASSNAME tmp;
	tmp.sub(*this, a);
	this->copy(tmp);
	return *this;
}
GAIM_RETURN_TYPE CLASSNAME::operator-=(GAIM_FLOAT a) {
	CLASSNAME tmp;
	tmp.add(a, *this);
	this->copy(tmp);
	return *this;
}
#endif // GAIM_FUNCTION_SUBSTRACT

#ifdef GAIM_FUNCTION_NEGATE
GAIM_RETURN_TYPE negate(const CLASSNAME &a) {
	GAIM_RETURN_VAR(result);
	((GAIM_CLASSNAME&)result).negate(a);
	return result;
}
#endif //GAIM_FUNCTION_NEGATE



#ifdef GAIM_FUNCTION_NORMALIZE
GAIM_RETURN_TYPE CLASSNAME::normal(int norm /* = 1 */) const {
	GAIM_RETURN_VAR(result);
	result.normalize(*this, norm);
	return result;
}
#endif // GAIM_FUNCTION_NORMALIZE


#ifdef GAIM_PRODUCT_OM
CLASSNAME_OM::CLASSNAME_OM(const CLASSNAME *vectorImages[3]) {
	initVectorImages(vectorImages);
}

CLASSNAME_OM::CLASSNAME_OM(const CLASSNAME &spinor) {
	initSpinor(spinor);
}


int CLASSNAME_OM::initSpinor(const CLASSNAME &spinor) {
	CLASSNAME si(spinor.inverse()), v, vi[GA_MAX_DIM];
	GAIM_FLOAT coordinates[GA_MAX_DIM];
	int i;

	memset(coordinates, 0, sizeof(GAIM_FLOAT) * GA_MAX_DIM);

	for (i = 0; i < CLASSNAME::dim; i++) {
		coordinates[i] = 1.0;
		if (i > 0) coordinates[i-1] = 0.0;
		v.setVector(coordinates);
		vi[i] = ((spinor * v) * si)(GRADE1);

	}
	return initVectorImages(vi);
}


GAIM_RETURN_TYPE om(const CLASSNAME_OM &om, const CLASSNAME &a) {
	GAIM_RETURN_VAR(result);

	result.om(a, om);

	return result;
}


#ifdef GAIM_NAMESPACE
}
#endif // GAIM_NAMESPACE


#endif // GAIM_PRODUCT_OM


