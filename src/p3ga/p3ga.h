
/*
Gaigen 1.0, Copyright (c) 2001-2010, University of Amsterdam

Copying, use and development for education and research purposes 
permitted as long as this license is not removed from the files.

All rights for commercial use reserved; for more information
contact Daniel Fontijne (fontijne@science.uva.nl)

This software is unsupported.
*/
/*
Header file p3ga.h, generated by Gaigen 1.0 on Mon Mar 22 19:10:50 2010
*/
#ifndef _p3ga_H_
#define _p3ga_H_

#include <stdio.h>
#include <stdlib.h>

// undefine all definitions possibly made in other gaigen header file
// This is important when multiple algebras are used in the same application
#undef GAIM_PRODUCT_GP
#undef GAIM_PRODUCT_LCONT
#undef GAIM_PRODUCT_OP
#undef GAIM_PRODUCT_SCP
#undef GAIM_PRODUCT_HIP
#undef GAIM_PRODUCT_MHIP
#undef GAIM_PRODUCT_RCONT
#undef GAIM_PRODUCT_IGP
#undef GAIM_PRODUCT_GP_EM
#undef GAIM_PRODUCT_LCONT_EM
#undef GAIM_PRODUCT_OM
#undef GAIM_FUNCTION_GRADEINVOLUTION
#undef GAIM_FUNCTION_REVERSE
#undef GAIM_FUNCTION_NEGATE
#undef GAIM_FUNCTION_ADD
#undef GAIM_FUNCTION_SUBSTRACT
#undef GAIM_FUNCTION_NORM_A
#undef GAIM_FUNCTION_NORMALIZE
#undef GAIM_FUNCTION_TAKEGRADE
#undef GAIM_FUNCTION_VERSORINVERSE
#undef GAIM_FUNCTION_GENERALINVERSE
#undef GAIM_FUNCTION_SPINORPRODUCT
#undef GAIM_FUNCTION_CLIFFORDCONJUGATE
#undef GAIM_FUNCTION_LOUNESTOINVERSE
#undef GAIM_FUNCTION_HIGHESTGRADE
#undef GAIM_FUNCTION_GRADE
#undef GAIM_FUNCTION_OUTERMORPHISM
#undef GAIM_FUNCTION_PROJECT
#undef GAIM_FUNCTION_MEETJOIN
#undef GAIM_FUNCTION_RANDOM
#undef GAIM_FUNCTION_RECIPROCALFRAME
#undef GAIM_FUNCTION_PROFILE
#undef GAIM_FUNCTION_FACTOR
#undef GAIM_FUNCTION_FASTTEMPVAR
#undef GAIM_FUNCTION_FASTDUAL
#undef GAIM_FUNCTION_MULTIVECTORTYPE
#undef GAIM_FUNCTION_PARSESTRING
#undef GAIM_FUNCTION_NAMESPACE
#undef GAIM_FUNCTION_USINGNAMESPACE
#undef GAIM_FUNCTION_UNDEFINED
#undef GAIM_FUNCTION_UNDEFINED
#undef GAIM_FUNCTION_UNDEFINED
#undef GAIM_FUNCTION_UNDEFINED
#undef GAIM_INVERSEPSEUDOSCALAR
#undef GAIM_PSEUDOSCALAR
#undef GAIM_FLOAT
#undef GAIM_DOUBLE
#undef GAIM_CLASSNAME
#undef GAIM_OM_CLASSNAME
#undef GAIM_CONSTRUCTOR_1_COOR
#undef GAIM_CONSTRUCTOR_2_COOR
#undef GAIM_CONSTRUCTOR_3_COOR
#undef GAIM_CONSTRUCTOR_4_COOR
#undef GAIM_CONSTRUCTOR_5_COOR
#undef GAIM_CONSTRUCTOR_6_COOR
#undef GAIM_CONSTRUCTOR_7_COOR
#undef GAIM_CONSTRUCTOR_8_COOR

// what functions/products are implemented (used by superclass):
#define GAIM_PRODUCT_GP
#define GAIM_PRODUCT_IGP
#define GAIM_PRODUCT_GP_EM gp
#define GAIM_PRODUCT_LCONT
#define GAIM_PRODUCT_LCONT_EM lcont
#define GAIM_PRODUCT_OP
#define GAIM_PRODUCT_SCP
#define GAIM_PRODUCT_HIP
#define GAIM_PRODUCT_MHIP
#define GAIM_PRODUCT_RCONT
#define GAIM_PRODUCT_OM
#define GAIM_FUNCTION_GRADEINVOLUTION
#define GAIM_FUNCTION_REVERSE
#define GAIM_FUNCTION_NEGATE
#define GAIM_FUNCTION_ADD
#define GAIM_FUNCTION_SUBSTRACT
#define GAIM_FUNCTION_NORM_A
#define GAIM_FUNCTION_NORMALIZE
#define GAIM_FUNCTION_TAKEGRADE
#define GAIM_FUNCTION_VERSORINVERSE
#define GAIM_FUNCTION_GENERALINVERSE
#define GAIM_FUNCTION_CLIFFORDCONJUGATE
#define GAIM_FUNCTION_HIGHESTGRADE
#define GAIM_FUNCTION_GRADE
#define GAIM_FUNCTION_OUTERMORPHISM
#define GAIM_FUNCTION_PROJECT
#define GAIM_FUNCTION_MEETJOIN
#define GAIM_FUNCTION_RANDOM
#define GAIM_FUNCTION_RECIPROCALFRAME
#define GAIM_FUNCTION_FACTOR
#define GAIM_FUNCTION_FASTTEMPVAR
#define GAIM_FUNCTION_FASTDUAL
#define GAIM_FUNCTION_MULTIVECTORTYPE
#define GAIM_FUNCTION_PARSESTRING
#define GAIM_INVERSEPSEUDOSCALAR p3gai::Ii
#define GAIM_PSEUDOSCALAR p3gai::I
#define GAIM_FLOAT double
#define GAIM_DOUBLE
#define GAIM_CLASSNAME p3gai
#define GAIM_OM_CLASSNAME p3gai_om

#define GAIM_CONSTRUCTOR_1_COOR
#define GAIM_CONSTRUCTOR_4_COOR
#define GAIM_CONSTRUCTOR_6_COOR

/* grade macros */
#ifndef GRADE0
#define GRADE0 (1 << 0)
#endif
#ifndef GRADE1
#define GRADE1 (1 << 1)
#endif
#ifndef GRADE2
#define GRADE2 (1 << 2)
#endif
#ifndef GRADE3
#define GRADE3 (1 << 3)
#endif
#ifndef GRADE4
#define GRADE4 (1 << 4)
#endif

/* coordinate macros */
#define P3GA_S 0
#define P3GA_I 0
#define P3GA_E1 0
#define P3GA_E2 1
#define P3GA_E3 2
#define P3GA_E0 3
#define P3GA_E2_E3 0
#define P3GA_E3_E1 1
#define P3GA_E1_E2 2
#define P3GA_E1_E0 3
#define P3GA_E2_E0 4
#define P3GA_E3_E0 5
#define P3GA_E2_E3_E0 0
#define P3GA_E3_E1_E0 1
#define P3GA_E1_E2_E0 2
#define P3GA_E1_E2_E3 3

#define GA_BLADE 1 // (versor of a single grade)
#define GA_VERSOR  2 // versor (invertible product of vectors)
#define GA_MULTIVECTOR 3 // the most general type of multivector
extern const char *p3gai_typeNames[4];

// the layer 0 functions:
// layer 0 functions are always pure C, unless custom float class if used
extern "C" {

extern const int p3gai_omct[48];
extern const int *p3gai_bevt[5];
extern const int p3gai_newBevt[16];
extern char *p3gai_basisElementNames[16];
extern int p3gai_gradeSize[5];
extern int p3gai_mvSize[32];

/* optimized implementations of products with a result of zero: */
extern void p3gai_opt_zero_result(const double *a, const double *b, double *c);

/* optimized implementations of products: (to be compiled from .opt file) */
extern void p3gai_general_gp(const double *a[], const double *b[], double *c);
extern void p3gai_general_lcont(const double *a[], const double *b[], double *c);
extern void p3gai_general_op(const double *a[], const double *b[], double *c);
extern void p3gai_general_scp(const double *a[], const double *b[], double *c);
extern void p3gai_general_hip(const double *a[], const double *b[], double *c);
extern void p3gai_general_mhip(const double *a[], const double *b[], double *c);
extern void p3gai_general_rcont(const double *a[], const double *b[], double *c);
extern void p3gai_opt_om_01x01(const double *a, const double *b, double *c);
extern void p3gai_opt_om_04x04(const double *a, const double *b, double *c);
extern void p3gai_opt_om_06x06(const double *a, const double *b, double *c);

extern void p3gai_copy(double *dest, const double *src, int length);
extern void p3gai_null(double *dest, int length);
extern void p3gai_reverse(double *a[5]);
extern void p3gai_cliffordConjugate(double *a[5]);
extern void p3gai_involution(double *a[5]);
extern void p3gai_negate(double *dest, const double *src, int length);
extern void p3gai_addSameGradeUsage(double *c, const double *a, const double *b, int length);
extern void p3gai_add(const double *a[5], const double *b[5], double *c[5]);
extern void p3gai_subSameGradeUsage(double *c, const double *a, const double *b, int length);
extern void p3gai_sub(const double *a[5], const double *b[5], double *c[5]);
extern double p3gai_norm_a(const double a[], int nb);
// end of the layer 0 functions
} /* end of 'extern "C"' */


class p3gai_om;
class p3gai_be;
class p3ga_ben;
class p3ga;

class p3gai {
public:
	static p3gai e1;
	static p3gai e2;
	static p3gai e3;
	static p3gai e0;
	static p3gai *bv[4];
	static p3gai I;
	static p3gai Ii;

	static const int dim;
	static const int nbCoor;

	p3gai();
	p3gai(const p3gai &a);
	~p3gai();
	p3gai(int gradeUsage, const double *coordinates);
	p3gai(int grade, double c0);
	p3gai(int grade, double c0, double c1, double c2, double c3);
	p3gai(int grade, double c0, double c1, double c2, double c3, double c4, double c5);

	void null();

	void set(int gradeUsage, const double *coordinates);
	void setScalar(const double coordinates[1]);
	void setVector(const double coordinates[4]);
	void set2Vector(const double coordinates[6]);
	void set3Vector(const double coordinates[4]);
	void set4Vector(const double coordinates[1]);
	int set(int grade, double c0);
	int set(int grade, double c0, double c1, double c2, double c3);
	int set(int grade, double c0, double c1, double c2, double c3, double c4, double c5);
	inline int setScalar(double c0)
		{return set(GRADE0, c0);}
	inline int setVector(double c0, double c1, double c2, double c3)
		{return set(GRADE1, c0, c1, c2, c3);}
	inline int set2Vector(double c0, double c1, double c2, double c3, double c4, double c5)
		{return set(GRADE2, c0, c1, c2, c3, c4, c5);}
	inline int set3Vector(double c0, double c1, double c2, double c3)
		{return set(GRADE3, c0, c1, c2, c3);}
	inline int set4Vector(double c0)
		{return set(GRADE4, c0);}

	inline double scalar() const {return((gradeUsage() & GRADE0) ? c[0] : (double)0.0);};

	const char *string(const char *prec = NULL) const;
	void print(const char *text = NULL, const char *prec = NULL) const;
	void fprint(FILE *F, const char *text = NULL, const char *prec = NULL) const;

	static const char *fpPrecision; // floating point precision (during printing)
	static const char *stringStartDelimiter, *stringEndDelimiter; // start and end delimiters of string
	static int setFPPrecision(const char *prec);
	static int setStringDelimiters(char start, char end);
	static int renameBasisVector(const char *oldName, const char *newName); // renames basis vector 'oldName' to 'newName'
	

	int usage; /* usage of grades/memory */
	inline int gradeUsage() const {return usage & 0x1f;}
	inline int memUsage() const {return (usage>>0x5) & 0x1f;}


	void gp(const p3gai &a, const p3gai &b);

	void lcont(const p3gai &a, const p3gai &b);

	void op(const p3gai &a, const p3gai &b);

	void op(double scalar, const p3gai &a);
	inline void op(const p3gai &a, double scalar) {op(scalar, a);};

	void scp(const p3gai &a, const p3gai &b);

	void hip(const p3gai &a, const p3gai &b);

	void mhip(const p3gai &a, const p3gai &b);

	void rcont(const p3gai &a, const p3gai &b);
	void copy(const p3gai &a);
	void compress(double epsilon = 1e-14); // compresses (removes all grades which are 0) this multivector in place
	void reverse(const p3gai &a);
	void cliffordConjugate(const p3gai &a);
	void gradeInvolution(const p3gai &a);
	void negate(const p3gai &a);

	void add(const p3gai &a, const p3gai &b);
	void add(double scalar, const p3gai &b);
	inline void add(const p3gai &b, double scalar) {add(scalar, b);};

	void sub(const p3gai &a, const p3gai &b);
	void sub(double scalar, const p3gai &b);
	inline void sub(const p3gai &b, double scalar) {sub(scalar, b);};
	void takeGrade(const p3gai &a, int grade);

	int highestGrade(const p3gai &a, double epsilon = 1e-14);

	int grade() const; // return the grade of 'this', if 'this' is a homogeneous multivector; otherwise it returns -1
	int largestGrade() const; // return the grade with the largest norm_a
	int maxGrade() const; // return the maximum non zero grade of 'this', returns -1 if this = 0
	int versorInverse(const p3gai &a); // compute inverse, for versors only
	int generalInverse(const p3gai &a); // compute inverse, for general multivectors; uses gaussian elimination (slower and less stable than versorInverse)
	void om(const p3gai &a, const p3gai_om &om);
	void expand(double matrix[], const int table[]) const;
	double norm_a() const;
	double norm_b() const;
	double largestCoordinate() const;
	void normalize(const p3gai &a, int norm);

	int project(const p3gai &blade, const p3gai &a);
	int projectOntoVersor(const p3gai &versor, const p3gai &a);
	int reject(const p3gai &blade, const p3gai &a);

	int factor(p3gai factors[], int versor = 0) const;
	inline int factorVersor(p3gai factors[]) const {return factor(factors, 1);};

	int deltaProduct(const p3gai &a, const p3gai &b); // sets this to delta(a, b); returns the grade of the delta product
	int join(const p3gai &a, const p3gai &b, int algorithm = 1); // sets this to join(a, b); returns the grade of the join
	int meet(const p3gai &a, const p3gai &b, int algorithm = 1); // sets this to meet(a, b); returns the grade of the meet
protected:
	int joinAlg1(const p3gai &a, const p3gai &b, int ga, int gb, int gj);
	int joinAlg2(const p3gai &a, const p3gai &b, int ga, int gb, int gj);
public:

	inline int randomBlade(int grade, double scale) {return random(grade, scale, 0);}
	inline int randomVersor(int grade, double scale) {return random(grade, scale, 1);}
	int random(int grade, double scale, int versor);

	static int reciprocalFrame(p3gai f[], const p3gai e[], int nbVectors);

	int mvType(int *grade = NULL, double epsilon = 1e-14) const;

	int parseString(const char *str, const p3ga_ben *ben = NULL);

	const double *coordinates(int grade) const;
	inline double get_e1() const {
		return (gradeUsage() & GRADE1) ? c[p3gai_mvSize[gradeUsage() & 1] + 0] : (double)0.0;
	}
	inline double get_e2() const {
		return (gradeUsage() & GRADE1) ? c[p3gai_mvSize[gradeUsage() & 1] + 1] : (double)0.0;
	}
	inline double get_e3() const {
		return (gradeUsage() & GRADE1) ? c[p3gai_mvSize[gradeUsage() & 1] + 2] : (double)0.0;
	}
	inline double get_e0() const {
		return (gradeUsage() & GRADE1) ? c[p3gai_mvSize[gradeUsage() & 1] + 3] : (double)0.0;
	}
	inline double get_e2_e3() const {
		return (gradeUsage() & GRADE2) ? c[p3gai_mvSize[gradeUsage() & 3] + 0] : (double)0.0;
	}
	inline double get_e3_e1() const {
		return (gradeUsage() & GRADE2) ? c[p3gai_mvSize[gradeUsage() & 3] + 1] : (double)0.0;
	}
	inline double get_e1_e2() const {
		return (gradeUsage() & GRADE2) ? c[p3gai_mvSize[gradeUsage() & 3] + 2] : (double)0.0;
	}
	inline double get_e1_e0() const {
		return (gradeUsage() & GRADE2) ? c[p3gai_mvSize[gradeUsage() & 3] + 3] : (double)0.0;
	}
	inline double get_e2_e0() const {
		return (gradeUsage() & GRADE2) ? c[p3gai_mvSize[gradeUsage() & 3] + 4] : (double)0.0;
	}
	inline double get_e3_e0() const {
		return (gradeUsage() & GRADE2) ? c[p3gai_mvSize[gradeUsage() & 3] + 5] : (double)0.0;
	}
	inline double get_e2_e3_e0() const {
		return (gradeUsage() & GRADE3) ? c[p3gai_mvSize[gradeUsage() & 7] + 0] : (double)0.0;
	}
	inline double get_e3_e1_e0() const {
		return (gradeUsage() & GRADE3) ? c[p3gai_mvSize[gradeUsage() & 7] + 1] : (double)0.0;
	}
	inline double get_e1_e2_e0() const {
		return (gradeUsage() & GRADE3) ? c[p3gai_mvSize[gradeUsage() & 7] + 2] : (double)0.0;
	}
	inline double get_e1_e2_e3() const {
		return (gradeUsage() & GRADE3) ? c[p3gai_mvSize[gradeUsage() & 7] + 3] : (double)0.0;
	}
	inline double get_e1_e2_e3_e0() const {
		return (gradeUsage() & GRADE4) ? c[p3gai_mvSize[gradeUsage() & 15] + 0] : (double)0.0;
	}

	int fastDual(const p3gai &a);

	double *c;
protected:
	void setUsage(int u);
	static int nbBlocksAvailable[17];
	static int maxBlocksAvailable[17];
	static double **blocks[17];
	void doubleMaxBlocks(int n);
	void addBlocks(int n);

	void expand(const double *pa[5]) const;
	void expand2i(const p3gai &b, double const *pa[5], double const *pb[5]) const;
	void expand(const p3gai &b, double const *pa[5], double const *pb[5]) const;
	void compress(double coordinates[16]);

public:
	static int resetProfile();
	static int printProfile(float threshold = 2.0);
	static int saveProfile(const char *filename = NULL);

	inline operator p3ga &() const {return *((p3ga*)this);}
};

class p3gai_om {
public:
	p3gai_om();
	~p3gai_om();

//	p3gai_om(const p3gai &Sp); (todo) -> initSpinor2
	p3gai_om(const p3gai vectorImages[4]);
	p3gai_om(const p3gai *vectorImages[4]);
	int initOuterMorphism(const p3gai vectorImages[4]);
	int initOuterMorphism(const p3gai *vectorImages[4]);
	int initSpinor2(const p3gai &Sp);

	double c[70];

protected:
	int computeBE(p3gai be[16], int beComputed[16], int idx);

};

// undocumented internal class
class p3gai_be {
public:
	p3gai_be(const char *name, const p3gai &mv);
	~p3gai_be();

	void initToNothing();

	int compareName(const char *name) const ; // returns true if 'm_name == name'

	char *m_name;
	p3gai m_mv;
};

class p3ga_ben {
public:
	p3ga_ben();
	p3ga_ben(char startDelimiter, char endDelimiter);
	~p3ga_ben();

	int addName(const char *name, const p3gai &mv);
	int removeName(const char *name);
	int lookupName(const char *name, p3gai &mv) const ;
	int setDelimiters(char startDelimiter, char endDelimiter);
	int removeAll();
	int setDefaults();

	char m_startDelimiter, m_endDelimiter;

protected:
	void initToNothing();

	int m_nbBen;
	p3gai_be **m_ben;

};

#ifdef CLASSNAME
#undef CLASSNAME
#endif
#define CLASSNAME p3ga

#ifdef CLASSNAME_OM
#undef CLASSNAME_OM
#endif
#define CLASSNAME_OM p3ga_om


//Merging /usr/local/include/gaigen/gaigenhl.h into generated code:

// DO NOT TRY TO INCLUDE DIRECTLY.
// IT IS MEANT TO BE INCLUDED BY GENERATED CODE!

/*
 *
 * Gaigen, Copyright (c) 2001-2004, University of Amsterdam
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *      * Redistributions of source code must retain the above copyright
 *        notice, this list of conditions and the following disclaimer.
 *      * Redistributions in binary form must reproduce the above copyright
 *        notice, this list of conditions and the following disclaimer in
 *        the documentation and/or other materials provided with the
 *        distribution.
 *      * Neither the name of the University of Amsterdam nor the names of its
 *        contributors may be used to endorse or promote products derived
 *        from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
 * CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
 * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 */

#include <stdlib.h>

#define MV_MAX_TEMP 256
#define GA_MAX_DIM 8

// temporary variable allocation determines the type of return variable (reference or copy) and...
// the type of temporary variables used inside some functions
#ifdef GAIM_FUNCTION_FASTTEMPVAR
#define GAIM_RETURN_TYPE CLASSNAME&
#define GAIM_RETURN_VAR(name) CLASSNAME &name = CLASSNAME::getTemp();
#else // slow, but safe, temporary variables
#define GAIM_RETURN_TYPE CLASSNAME
#define GAIM_RETURN_VAR(name) CLASSNAME name;
#endif // GAIM_FUNCTION_FASTTEMPVAR

//#define CLASSNAME_OM GAIM_OM_CLASSNAME

class CLASSNAME;
#ifdef GAIM_PRODUCT_OM
class CLASSNAME_OM;
#endif // GAIM_PRODUCT_OM

// if no namespace is used, set these #define to nothing
#ifndef CLASSNAME_NS
#define CLASSNAME_NS
#endif // CLASSNAME_NS
#ifndef CLASSNAME_NS_DSC
#define CLASSNAME_NS_DSC
#endif // CLASSNAME_NS_DSC

#ifndef INV_MUL_SCALAR
#define INV_MUL_SCALAR
inline GAIM_FLOAT invScalar(const GAIM_FLOAT &b) {return ((GAIM_FLOAT)1.0 / b);}
inline GAIM_FLOAT mulScalar(const GAIM_FLOAT a, const GAIM_FLOAT b) {return (a * b);}
#endif // INV_MUL_SCALAR

#ifdef GAIM_NAMESPACE
namespace CLASSNAME_NS {
#endif // GAIM_NAMESPACE


#ifdef GAIM_PRODUCT_GP
extern GAIM_RETURN_TYPE gp(const CLASSNAME &a, const CLASSNAME &b);
extern GAIM_RETURN_TYPE gp(GAIM_FLOAT a, const CLASSNAME &b);
inline GAIM_RETURN_TYPE gp(const CLASSNAME &a, GAIM_FLOAT b);
inline GAIM_RETURN_TYPE operator*(GAIM_FLOAT a, const CLASSNAME &b) ;
#endif // GAIM_PRODUCT_GP

#ifdef GAIM_PRODUCT_GP_EM
extern GAIM_RETURN_TYPE gpem (const CLASSNAME &a, const CLASSNAME &b);
extern GAIM_RETURN_TYPE gpem (GAIM_FLOAT a, const CLASSNAME &b);
inline GAIM_RETURN_TYPE gpem (const CLASSNAME &a, GAIM_FLOAT b);
#endif // GAIM_PRODUCT_GP_EM

#ifdef GAIM_PRODUCT_IGP
inline GAIM_RETURN_TYPE igp(const CLASSNAME &a, const CLASSNAME &b);
inline GAIM_RETURN_TYPE igp(const CLASSNAME &a, GAIM_FLOAT b);
inline GAIM_RETURN_TYPE igp(GAIM_FLOAT a, const CLASSNAME &b);
inline GAIM_RETURN_TYPE operator/(GAIM_FLOAT a, const CLASSNAME &b);
#endif // GAIM_PRODUCT_IGP

#ifdef GAIM_PRODUCT_OP
extern GAIM_RETURN_TYPE op(const CLASSNAME &a, const CLASSNAME &b);
extern GAIM_RETURN_TYPE op(GAIM_FLOAT a, const CLASSNAME &b);
inline GAIM_RETURN_TYPE op(const CLASSNAME &a, GAIM_FLOAT b);
inline GAIM_RETURN_TYPE operator^(GAIM_FLOAT a, const CLASSNAME &b);
#endif // GAIM_PRODUCT_OP

#ifdef GAIM_PRODUCT_LCONT
extern GAIM_RETURN_TYPE lcont(const CLASSNAME &a, const CLASSNAME &b);
#endif // GAIM_PRODUCT_LCONT

#ifdef GAIM_PRODUCT_LCONT_EM
extern GAIM_RETURN_TYPE lcem(const CLASSNAME &a, const CLASSNAME &b);
#endif // GAIM_PRODUCT_LCONT_EM

#ifdef GAIM_PRODUCT_RCONT
extern GAIM_RETURN_TYPE rcont(const CLASSNAME &a, const CLASSNAME &b);
#endif // GAIM_PRODUCT_RCONT

#ifdef GAIM_PRODUCT_SCP
extern GAIM_RETURN_TYPE scp(const CLASSNAME &a, const CLASSNAME &b);
extern GAIM_RETURN_TYPE scp(GAIM_FLOAT b, const CLASSNAME &a);
inline GAIM_RETURN_TYPE scp(const CLASSNAME &a, GAIM_FLOAT b);
inline GAIM_RETURN_TYPE operator%(GAIM_FLOAT a, const CLASSNAME &b);
#endif // GAIM_PRODUCT_SCP

#ifdef GAIM_PRODUCT_HIP
extern GAIM_RETURN_TYPE hip(const CLASSNAME &a, const CLASSNAME &b);
extern GAIM_RETURN_TYPE hip(GAIM_FLOAT b, const CLASSNAME &a);
extern GAIM_RETURN_TYPE hip(const CLASSNAME &a, GAIM_FLOAT b);
#endif // GAIM_PRODUCT_HIP

#ifdef GAIM_PRODUCT_MHIP
extern GAIM_RETURN_TYPE mhip(const CLASSNAME &a, const CLASSNAME &b);
extern GAIM_RETURN_TYPE mhip(GAIM_FLOAT b, const CLASSNAME &a);
extern GAIM_RETURN_TYPE mhip(const CLASSNAME &a, GAIM_FLOAT b);
#endif // GAIM_PRODUCT_MHIP

#ifdef GAIM_FUNCTION_MEETJOIN
extern GAIM_RETURN_TYPE meet(const CLASSNAME &a, const CLASSNAME &b);
extern GAIM_RETURN_TYPE join(const CLASSNAME &a, const CLASSNAME &b);
#endif // GAIM_FUNCTION_MEETJOIN


#ifdef GAIM_FUNCTION_ADD
extern GAIM_RETURN_TYPE add(const CLASSNAME &a, const CLASSNAME &b);
extern GAIM_RETURN_TYPE add(GAIM_FLOAT a, const CLASSNAME &b);
inline GAIM_RETURN_TYPE add(const CLASSNAME &a, GAIM_FLOAT b);
inline GAIM_RETURN_TYPE operator+(GAIM_FLOAT a, const CLASSNAME &b);
#endif // GAIM_FUNCTION_ADD

#ifdef GAIM_FUNCTION_SUBSTRACT
extern GAIM_RETURN_TYPE sub(const CLASSNAME &a, const CLASSNAME &b);
extern GAIM_RETURN_TYPE sub(GAIM_FLOAT a, const CLASSNAME &b);
inline GAIM_RETURN_TYPE sub(const CLASSNAME &a, GAIM_FLOAT b);
inline GAIM_RETURN_TYPE operator-(GAIM_FLOAT a, const CLASSNAME &b);
#endif // GAIM_FUNCTION_SUBSTRACT


#ifdef GAIM_FUNCTION_NEGATE
extern GAIM_RETURN_TYPE negate(const CLASSNAME &a);
#endif //GAIM_FUNCTION_NEGATE

// casting operator from GAIM_CLASSNAME -> CLASSNAME
//operator CLASSNAME &(GAIM_CLASSNAME &a) const {return *((CLASSNAME*)&a);}
//operator int &(GAIM_CLASSNAME &a) const {return 0;}

class CLASSNAME : public GAIM_CLASSNAME {
public:
	CLASSNAME();
//	CLASSNAME(const GAIM_CLASSNAME &a)  : GAIM_CLASSNAME (a) {};
	CLASSNAME(GAIM_FLOAT scalar) : GAIM_CLASSNAME (GRADE0, scalar) {};
	CLASSNAME(int gradeUsage, const GAIM_FLOAT *coordinates) : GAIM_CLASSNAME (gradeUsage, coordinates) {};

	// casting operator from GAIM_CLASSNAME -> CLASSNAME
	//operator GAIM_CLASSNAME () const {return scalar();}


#ifdef GAIM_CONSTRUCTOR_1_COOR
	CLASSNAME(int gradeUsage, GAIM_FLOAT c0) : GAIM_CLASSNAME (gradeUsage, c0) {};
#endif
#ifdef GAIM_CONSTRUCTOR_2_COOR
	CLASSNAME(int gradeUsage, GAIM_FLOAT c0, GAIM_FLOAT c1) : GAIM_CLASSNAME (gradeUsage, c0, c1) {};
#endif
#ifdef GAIM_CONSTRUCTOR_3_COOR
	CLASSNAME(int gradeUsage, GAIM_FLOAT c0, GAIM_FLOAT c1, GAIM_FLOAT c2) : GAIM_CLASSNAME (gradeUsage, c0, c1, c2) {};
#endif
#ifdef GAIM_CONSTRUCTOR_4_COOR
	CLASSNAME(int gradeUsage, GAIM_FLOAT c0, GAIM_FLOAT c1, GAIM_FLOAT c2, GAIM_FLOAT c3) : GAIM_CLASSNAME (gradeUsage, c0, c1, c2, c3) {};
#endif
#ifdef GAIM_CONSTRUCTOR_5_COOR
	CLASSNAME(int gradeUsage, GAIM_FLOAT c0, GAIM_FLOAT c1, GAIM_FLOAT c2, GAIM_FLOAT c3, GAIM_FLOAT c4) : GAIM_CLASSNAME (gradeUsage, c0, c1, c2, c3, c4) {};
#endif
#ifdef GAIM_CONSTRUCTOR_6_COOR
	CLASSNAME(int gradeUsage, GAIM_FLOAT c0, GAIM_FLOAT c1, GAIM_FLOAT c2, GAIM_FLOAT c3, GAIM_FLOAT c4, GAIM_FLOAT c5) : GAIM_CLASSNAME (gradeUsage, c0, c1, c2, c3, c4, c5) {};
#endif
#ifdef GAIM_CONSTRUCTOR_7_COOR
	CLASSNAME(int gradeUsage, GAIM_FLOAT c0, GAIM_FLOAT c1, GAIM_FLOAT c2, GAIM_FLOAT c3, GAIM_FLOAT c4, GAIM_FLOAT c5, GAIM_FLOAT c6) : GAIM_CLASSNAME (gradeUsage, c0, c1, c2, c3, c4, c5, c6) {};
#endif
#ifdef GAIM_CONSTRUCTOR_8_COOR
	CLASSNAME(int gradeUsage, GAIM_FLOAT c0, GAIM_FLOAT c1, GAIM_FLOAT c2, GAIM_FLOAT c3, GAIM_FLOAT c4, GAIM_FLOAT c5, GAIM_FLOAT c6, GAIM_FLOAT c7) : GAIM_CLASSNAME (gradeUsage, c0, c1, c2, c3, c4, c5, c6, c7) {};
#endif
// maybe implement it like this:
//	CLASSNAME(int gradeUsage, ...) {};

	CLASSNAME(const CLASSNAME &a) : GAIM_CLASSNAME (a) {};
	~CLASSNAME();

	GAIM_RETURN_TYPE operator=(const CLASSNAME &a);
	GAIM_RETURN_TYPE operator=(GAIM_FLOAT f);

	// take grade
#ifdef GAIM_FUNCTION_TAKEGRADE
	GAIM_RETURN_TYPE grade(int g) const;
	inline GAIM_RETURN_TYPE operator()(int g) const {return grade(g);}
#endif // GAIM_FUNCTION_TAKEGRADE

#ifdef GAIM_FUNCTION_GRADE
	inline int grade() const {return ((GAIM_CLASSNAME*)this)->grade();}
#endif // GAIM_FUNCTION_GRADE

	inline const GAIM_FLOAT *operator[](int g) const {return coordinates(g);}

#ifdef GAIM_FUNCTION_REVERSE
	GAIM_RETURN_TYPE operator~() const;
	inline GAIM_RETURN_TYPE reverse() const {return operator~();};
#endif // GAIM_FUNCTION_REVERSE

#ifdef GAIM_FUNCTION_CLIFFORDCONJUGATE
	GAIM_RETURN_TYPE operator--() const;
	inline GAIM_RETURN_TYPE operator--(int) const {return operator--();};
	inline GAIM_RETURN_TYPE cliffordConjugate() const {return operator--();};
#endif // GAIM_FUNCTION_CLIFFORDCONJUGATE

#ifdef GAIM_FUNCTION_GRADEINVOLUTION
	GAIM_RETURN_TYPE operator++() const;
	inline GAIM_RETURN_TYPE operator++(int) const {return operator++();};
	inline GAIM_RETURN_TYPE gradeInvolution() const {return operator++();};
#endif // GAIM_FUNCTION_GRADEINVOLUTION

#ifdef GAIM_FUNCTION_NORMALIZE
	GAIM_RETURN_TYPE normal(int norm = 1) const;
#endif // GAIM_FUNCTION_NORMALIZE

	// inverse
#ifdef GAIM_FUNCTION_VERSORINVERSE
	inline void inverse(const CLASSNAME &a) {versorInverse(a);};
#elif defined(GAIM_FUNCTION_LOUNESTOINVERSE)
	inline void inverse(const CLASSNAME &a) {lounestoInverse(a);};
#elif defined(GAIM_FUNCTION_GENERALINVERSE)
	inline void inverse(const CLASSNAME &a) {generalInverse(a);};
#endif

#ifdef GAIM_FUNCTION_VERSORINVERSE
	inline void versorInverse(const CLASSNAME &a) {GAIM_CLASSNAME::versorInverse(a);};
	GAIM_RETURN_TYPE versorInverse() const;
#endif
#ifdef GAIM_FUNCTION_LOUNESTOINVERSE
	inline void lounestoInverse(const CLASSNAME &a) {GAIM_CLASSNAME::lounestoInverse(a);};
	GAIM_RETURN_TYPE lounestoInverse() const;
#endif
#ifdef GAIM_FUNCTION_GENERALINVERSE
	inline void generalInverse(const CLASSNAME &a) {GAIM_CLASSNAME::generalInverse(a);};
	GAIM_RETURN_TYPE generalInverse() const;
#endif

	// geometric product
#ifdef GAIM_PRODUCT_GP
	GAIM_RETURN_TYPE exp(int order = 9) const ;

	GAIM_RETURN_TYPE operator*=(const CLASSNAME &a);
	GAIM_RETURN_TYPE operator*=(GAIM_FLOAT a);
	inline GAIM_RETURN_TYPE operator*(const CLASSNAME &a) const {return CLASSNAME_NS ::gp(*this, a);}
	inline GAIM_RETURN_TYPE operator*(GAIM_FLOAT a) const {return CLASSNAME_NS ::gp(*this, a);}
#ifndef GAIM_FUNCTION_FASTDUAL
	GAIM_RETURN_TYPE dual() const;
#endif // GAIM_FUNCTION_FASTDUAL
#endif // GAIM_PRODUCT_GP

#ifdef GAIM_FUNCTION_FASTDUAL
	GAIM_RETURN_TYPE fastDual() const;
	inline GAIM_RETURN_TYPE dual() const {return fastDual();};
#endif // GAIM_FUNCTION_FASTDUAL

	// inverse geometric product
#ifdef GAIM_PRODUCT_IGP
	GAIM_RETURN_TYPE inverse() const;
	inline GAIM_RETURN_TYPE operator!() const {return inverse();}

	inline GAIM_RETURN_TYPE operator/(const CLASSNAME &a) const {return CLASSNAME_NS ::igp(*this, a);}
	inline GAIM_RETURN_TYPE operator/(GAIM_FLOAT a) const {return CLASSNAME_NS ::igp(*this, a);}
	GAIM_RETURN_TYPE operator/=(const CLASSNAME &a);
	GAIM_RETURN_TYPE operator/=(GAIM_FLOAT a);
#endif // GAIM_PRODUCT_IGP

	// scalar product
#ifdef GAIM_PRODUCT_SCP
	inline GAIM_RETURN_TYPE operator%(const CLASSNAME &a) const {return CLASSNAME_NS ::scp(*this, a);};
	inline GAIM_RETURN_TYPE operator%(GAIM_FLOAT a) const {return CLASSNAME_NS ::scp(a, *this);};
	GAIM_RETURN_TYPE operator%=(const CLASSNAME &a);
	GAIM_RETURN_TYPE operator%=(GAIM_FLOAT a);
#endif // GAIM_PRODUCT_SCP

	// left contraction
#ifdef GAIM_PRODUCT_LCONT
	inline GAIM_RETURN_TYPE operator<<(const CLASSNAME &a) const {return CLASSNAME_NS ::lcont(*this, a);}
	GAIM_RETURN_TYPE operator<<=(const CLASSNAME &a);
#endif // GAIM_PRODUCT_LCONT

	// right contraction
#ifdef GAIM_PRODUCT_RCONT
	inline GAIM_RETURN_TYPE operator>>(const CLASSNAME &a) const {return CLASSNAME_NS ::rcont(*this, a);}
	GAIM_RETURN_TYPE operator>>=(const CLASSNAME &a);
#endif // GAIM_PRODUCT_RCONT

	// outer product
#ifdef GAIM_PRODUCT_OP
	inline GAIM_RETURN_TYPE operator^(const CLASSNAME &a) const {return CLASSNAME_NS ::op(*this, a);}
	inline GAIM_RETURN_TYPE operator^(GAIM_FLOAT a) const {return CLASSNAME_NS ::op(a, *this);}
	GAIM_RETURN_TYPE operator^=(const CLASSNAME &a);
	GAIM_RETURN_TYPE operator^=(GAIM_FLOAT a);
#endif // GAIM_PRODUCT_OP

#ifdef GAIM_FUNCTION_MEETJOIN
	inline GAIM_RETURN_TYPE operator&(const CLASSNAME &a) const {return CLASSNAME_NS ::meet(*this, a);}
	inline GAIM_RETURN_TYPE operator|(const CLASSNAME &a) const {return CLASSNAME_NS ::join(*this, a);}
#endif // GAIM_FUNCTION_MEETJOIN

#ifdef GAIM_FUNCTION_ADD
	inline GAIM_RETURN_TYPE operator+(const CLASSNAME &a) const {return CLASSNAME_NS ::add(*this, a);}
	inline GAIM_RETURN_TYPE operator+(GAIM_FLOAT a) const {return CLASSNAME_NS ::add(a, *this);}
	GAIM_RETURN_TYPE operator+=(const CLASSNAME &a);
	GAIM_RETURN_TYPE operator+=(GAIM_FLOAT a);
#endif // GAIM_FUNCTION_ADD

#ifdef GAIM_FUNCTION_SUBSTRACT
	inline GAIM_RETURN_TYPE operator-(const CLASSNAME &a) const {return CLASSNAME_NS ::sub(*this, a);}
	inline GAIM_RETURN_TYPE operator-(GAIM_FLOAT a) const {return CLASSNAME_NS ::add(-a, *this);}
	GAIM_RETURN_TYPE operator-=(const CLASSNAME &a);
	GAIM_RETURN_TYPE operator-=(GAIM_FLOAT a);
#endif // GAIM_FUNCTION_SUBSTRACT

#ifdef GAIM_FUNCTION_NEGATE
	inline GAIM_RETURN_TYPE operator-() const {return CLASSNAME_NS ::negate(*this);}
	inline GAIM_RETURN_TYPE negate() const {return CLASSNAME_NS ::negate(*this);}
#endif //GAIM_FUNCTION_NEGATE


#ifdef GAIM_FUNCTION_FACTOR
	inline int factor(CLASSNAME f[], int versor = 0) const {return GAIM_CLASSNAME::factor((GAIM_CLASSNAME*)f, versor);};
	inline int factorVersor(CLASSNAME f[]) const {return CLASSNAME::factor(f, 1);};
#endif //GAIM_FUNCTION_FACTOR


#ifdef GAIM_FUNCTION_FASTTEMPVAR
	static CLASSNAME &getTemp();	// returns a temporary variable; don't use expressions which require more than MV_MAX_TEMP temporaries
#endif // GAIM_FUNCTION_FASTTEMPVAR

#ifdef GAIM_DRAWING
	/* ********************** drawing ************************/
/* ****************** under construction ************************/

	/*
	sets the color of objects
	*/
	static int setColor(int grade, int idx, float r, float g, float b, float a = 1.0f);
	static int setColor(int grade, int idx, float *rgba);
	static int setColor(int grade, int idx, const char *name, float alpha = 1.0f);

	/*
	Sets the frame used for drawing OpenGL images.
	Specifies to what vectors the x, y and z axis in OpenGL correspond.
	Returns 0 on success, -1 on failure (i.e. when x^y^z is too small)
	*/
	static unsigned int m_Draw3DMode;
	static int setDraw3DMode(unsigned int mode);
	static int setDraw3DFrame(CLASSNAME &x, CLASSNAME &y, CLASSNAME &z);
	void draw3DProject(float *p);
	void draw3DBlade();

protected:
	static CLASSNAME m_Draw3DFrame[3], m_Draw3DTriVector, m_Draw3DTriVectorInverse;
	void draw3DVector();
	void draw3DBiVector();
	void draw3DTriVector();
	void drawBandedDisc(int halfSphere = 0, int colorSkip = 0, int ori = 1);
	static int m_drawLightOn;
	static void drawEnableLighting();
	static void drawDisableLighting();
	static int m_drawCullFaceOn;
	static void drawEnableCullFace();
	static void drawDisableCullFace();

	static float m_color[4][2][4];
	void setColor(int grade, int idx); 	// automatically sets material properties as well



public:
/* ****************** under construction ************************/
	/* ********************** drawing ************************/
#endif //GAIM_DRAWING


	// implicit 'cast to GAIM_FLOATing point' operator
//	operator GAIM_FLOAT () const {return scalar();}

};

#ifdef GAIM_PRODUCT_GP
inline GAIM_RETURN_TYPE gp(const CLASSNAME &a, GAIM_FLOAT b) {return gp(b, a);}
inline GAIM_RETURN_TYPE operator*(GAIM_FLOAT a, const CLASSNAME &b) {return gp(a, b);}
inline GAIM_RETURN_TYPE gp(const GAIM_CLASSNAME &a, GAIM_FLOAT b) {return gp((const CLASSNAME&)a, b);}
inline GAIM_RETURN_TYPE gp(const GAIM_CLASSNAME &a, const CLASSNAME &b) {return gp((const CLASSNAME&)a, b);}
inline GAIM_RETURN_TYPE operator*(const GAIM_CLASSNAME &a, GAIM_FLOAT b) {return gp((const CLASSNAME&)a, b);}
inline GAIM_RETURN_TYPE operator*(const GAIM_CLASSNAME &a, const CLASSNAME &b) {return gp((const CLASSNAME&)a, b);}
#endif // GAIM_PRODUCT_GP

#ifdef GAIM_PRODUCT_GP_EM
inline GAIM_RETURN_TYPE gpem (const CLASSNAME &a, GAIM_FLOAT b) {return GAIM_PRODUCT_GP_EM (b, a);}
inline GAIM_RETURN_TYPE gpem (const GAIM_CLASSNAME &a, GAIM_FLOAT b) {return GAIM_PRODUCT_GP_EM ((const CLASSNAME&)a, b);}
inline GAIM_RETURN_TYPE gpem (const GAIM_CLASSNAME &a, const CLASSNAME &b) {return GAIM_PRODUCT_GP_EM ((const CLASSNAME&)a, b);}
#endif // GAIM_PRODUCT_GP_EM

#ifdef GAIM_PRODUCT_OP
inline GAIM_RETURN_TYPE op(const CLASSNAME &a, GAIM_FLOAT b) {return op(b, a);}
inline GAIM_RETURN_TYPE operator^(GAIM_FLOAT a, const CLASSNAME &b) {return op(a, b);}
inline GAIM_RETURN_TYPE op(const GAIM_CLASSNAME &a, GAIM_FLOAT b) {return op((const CLASSNAME&)a, b);}
inline GAIM_RETURN_TYPE op(const GAIM_CLASSNAME &a, const CLASSNAME &b) {return op((const CLASSNAME&)a, b);}
inline GAIM_RETURN_TYPE operator^(const GAIM_CLASSNAME &a, GAIM_FLOAT b) {return op((const CLASSNAME&)a, b);}
inline GAIM_RETURN_TYPE operator^(const GAIM_CLASSNAME &a, const CLASSNAME &b) {return op((const CLASSNAME&)a, b);}
#endif // GAIM_PRODUCT_OP

#ifdef GAIM_PRODUCT_LCONT
inline GAIM_RETURN_TYPE lcont(const GAIM_CLASSNAME &a, const CLASSNAME &b) {return lcont((const CLASSNAME&)a, b);}
inline GAIM_RETURN_TYPE operator<<(const GAIM_CLASSNAME &a, const CLASSNAME &b) {return lcont((const CLASSNAME&)a, b);}
#endif // GAIM_PRODUCT_LCONT

#ifdef GAIM_PRODUCT_LCONT_EM
inline GAIM_RETURN_TYPE lcem(const GAIM_CLASSNAME &a, const CLASSNAME &b) {return lcem((const CLASSNAME&)a, b);}
#endif // GAIM_PRODUCT_LCONT_EM

#ifdef GAIM_PRODUCT_RCONT
inline GAIM_RETURN_TYPE rcont(const GAIM_CLASSNAME &a, const CLASSNAME &b) {return rcont((const CLASSNAME&)a, b);}
inline GAIM_RETURN_TYPE operator>>(const GAIM_CLASSNAME &a, const CLASSNAME &b) {return rcont((const CLASSNAME&)a, b);}
#endif // GAIM_PRODUCT_RCONT

#ifdef GAIM_PRODUCT_SCP
inline GAIM_RETURN_TYPE scp(const CLASSNAME &a, GAIM_FLOAT b)  {return scp(b, a);}
inline GAIM_RETURN_TYPE operator%(GAIM_FLOAT a, const CLASSNAME &b) {return scp(b, a);}
inline GAIM_RETURN_TYPE scp(const GAIM_CLASSNAME &a, GAIM_FLOAT b)  {return scp(b, (const CLASSNAME&)a);}
inline GAIM_RETURN_TYPE scp(const GAIM_CLASSNAME &a, const CLASSNAME &b)  {return scp((const CLASSNAME&)a, b);}
inline GAIM_RETURN_TYPE  operator%(const GAIM_CLASSNAME &a, GAIM_FLOAT b)  {return scp(b, (const CLASSNAME&)a);}
inline GAIM_RETURN_TYPE  operator%(const GAIM_CLASSNAME &a, const CLASSNAME &b)  {return scp((const CLASSNAME&)a, b);}
#endif // GAIM_PRODUCT_SCP

#ifdef GAIM_PRODUCT_HIP
inline GAIM_RETURN_TYPE hip(const GAIM_CLASSNAME &a, const CLASSNAME &b) {return hip((const CLASSNAME&)a, b);}
inline GAIM_RETURN_TYPE hip(const GAIM_CLASSNAME &a, GAIM_FLOAT b) {return hip((const CLASSNAME&)a, b);}
#endif // GAIM_PRODUCT_HIP

#ifdef GAIM_PRODUCT_MHIP
inline GAIM_RETURN_TYPE mhip(const GAIM_CLASSNAME &a, const CLASSNAME &b) {return mhip((const CLASSNAME&)a, b);}
inline GAIM_RETURN_TYPE mhip(const GAIM_CLASSNAME &a, GAIM_FLOAT b) {return mhip((const CLASSNAME&)a, b);}
#endif // GAIM_PRODUCT_MHIP

#ifdef GAIM_FUNCTION_MEETJOIN
inline GAIM_RETURN_TYPE meet(const GAIM_CLASSNAME &a, const CLASSNAME &b) {return meet((const CLASSNAME&)a, b);}
inline GAIM_RETURN_TYPE join(const GAIM_CLASSNAME &a, const CLASSNAME &b) {return join((const CLASSNAME&)a, b);}
//inline GAIM_RETURN_TYPE operator&(const GAIM_CLASSNAME &a, const CLASSNAME &b) const {return meet((const CLASSNAME&)a, b);}
//inline GAIM_RETURN_TYPE operator|(const GAIM_CLASSNAME &a, const CLASSNAME &b) const {return join((const CLASSNAME&)a, b);}
#endif // GAIM_FUNCTION_MEETJOIN

#ifdef GAIM_FUNCTION_ADD
inline GAIM_RETURN_TYPE add(const CLASSNAME &a, GAIM_FLOAT b) {return add(b, a);}
inline GAIM_RETURN_TYPE operator+(GAIM_FLOAT a, const CLASSNAME &b) {return add(a, b);}
inline GAIM_RETURN_TYPE add(const GAIM_CLASSNAME &a, GAIM_FLOAT b) {return add(b, (const CLASSNAME&)a);}
inline GAIM_RETURN_TYPE operator+(GAIM_FLOAT a, const GAIM_CLASSNAME &b) {return add(a, (const CLASSNAME&)b);}
inline GAIM_RETURN_TYPE operator+(const GAIM_CLASSNAME &a, const CLASSNAME &b) {return add((const CLASSNAME&)a, b);}
#endif // GAIM_FUNCTION_ADD

#ifdef GAIM_FUNCTION_SUBSTRACT
inline GAIM_RETURN_TYPE sub(const CLASSNAME &a, GAIM_FLOAT b) {return add(-b, a);}
inline GAIM_RETURN_TYPE operator-(GAIM_FLOAT a, const CLASSNAME &b) {return sub(a, b);}
inline GAIM_RETURN_TYPE sub(const GAIM_CLASSNAME &a, GAIM_FLOAT b) {return add(-b, (const CLASSNAME&)a);}
inline GAIM_RETURN_TYPE operator-(GAIM_FLOAT a, const GAIM_CLASSNAME &b) {return sub(a, (const CLASSNAME&)b);}
inline GAIM_RETURN_TYPE operator-(const GAIM_CLASSNAME &a, const CLASSNAME &b) {return sub((const CLASSNAME&)a, b);}
#endif // GAIM_FUNCTION_SUBSTRACT


#ifdef GAIM_FUNCTION_NEGATE
GAIM_RETURN_TYPE negate(const CLASSNAME &a);
inline GAIM_RETURN_TYPE negate(const GAIM_CLASSNAME &a) {return negate((const CLASSNAME&)a);}
#endif //GAIM_FUNCTION_NEGATE

#ifdef GAIM_PRODUCT_IGP
inline GAIM_RETURN_TYPE igp(const CLASSNAME &a, const CLASSNAME &b) {return gp(a, b.inverse());}
inline GAIM_RETURN_TYPE igp(const CLASSNAME &a, GAIM_FLOAT b) {return op(invScalar(b), a);}
inline GAIM_RETURN_TYPE igp(GAIM_FLOAT a, const CLASSNAME &b) {return op(a, b.inverse());}
inline GAIM_RETURN_TYPE operator/(GAIM_FLOAT a, const CLASSNAME &b) {return igp(a, b);}
inline GAIM_RETURN_TYPE igp(const GAIM_CLASSNAME &a, const CLASSNAME &b) {return gp((const CLASSNAME&)a, b.inverse());}
inline GAIM_RETURN_TYPE igp(const GAIM_CLASSNAME &a, GAIM_FLOAT b) {return op(invScalar(b), (const CLASSNAME&)a);}
#endif // GAIM_PRODUCT_IGP

#ifdef GAIM_PRODUCT_OM
class CLASSNAME_OM : public GAIM_OM_CLASSNAME {
public:
	CLASSNAME_OM() : GAIM_OM_CLASSNAME() {};
	~CLASSNAME_OM() {};

	CLASSNAME_OM(const CLASSNAME vectorImages[3]) : GAIM_OM_CLASSNAME(vectorImages) {};
	CLASSNAME_OM(const CLASSNAME *vectorImages[3]);
	CLASSNAME_OM(const CLASSNAME &spinor);

	// init using a spinor to create the vector images
	int initSpinor(const CLASSNAME &spinor);

	// init using images under the outermorphism of the basis vectors
	inline int initVectorImages(const CLASSNAME vectorImages[3]) {
		return GAIM_OM_CLASSNAME::initOuterMorphism(vectorImages);
	}
	inline int initVectorImages(const CLASSNAME *vectorImages[3]) {
		return GAIM_OM_CLASSNAME::initOuterMorphism((const GAIM_CLASSNAME**)vectorImages);
	}
};

GAIM_RETURN_TYPE om(const CLASSNAME_OM &L, const CLASSNAME &A);
inline GAIM_RETURN_TYPE operator*(const CLASSNAME_OM &L, const CLASSNAME &A) {return om(L, A);}

#ifdef GAIM_NAMESPACE
}
#endif // GAIM_NAMESPACE

#endif // GAIM_PRODUCT_OM
#endif /* _p3gai_H_*/
