
/*
Gaigen 1.0, Copyright (c) 2001-2010, University of Amsterdam

Copying, use and development for education and research purposes 
permitted as long as this license is not removed from the files.

All rights for commercial use reserved; for more information
contact Daniel Fontijne (fontijne@science.uva.nl)

This software is unsupported.
*/
/*
Source file c3ga.cpp, generated by Gaigen 1.0 on Mon Mar 22 19:10:50 2010
*/




#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <math.h>
#include "c3ga.h"
#ifdef WIN32
#pragma warning( disable : 4996)
#endif

int c3gai_expansionTable_gp[] = {
133, 140, 141, 142, 148, 149, 150, 155, 164, 169, 170, 171, 177, 178, 179, 186, 293, 300, 301, 302, 308, 309, 310, 315, 325, 332, 333, 334, 340, 341, 342, 347, 357, 364, 365, 366, 372, 373, 374, 379, 388, 393, 394, 395, 401, 402, 403, 410, 420, 425, 426, 427, 433, 434, 435, 442, 452, 457, 458, 459, 465, 466, 467, 474, 549, 556, 557, 558, 564, 565, 566, 571, 581, 588, 589, 590, 596, 597, 598, 603, 613, 620, 621, 622, 628, 629, 630, 635, 644, 649, 650, 651, 657, 658, 659, 666, 676, 681, 682, 683, 689, 690, 691, 698, 708, 713, 714, 715, 721, 722, 723, 730, 837, 844, 845, 846, 852, 853, 854, 859, 868, 873, 874, 875, 881, 882, 883, 890, -1,
0, 33, 66, 99, 132, 165, 198, 231, 264, 297, 330, 363, 396, 429, 462, 495, 528, 561, 594, 627, 660, 693, 726, 759, 792, 825, 858, 891, 924, 957, 990, 1023, -1,
1, 32, 70, 103, 137, 172, 194, 227, 272, 292, 337, 370, 389, 436, 469, 503, 520, 554, 587, 634, 653, 686, 731, 751, 796, 829, 851, 886, 920, 953, 991, 1022, -1,
2, 1062, 64, 104, 138, 173, 1217, 1264, 259, 1329, 324, 371, 1428, 421, 470, 504, 1543, 1577, 1626, 619, 1676, 1723, 718, 1788, 783, 830, 1874, 1909, 1943, 1983, 985, 2045, -1,
3, 1063, 1096, 96, 139, 174, 208, 1249, 1282, 1330, 1363, 356, 1429, 1462, 453, 505, 518, 570, 1609, 1642, 667, 1708, 1741, 1789, 1822, 815, 849, 884, 927, 1975, 2008, 1020, -1,
1029, 44, 77, 110, 128, 143, 1236, 1269, 1302, 1313, 1335, 1346, 1368, 1379, 1401, 485, 539, 550, 572, 583, 605, 616, 638, 1772, 1805, 1838, 1872, 1887, 916, 949, 982, 2043, -1,
1028, 41, 74, 107, 160, 1199, 1233, 1266, 1299, 1409, 407, 1442, 440, 1475, 473, 1508, 538, 646, 1692, 679, 1725, 712, 1758, 745, 778, 811, 1904, 895, 1937, 1970, 2003, 1018, -1,
1030, 34, 1089, 1136, 1169, 1204, 192, 232, 1287, 298, 1353, 1402, 397, 1452, 1499, 1532, 515, 548, 595, 1650, 645, 694, 1749, 760, 1815, 1855, 843, 878, 911, 958, 2013, 1017, -1,
1031, 35, 80, 1121, 1170, 1205, 1224, 224, 262, 299, 346, 1385, 398, 443, 1484, 1533, 1538, 1587, 580, 625, 1686, 677, 724, 761, 799, 1847, 1866, 1901, 1950, 943, 988, 2040, -1,
1032, 1072, 67, 1122, 1171, 1206, 199, 1254, 256, 1338, 331, 1386, 1435, 430, 1485, 1534, 513, 562, 1617, 612, 661, 1716, 709, 1791, 793, 1848, 841, 876, 925, 1980, 975, 1015, -1,
12, 1061, 1108, 1141, 1153, 1175, 205, 238, 283, 288, 303, 326, 348, 359, 381, 1516, 1558, 1570, 1592, 1603, 1625, 1648, 1663, 741, 788, 821, 840, 862, 1933, 1966, 2011, 1014, -1,
13, 52, 1093, 1142, 1154, 1176, 1228, 1275, 270, 1318, 1340, 320, 335, 360, 382, 1517, 533, 545, 567, 592, 607, 1635, 1657, 1780, 773, 822, 1863, 1885, 908, 955, 1998, 2037, -1,
14, 53, 86, 1125, 1155, 1177, 219, 1260, 1293, 1319, 1341, 1352, 1374, 352, 367, 1518, 1556, 1584, 1599, 577, 599, 610, 632, 1781, 1814, 805, 838, 860, 1947, 940, 973, 1012, -1,
9, 1060, 1105, 1138, 1185, 183, 202, 235, 282, 384, 1423, 422, 1468, 455, 1501, 489, 1555, 1666, 664, 1699, 697, 1744, 735, 1764, 1809, 1842, 872, 1918, 906, 939, 986, 2035, -1,
10, 49, 1092, 1139, 1186, 184, 1225, 1274, 267, 1414, 412, 416, 1455, 456, 1502, 490, 530, 641, 1687, 688, 1727, 1731, 729, 753, 1796, 1843, 1895, 893, 1929, 1978, 971, 1010, -1,
11, 50, 83, 1124, 1187, 185, 218, 1257, 1290, 1415, 413, 1448, 446, 448, 1487, 491, 1553, 1680, 671, 673, 1719, 706, 1752, 754, 787, 1828, 870, 1916, 922, 1961, 1994, 2033, -1,
15, 55, 88, 121, 3204, 2213, 220, 253, 286, 3369, 3402, 3435, 2444, 2477, 2510, 480, 543, 3633, 3666, 3699, 2708, 2741, 2774, 737, 770, 803, 3930, 2939, 902, 935, 968, 1008, -1,
1040, 1064, 71, 1126, 1178, 1211, 195, 1250, 257, 1331, 338, 1393, 1430, 437, 1492, 1535, 512, 555, 1610, 617, 654, 1709, 716, 1790, 797, 1852, 836, 869, 921, 1976, 983, 1007, -1,
20, 45, 1100, 1147, 1158, 1180, 1221, 1270, 277, 1314, 1336, 321, 343, 368, 383, 1524, 526, 544, 559, 584, 606, 1639, 1661, 1773, 780, 827, 1859, 1881, 901, 950, 2005, 2030, -1,
21, 46, 91, 1132, 1159, 1181, 214, 1253, 1300, 1315, 1337, 1360, 1375, 353, 375, 1525, 1549, 1576, 1598, 576, 591, 614, 636, 1774, 1819, 812, 834, 856, 1942, 933, 980, 1005, -1,
22, 1083, 78, 1133, 1160, 1182, 1237, 244, 1285, 304, 319, 1347, 1369, 354, 376, 1526, 524, 551, 573, 1606, 1628, 608, 623, 763, 1806, 813, 1857, 1879, 917, 1972, 965, 2028, -1,
17, 42, 1097, 1146, 1190, 188, 1220, 1267, 274, 1410, 408, 417, 1463, 464, 1503, 497, 523, 640, 1679, 680, 1726, 1735, 733, 746, 1801, 1850, 1891, 889, 1924, 1971, 978, 1003, -1,
18, 43, 90, 1129, 1191, 189, 211, 1252, 1297, 1411, 409, 1456, 447, 449, 1495, 498, 1546, 1672, 670, 672, 1711, 710, 1756, 747, 794, 1833, 866, 1912, 915, 1956, 2001, 2026, -1,
19, 1082, 75, 1130, 1192, 190, 1234, 241, 1284, 400, 1439, 1443, 441, 450, 1496, 499, 521, 647, 1693, 1702, 700, 704, 1743, 1786, 779, 1834, 1889, 887, 1938, 945, 1988, 1001, -1,
23, 47, 92, 125, 3209, 2220, 216, 249, 287, 3364, 3409, 3442, 2437, 2484, 2517, 481, 542, 3626, 3659, 3706, 2701, 2734, 2779, 736, 774, 807, 3923, 2934, 898, 931, 976, 1000, -1,
24, 1084, 79, 126, 3210, 2221, 1239, 1279, 281, 2353, 3396, 3443, 3476, 2469, 2518, 482, 1565, 2601, 2650, 3691, 3724, 3771, 2766, 1766, 768, 808, 2898, 3957, 1921, 1968, 963, 2023, -1,
25, 1085, 1118, 111, 3211, 2222, 223, 1271, 1304, 2354, 2387, 3428, 3477, 3510, 2501, 483, 540, 3642, 2633, 2666, 2715, 3756, 3789, 1767, 1800, 800, 3921, 2932, 912, 1953, 1986, 998, -1,
1051, 54, 1109, 116, 144, 159, 206, 1261, 268, 1320, 1342, 327, 349, 1382, 1404, 507, 1541, 1571, 1593, 578, 600, 1633, 1655, 1782, 789, 1844, 832, 847, 1934, 941, 1996, 997, -1,
1050, 51, 1106, 113, 176, 1215, 203, 1258, 265, 1416, 414, 423, 1469, 1478, 476, 1530, 1540, 1667, 665, 674, 1720, 1729, 727, 755, 1810, 817, 864, 1903, 907, 1962, 969, 2020, -1,
1052, 56, 1111, 1151, 2193, 3252, 207, 254, 1309, 3370, 2377, 2426, 2445, 3500, 3547, 1510, 537, 3620, 3667, 2674, 2693, 2742, 3797, 738, 1793, 1840, 3915, 2926, 896, 936, 1991, 995, -1,
1053, 57, 95, 1143, 2194, 3253, 1246, 239, 284, 3371, 3418, 2409, 2446, 2491, 3532, 1511, 1560, 2611, 3652, 3697, 3734, 2725, 2772, 739, 784, 1825, 2890, 3949, 1928, 928, 966, 2018, -1,
1054, 1087, 89, 1144, 2195, 3254, 221, 1276, 271, 2362, 3403, 2410, 3483, 2478, 3533, 1512, 535, 3634, 2641, 3684, 2709, 3764, 2757, 1776, 771, 1826, 3913, 2924, 903, 1958, 960, 993, -1,
1055, 1086, 93, 1148, 2202, 3259, 217, 1272, 279, 2355, 3410, 2417, 3478, 2485, 3540, 1520, 527, 3627, 2634, 3689, 2702, 3757, 2764, 1768, 775, 1830, 3908, 2917, 899, 1954, 961, 992, -1
};

const char *c3gai_typeNames[4] = {
	"undefined",
	"blade",
	"versor",
	"multivector"
};
// layer 0 functions are always pure C, unless custom float class if used
extern "C" {

char *c3gai_basisElementNames[32] = {
(char*)"1",
(char*)"e1",
(char*)"e2",
(char*)"e3",
(char*)"no",
(char*)"ni",
(char*)"e1^e2",
(char*)"e1^e3",
(char*)"e2^e3",
(char*)"e1^no",
(char*)"e2^no",
(char*)"e3^no",
(char*)"e1^ni",
(char*)"e2^ni",
(char*)"e3^ni",
(char*)"no^ni",
(char*)"e1^e2^e3",
(char*)"e1^e2^no",
(char*)"e1^e3^no",
(char*)"e2^e3^no",
(char*)"e1^e2^ni",
(char*)"e1^e3^ni",
(char*)"e2^e3^ni",
(char*)"e1^no^ni",
(char*)"e2^no^ni",
(char*)"e3^no^ni",
(char*)"e1^e2^e3^no",
(char*)"e1^e2^e3^ni",
(char*)"e1^e2^no^ni",
(char*)"e1^e3^no^ni",
(char*)"e2^e3^no^ni",
(char*)"e1^e2^e3^no^ni"
};

bool c3gai_basisElementNamesAllocated[32] = {
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false,
	false
};

int c3gai_gradeSize[6] = {1, 5, 10, 10, 5, 1};
int c3gai_mvSize[64] = {0, 1, 5, 6, 10, 11, 15, 16, 10, 11, 15, 16, 20, 21, 25, 26, 5, 6, 10, 11, 15, 16, 20, 21, 15, 16, 20, 21, 25, 26, 30, 31, 1, 2, 6, 7, 11, 12, 16, 17, 11, 12, 16, 17, 21, 22, 26, 27, 6, 7, 11, 12, 16, 17, 21, 22, 16, 17, 21, 22, 26, 27, 31, 32};

const int c3gai_bevt0[1] = {-1};
const int c3gai_bevt1[5] = {0, 1, 2, 3, 4};
const int c3gai_bevt2[10] = {0, 0, 1, 0, 1, 2, 0, 1, 2, 3};
const int c3gai_bevt3[10] = {0, 0, 0, 1, 0, 0, 1, 0, 1, 2};
const int c3gai_bevt4[5] = {0, 0, 0, 0, 1};
const int c3gai_bevt5[1] = {0};
const int *c3gai_bevt[6] = { // bevt = basis element vector table
	c3gai_bevt0,
	c3gai_bevt1,
	c3gai_bevt2,
	c3gai_bevt3,
	c3gai_bevt4,
	c3gai_bevt5
};
const int c3gai_newBevt[32] = { // bevt = basis element vector table
	0, 1, 2, 4, 8, 16, 3, 5, 6, 9, 10, 12, 17, 18, 20, 24, 7, 11, 13, 14, 19, 21, 22, 25, 26, 28, 15, 23, 27, 29, 30, 31
};

const int c3gai_omct[96] = { // omct = Outer Morphism Construction Table
	-1, -1, 0,
	1, -1, 1,
	2, -1, 1,
	3, -1, 1,
	4, -1, 1,
	5, -1, 1,
	1, 2, 1,
	1, 3, 1,
	2, 3, 1,
	1, 4, 1,
	2, 4, 1,
	3, 4, 1,
	1, 5, 1,
	2, 5, 1,
	3, 5, 1,
	4, 5, 1,
	6, 3, 1,
	6, 4, 1,
	7, 4, 1,
	8, 4, 1,
	6, 5, 1,
	7, 5, 1,
	8, 5, 1,
	9, 5, 1,
	10, 5, 1,
	11, 5, 1,
	16, 4, 1,
	16, 5, 1,
	17, 5, 1,
	18, 5, 1,
	19, 5, 1,
	26, 5, 1
};
// end of the layer 0 functions
} /* end of 'extern "C"' */



c3gai c3gai::e1(GRADE1, 1.0, 0.0, 0.0, 0.0, 0.0);
c3gai c3gai::e2(GRADE1, 0.0, 1.0, 0.0, 0.0, 0.0);
c3gai c3gai::e3(GRADE1, 0.0, 0.0, 1.0, 0.0, 0.0);
c3gai c3gai::no(GRADE1, 0.0, 0.0, 0.0, 1.0, 0.0);
c3gai c3gai::ni(GRADE1, 0.0, 0.0, 0.0, 0.0, 1.0);
c3gai *c3gai::bv[5] = {&c3gai::e1, &c3gai::e2, &c3gai::e3, &c3gai::no, &c3gai::ni};
c3gai c3gai::I(GRADE5, 1.0);
c3gai c3gai::Ii(GRADE5, -1.0);

const int c3gai::dim = 5;
const int c3gai::nbCoor = 32;

c3gai::c3gai() {
	usage = 0;
	c = NULL;
}

c3gai::c3gai(const c3gai &a) {
	usage = 0;
	copy(a);
}

c3gai::c3gai(int gradeUsage, const double *coordinates) {
	usage = 0;
	set(gradeUsage, coordinates);
}

c3gai::~c3gai() {
	setUsage(0);
}

c3gai::c3gai(int grade, double c0) {
	usage = 0;
	set(grade, c0);
}

c3gai::c3gai(int grade, double c0, double c1, double c2, double c3, double c4) {
	usage = 0;
	set(grade, c0, c1, c2, c3, c4);
}

c3gai::c3gai(int grade, double c0, double c1, double c2, double c3, double c4, double c5, double c6, double c7, double c8, double c9) {
	usage = 0;
	set(grade, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9);
}

void c3gai::null() {
	setUsage(0);
}

void c3gai::set(int gradeUsage, const double *coordinates) {
	setUsage((c3gai_mvSize[gradeUsage] << 6) | gradeUsage);
	c3gai_copy(c, coordinates, c3gai_mvSize[gradeUsage]);
}

void c3gai::setScalar(const double coordinates[1]) {
	setUsage(65);
	c3gai_copy(c, coordinates, 1);
}

void c3gai::setVector(const double coordinates[5]) {
	setUsage(322);
	c3gai_copy(c, coordinates, 5);
}

void c3gai::set2Vector(const double coordinates[10]) {
	setUsage(644);
	c3gai_copy(c, coordinates, 10);
}

void c3gai::set3Vector(const double coordinates[10]) {
	setUsage(648);
	c3gai_copy(c, coordinates, 10);
}

void c3gai::set4Vector(const double coordinates[5]) {
	setUsage(336);
	c3gai_copy(c, coordinates, 5);
}

void c3gai::set5Vector(const double coordinates[1]) {
	setUsage(96);
	c3gai_copy(c, coordinates, 1);
}

int c3gai::set(int grade, double c0) {
	setUsage(grade | (c3gai_mvSize[grade] << 6));
	c[0] = c0;
	return 0;
}

int c3gai::set(int grade, double c0, double c1, double c2, double c3, double c4) {
	setUsage(grade | (c3gai_mvSize[grade] << 6));
	c[0] = c0;
	c[1] = c1;
	c[2] = c2;
	c[3] = c3;
	c[4] = c4;
	return 0;
}

int c3gai::set(int grade, double c0, double c1, double c2, double c3, double c4, double c5, double c6, double c7, double c8, double c9) {
	setUsage(grade | (c3gai_mvSize[grade] << 6));
	c[0] = c0;
	c[1] = c1;
	c[2] = c2;
	c[3] = c3;
	c[4] = c4;
	c[5] = c5;
	c[6] = c6;
	c[7] = c7;
	c[8] = c8;
	c[9] = c9;
	return 0;
}

const char *c3gai::fpPrecision = "%2.2f";
const char *c3gai::stringStartDelimiter = "";
const char *c3gai::stringEndDelimiter = "";

int c3gai::setFPPrecision(const char *prec) {
	if (prec == NULL) return -1;
	fpPrecision = prec;
	return 0;
}

int c3gai::setStringDelimiters(char start, char end) {
	if ((start < 0) || (end < 0)) return -1;
	static char startStr[2], endStr[2];

	startStr[0] = start; startStr[1] = 0;
	stringStartDelimiter = startStr;

	endStr[0] = end; endStr[1] = 0;
	stringEndDelimiter = endStr;
	return 0;
}

const char *c3gai::string(const char *prec /*= NULL*/) const {
	// todo: this whole function is not very (mt-)safe
	static char tmpResult[1024]; 
	tmpResult[0] = 0;

	const int maxResult = 16; 
	static char *result[maxResult];
	static int currentResult = 0;

	char *rBuf = tmpResult;
	int i, j, k = 0, ia = 0, gu = gradeUsage(), s = c3gai_mvSize[gu], p = 0, cnt = 0;
	char buf[32];	

	if (prec == NULL) prec = fpPrecision;
	sprintf(buf, "%cs%s%cs%cs", '%', prec, '%', '%');
	rBuf += sprintf(rBuf, "%s", stringStartDelimiter);
	for (i = 0; i <= 5; i++)
		if (gu & (1 << i)) {
			for (j = 0; j < c3gai_gradeSize[i]; j++) {
				if (fabs(c[k]) > 1e-14) {
					cnt++;
					rBuf += sprintf(rBuf, buf, (p) ? " + " : "", float(c[k]), (i) ? "*" : "", (i) ? c3gai_basisElementNames[ia] : "");
					p = 1;
				}
				k++; ia++;
			}
		}
		else ia += c3gai_gradeSize[i];

	if (cnt == 0) rBuf += sprintf(rBuf, "0");
	rBuf += sprintf(rBuf, "%s", stringEndDelimiter);

	k = (int)(strlen(tmpResult) + 1);
	rBuf = result[currentResult] = (char*)realloc(result[currentResult], k);
	currentResult = (currentResult + 1) % maxResult;

	if (rBuf == NULL) {
		printf("Memory allocation failure for %d bytes\n", k);
		return tmpResult; // at least return something...
	}
	else {
		memcpy(rBuf, tmpResult, k);
		return rBuf;
	}
}

void c3gai::print(const char *text /*= NULL*/, const char *prec /*= NULL*/) const {
	fprint(stdout, text, prec);
}

void c3gai::fprint(FILE *F, const char *text /*= NULL*/, const char *prec /*= NULL*/) const {
	if (text) fprintf(F, text);
	fprintf(F, "%s\n", string(prec));
}

int c3gai::renameBasisVector(const char *oldName, const char *newName) {
    unsigned int totalNb = 0;
    for (unsigned int j = 0; j < 32;j++) {
        // count number of occurances of oldName:
        char *ptr = c3gai_basisElementNames[j];
        int nb = 0;
        do {
            ptr = strstr(ptr, oldName);
            
            if (ptr != NULL) {
                nb ++;
                ptr += strlen(oldName);
            }
        } while (ptr);
        totalNb += nb;
        
        // if oldName occured:
        if (nb) {
            // allocate mem for new name
            char *buf = (char*)malloc(
                strlen(c3gai_basisElementNames[j]) + 1 + 
                nb * (strlen(newName) - strlen(oldName)));
            if (buf == NULL) return -1;

            // form new name
            ptr = c3gai_basisElementNames[j];
            char *buf2 = buf, *ptr2 = ptr;
            do {
                ptr = strstr(ptr, oldName);
                if (ptr != NULL) {
                    memcpy(buf2, ptr2, ptr - ptr2);
                    buf2 += ptr - ptr2;
                    
                    strcpy(buf2, newName);
                    buf2 += strlen(newName);
                    
                    ptr += strlen(oldName);        
                    ptr2 = ptr;
                }
                else {
                    strcpy(buf2, ptr2);
                }
            } while (ptr);
            
            // set result:
            if (c3gai_basisElementNamesAllocated[j])
                free(c3gai_basisElementNames[j]);
            c3gai_basisElementNames[j] = buf;
            c3gai_basisElementNamesAllocated[j] = true;
        }
    }
    return (totalNb == 0) ? -1 : 0;
}



int c3gai::nbBlocksAvailable[32 + 1];
int c3gai::maxBlocksAvailable[32 + 1];
double **c3gai::blocks[32 + 1];

void c3gai::doubleMaxBlocks(int n) {
	maxBlocksAvailable[n] = (maxBlocksAvailable[n]) ? maxBlocksAvailable[n] * 2 : 2;
	blocks[n] = (double**)realloc(blocks[n], sizeof(double*) * maxBlocksAvailable[n]);  // todo: check mem alloc
}

void c3gai::addBlocks(int n) {
	const int nb = 128; // nb = just a constant
	int i;
	double *newBlocks = (double*)calloc(sizeof(double) * n, nb);	// todo: check mem alloc
	while (maxBlocksAvailable[n] < nbBlocksAvailable[n] + nb) doubleMaxBlocks(n);
	for (i = 0; i < nb; i++)
		blocks[n][nbBlocksAvailable[n]++] = newBlocks + i * n;
}

void c3gai::setUsage(int u) {
	int n1, n2;

	n1 = memUsage();
	n2 = u >> (5 + 1);
	usage = u;
	if (n1 == n2) return;
	if (n1) {	// free old mem
		if (maxBlocksAvailable[n1] == nbBlocksAvailable[n1]) doubleMaxBlocks(n1);
		blocks[n1][nbBlocksAvailable[n1]] = c;
		nbBlocksAvailable[n1]++;
	}
	if (n2) {	// alloc new mem
		if (!nbBlocksAvailable[n2]) addBlocks(n2);
		nbBlocksAvailable[n2]--;
		c = blocks[n2][nbBlocksAvailable[n2]];
	}
}

void c3gai::copy(const c3gai &a) {
	setUsage(a.usage);
	c3gai_copy(c, a.c, c3gai_mvSize[a.gradeUsage()]);
}

void c3gai::compress(double epsilon /* = 1e-14 */ ) {
	double cc[32];
	int i, j, ia = 0, ib = 0, gu = gradeUsage(), gu2 = 0, f, s;
	for (i = 0; i < 6; i++) {
		if (!(gu & (1 << i))) continue;

		s = c3gai_gradeSize[i];
		j = ia + s;
		f = 0;
		for (; ia < j; ia++)
			if ((c[ia] > epsilon) || (c[ia] < -epsilon)) {f = 1; break;}
		ia = j;
		if (f) {
			c3gai_copy(cc + ib, c + ia - s, s);
			ib += s;
			gu2 |= (1 << i);
		}
	}
	if (gu2 != gu) set(gu2, cc);
}

void c3gai::reverse(const c3gai &a) {
	double *pc[6];
	copy(a);
	if (!(a.gradeUsage() & 12)) return;
	expand( (const double**) pc);
	c3gai_reverse(pc);
}

void c3gai::cliffordConjugate(const c3gai &a) {
	double *pc[6];
	copy(a);
	if (!(a.gradeUsage() & 38)) return;
	expand( (const double**) pc);
	c3gai_cliffordConjugate(pc);
}

void c3gai::gradeInvolution(const c3gai &a) {
	double *pc[6];
	copy(a);
	if (!(a.gradeUsage() & 42)) return;
	expand( (const double**) pc);
	c3gai_involution(pc);
}

void c3gai::negate(const c3gai &a) {
	setUsage(a.usage);
	c3gai_negate(c, a.c, c3gai_mvSize[a.gradeUsage()]);
}

void c3gai::add(const c3gai &a, const c3gai &b) {
	double const *pa[6], *pb[6];
	double *pc[6];
	int gu = a.gradeUsage() | b.gradeUsage();
	setUsage(gu | (c3gai_mvSize[gu] << 6));
	if (a.gradeUsage() == b.gradeUsage()) c3gai_addSameGradeUsage(c, a.c, b.c, memUsage());
	else {
		a.expand(b, pa, pb);
		expand( (const double**) pc);
		c3gai_add(pa, pb, pc);
	}
}

void c3gai::add(double scalar, const c3gai &b) {
	double const *pa[6], *pb[6];
	double *pc[6];
	int gu = GRADE0 | b.gradeUsage();
	setUsage(gu | (c3gai_mvSize[gu] << 6));
	if (GRADE0 == b.gradeUsage()) c3gai_addSameGradeUsage(c, &scalar, b.c, memUsage());
	else {
		memset(pa + 1, 0, sizeof(double*) * 5);
		pa[0] = &scalar;
		b.expand(pb);
		expand( (const double**) pc);
		c3gai_add(pa, pb, pc);
	}
}

void c3gai::sub(const c3gai &a, const c3gai &b) {
	double const *pa[6], *pb[6];
	double *pc[6];
	int gu = a.gradeUsage() | b.gradeUsage();
	setUsage(gu | (c3gai_mvSize[gu] << 6));
	if (a.gradeUsage() == b.gradeUsage()) c3gai_subSameGradeUsage(c, a.c, b.c, memUsage());
	else {
		a.expand(b, pa, pb);
		expand( (const double**) pc);
		c3gai_sub(pa, pb, pc);
	}
}

void c3gai::sub(double scalar, const c3gai &b) {
	double const *pa[6], *pb[6];
	double *pc[6];
	int gu = GRADE0 | b.gradeUsage();
	setUsage(gu | (c3gai_mvSize[gu] << 6));
	if (GRADE0 == b.gradeUsage()) c3gai_subSameGradeUsage(c, &scalar, b.c, memUsage());
	else {
		memset(pa + 1, 0, sizeof(double*) * 5);
		pa[0] = &scalar;
		b.expand(pb);
		expand( (const double**) pc);
		c3gai_sub(pa, pb, pc);
	}
}

// take grade introduced 20020710
void c3gai::takeGrade(const c3gai &a, int gu) {
	int i, gua, s;
	double *bc; 
	const double *ac; 

	// determine what the grage usage 'gu' of the result should be:
	if (gu = ((gua = a.gradeUsage()) & gu)) { // only execute if any grade will be present in the result
		// set the grade usage of the result + allocate memory
		setUsage(gu | (c3gai_mvSize[gu] << 6)); 

		bc = c; ac = a.c; // pointers to the coordinates of source (ac) and result (bc)
		for (i = 1; i <= gu; i = i << 1) { // for each grade that is possibly in the result
			if (gua & i) { // determine if grade is present in source
				s = c3gai_mvSize[i]; // get the size of grade
				if (gu & i) { // determine if grade is present in result
					c3gai_copy(bc, ac, s); // copy coordinates
					bc += s; // increment pointer to result
				}
				ac += s; // increment pointer to source
			}
		}
	}
	else setUsage(0);
}

// added an epsilon value on 2002 07 28
int c3gai::highestGrade(const c3gai &a, double epsilon /* = 1e-14 */) {
	int g = 5, gu = a.gradeUsage(), ia = c3gai_mvSize[gu], size, i;
	const double *cptr;
	do {
		if (gu & (1 << g)) {
			size = c3gai_gradeSize[g];
			ia -= size;
			cptr = a.c + ia;
			for (i = 0; i < size; i++) 
				if (fabs(cptr[i]) > epsilon) {
					set(1 << g, a.c + ia);
					return g;
				}
		}
	} while ((--g)>= 0); // bug fix on 2003 11 16, used to be while ((--g) _>_ 0)
//return -1; // modification on 20020828

	setUsage(0);
	return 0;
}

int c3gai::grade() const {
	int g = 5, gu = gradeUsage(), idx = c3gai_mvSize[gu], size, i;
	const double *cptr;
	do {
		if (gu & (1 << g)) {
			size = c3gai_gradeSize[g];
			idx -= size;
			cptr = c + idx;
			for (i = 0; i < size; i++) if (cptr[i] != (double)0.0) return (gu ^ (1 << g)) ? -1 : g;
		}
	} while ((--g)>0);
	return 0;
}

int c3gai::maxGrade() const { 
	int g = 5, gu = gradeUsage(), idx = c3gai_mvSize[gu], size, i;
	const double *cptr;
	do {
		if (gu & (1 << g)) {
			size = c3gai_gradeSize[g];
			idx -= size;
			cptr = c + idx;
			for (i = 0; i < size; i++) if (cptr[i] != (double)0.0) return g;
		}
	} while ((--g)>0);
	return -1;
}

int c3gai::largestGrade() const {
	int g = 0, gu = gradeUsage(), size;
	double largest = -1.0, tmp;
	int lg = 0;
	const double *cptr = c;
	do {
		if (gu & (1 << g)) {
			size = c3gai_gradeSize[g];
			if ( (tmp = c3gai_norm_a(cptr, size)) > largest) {
				largest = tmp;
				lg = g;
			}
			gu ^= (1 << g);
			
			cptr += size;
		}
	} while (gu && ((++g)<=5));
	return lg;
}




int c3gai::versorInverse(const c3gai &a) {
	c3gai reverse, scalar;
	reverse.reverse(a);
	scalar.scp(a, reverse);
	if ((scalar.c == NULL) || (scalar.c[0] == 0.0f)) {null(); return -1;}
	scalar.c[0] = 1.0f / scalar.c[0];
	op(scalar, reverse);
	return 0;
}

void c3gai::expand(double matrix[], const int table[]) const {
	double val;
	int i, j = 0, t, g = -1, gi = 0, gu = gradeUsage(), ci = 0;
	for (i = -1; i < 32; i++) {
		if (i == -1) val = 0.0f;
		else {
			if (gi == 0) gi = c3gai_gradeSize[++g];
			if (gu & (1 << g)) val = c[ci++];
			else val = 0.0f;
			gi--;
		}
		while ((t = table[j++]) >= 0) {
			if (t & 2048) matrix[t & 1023] += (t & 1024) ? (double)-val : (double)val;
			else matrix[t & 1023] = (t & 1024) ? (double)-val : (double)val;
		}
	}
}

int c3gai::generalInverse(const c3gai &a) {
	static double matrix[1024];
	double *m[32] = {
		matrix + 0,
		matrix + 32,
		matrix + 64,
		matrix + 96,
		matrix + 128,
		matrix + 160,
		matrix + 192,
		matrix + 224,
		matrix + 256,
		matrix + 288,
		matrix + 320,
		matrix + 352,
		matrix + 384,
		matrix + 416,
		matrix + 448,
		matrix + 480,
		matrix + 512,
		matrix + 544,
		matrix + 576,
		matrix + 608,
		matrix + 640,
		matrix + 672,
		matrix + 704,
		matrix + 736,
		matrix + 768,
		matrix + 800,
		matrix + 832,
		matrix + 864,
		matrix + 896,
		matrix + 928,
		matrix + 960,
		matrix + 992

	};
	double maxp, *tmp, mult;
	int pi, i, j, k;
	double inverse[32];
	inverse[0] = 1.0f;

	// modification for custom float (december 9 2002)
	c3gai_null(inverse + 1, 32-1);

	int it = 0;

	a.expand(matrix, c3gai_expansionTable_gp);

	for (i = 0; i < 32; i++) {	// sweep all columns
		pi = i;
		maxp = (double)fabs(m[i][i]);

		for (j = i + 1; j < 32; j++) // find the max pivot
			if ((double)fabs(m[j][i]) > maxp)
				maxp = (double)fabs(m[pi = j][i]);
		if (inverse[pi] != 0.0f) it = 1;
		if (pi != i) { // swap rows
			if (inverse[i] != 0.0f) it = 1;
			tmp = m[pi]; m[pi] = m[i]; m[i] = tmp;
			if (it) maxp = inverse[pi]; inverse[pi] = inverse[i]; inverse[i] = maxp;
		}

		maxp = m[i][i];
		if (maxp == 0.0f) {	// singular matrix
			setUsage(0);
			return -1;
		}

		for (k = 0; k < 32; k++) { // sweep all other rows
			if (k == i) continue;
			mult = -m[k][i] / maxp;
			for (j = i + 1; j < 32; j++) m[k][j] += m[i][j] * mult;
			if (it) inverse[k] += inverse[i] * mult;
		}

		for (j = i+1; j < 32; j++) m[i][j] /= maxp; // divide the pivot row
		if (it) inverse[i] /= maxp;
	}
	set((1 << 6) - 1, inverse);
	return 0;
}

double c3gai::norm_a() const {
	return c3gai_norm_a(c, c3gai_mvSize[gradeUsage()]);
}

double c3gai::norm_b() const {
	c3gai r, s;
	r.reverse(*this);
	s.scp(*this, r);
	return s.scalar();
}

double c3gai::largestCoordinate() const {
	int nc = c3gai_mvSize[gradeUsage()], i;
	double maxC = 0.0, C;
	
	for (i = 0; i < nc; i++) {
		C = fabs(c[i]);
		if (C > maxC) maxC = C;
	}
	
	return maxC;
}

void c3gai::normalize(const c3gai &a, int norm) {
	double tmpC;
	switch(norm) {
	case 1:
		tmpC = 1.0f / (double)sqrt(a.norm_a());
		break;
	case 2:
		tmpC = 1.0f / (double)sqrt(fabs(a.norm_b()));
		break;
	}
	c3gai scalar(GRADE0, tmpC);
	op(a, scalar);
}

int c3gai::project(const c3gai &blade, const c3gai &a) {
	c3gai tmp, bladeInverse;
	bladeInverse.versorInverse(blade);
	tmp.lcont(a, blade);
	lcont(tmp, bladeInverse);
	return 0;
}

int c3gai::projectOntoVersor(const c3gai &versor, const c3gai &a) {
	c3gai tmp, versorInverse;
	versorInverse.versorInverse(versor);
	tmp.lcont(a, versor);
	gp(tmp, versorInverse);
	return 0;
}

int c3gai::reject(const c3gai &blade, const c3gai &a) {
	c3gai tmp, bladeInverse;
	// todo: check if this code is correct
	bladeInverse.versorInverse(blade);
	tmp.op(blade, a);
	lcont(bladeInverse, tmp);
	return 0;
}

int c3gai::versorInverseEM(const c3gai &a) {
	c3gai reverse, scalar;
	reverse.reverse(a);
	scalar.scpem(a, reverse);
	if (scalar.c[0] == 0.0f) return -1;
	scalar.c[0] = 1.0f / scalar.c[0];
	op(scalar, reverse);
	return 0;
}

int c3gai::projectEM(const c3gai &blade, const c3gai &a) {
	c3gai tmp, bladeInverse;
	bladeInverse.versorInverseEM(blade);
	tmp.lcem(a, blade);
	lcem(tmp, bladeInverse);
	return 0;
}

// todo: ensure everything is euclidean...
int c3gai::factor(c3gai factors[], int versor /* = 0 */) const {
	c3gai ca[2], tmp, fi, tmpbv;
	int ga = (versor) ? maxGrade() : grade(), n = 0, i, idx, cca = 0, gu = gradeUsage(), bev;
	double maxC, tmpC, mul, *c2;
	const double *tmpc;
	static double bvc[5] = {1.0, 0.0, 0.0, 0.0, 0.0};

	if (ga <= 0) return 0;

	// compute the multiplication factor require to make every factor of the same order of magnitude
	mul = (double)pow((double)sqrt((double)norm_a()), 1.0 / (double)ga);

	// setup current 'a'
	ca[0].copy(*this);

	// get the coordinate array for grade 'ga'
	tmpc = coordinates(1 << ga);

	// find out the maximum coordinate
	maxC = (double)fabs(tmpc[idx = 0]);
	for (i = 1; i < c3gai_gradeSize[ga]; i++) 
		if ( (tmpC = (double)fabs(ca[cca].c[i])) > maxC) {maxC = tmpC;idx = i;}

	// find out which basis vectors we have to project onto the blade
	idx += c3gai_mvSize[0xff >> (8 - ga)];
	bev = c3gai_newBevt[idx];

	// setup a basis vector
	tmpbv.setVector(bvc);
	c2 = tmpbv.c;
	idx = 0;

	i = 1;
	for (; ga > 1; ga--) {
		// find the next coordinate
		do { // note: the first coordinate is always skipped; this is note a bug 
			c2[idx++] = 0.0; // direct manipulation of 'bv'; hack
			c2[idx] = 1.0; // direct manipulation of 'bv'; hack
			i <<= 1;
		} while (!(bev & i));

		tmp.projectEM(ca[cca], tmpbv);
		factors[n].op(mul, tmp); // make all factors approximatelly the same size

		// remove the factor from the blade
		fi.versorInverseEM(factors[n++]); 
		if (versor) ca[cca ^ 1].gpem(fi, ca[cca]);
		else ca[cca ^ 1].lcem(fi, ca[cca]);
		cca ^= 1;
	}

	factors[n++].takeGrade(ca[cca], GRADE1);	// the last factor is equal to the remaining vector

	return n;
}


int c3gai::deltaProduct(const c3gai &a, const c3gai &b) {
	c3gai mv1;
	mv1.gpem(a, b);
	return this->highestGrade(mv1);
}

int c3gai::join(const c3gai &a, const c3gai &b, int algorithm /*= 1*/) {
	c3gai d, factors[5];
	int gj, ga = a.grade(), gb = b.grade(), gd;
	c3gai ca, cb;

	// if we are not handed homogeneous multivectors, take the grade parts with the largest norm
	if (ga < 0) {
		ga = a.largestGrade();
		ca.takeGrade(a, 1 << ga);
	}
	else ca.copy(a);

	if (gb < 0) {
		gb = b.largestGrade();
		cb.takeGrade(b, 1 << gb);
	}
	else cb.copy(b);

	// determine the grade of the join
	if (ga == 0) { // then the join is equal to b
		op(ca, cb); return gb;
	}
	else if (gb == 0) { // then the join is equal to a
		op(cb, ca); return ga;
	}
	else { // the join must be computed
		gd = d.deltaProduct(ca, cb);
		gj = (ga + gb + gd) >> 1;
		return (algorithm == 1) 
			? joinAlg1(ca, cb, ga, gb, gj)
			: joinAlg2(ca, cb, ga, gb, gj);
	}
}

int c3gai::meet(const c3gai &a, const c3gai &b, int algorithm /*= 1*/) {
	c3gai d, factors[5], j, jinv;
	int ga = a.grade(), gb = b.grade(), gd;

	c3gai ca, cb;

	// if we are not handed homogeneous multivectors, take the grade parts with the largest norm
	if (ga < 0) {
		ga = a.largestGrade();
		ca.takeGrade(a, 1 << ga);
	}
	else ca.copy(a);

	if (gb < 0) {
		gb = b.largestGrade();
		cb.takeGrade(b, 1 << gb);
	}
	else cb.copy(b);

	// compute delta product, join, ->meet
	gd = d.deltaProduct(ca, cb);
	j.join(ca, cb, algorithm);
	if (jinv.versorInverse(j)) {
		null();
		return 0;
	}
	lcem(d, jinv);
	return (ga + gb - gd) >> 1;
}

// todo: ensure everything is euclidean...
int c3gai::joinAlg2(const c3gai &a, const c3gai &b, int ga, int gb, int gj) {
	c3gai mv1, factors[5];
	int cg, lg, nf; // gj = grade join, gd = grade delta product

	// check for pseudoscalar case:
	if (gj == 5) {
		copy(I);
		return gj;
	}
	
	/*
	we pick the highest-dimension blade to start with,
	and factor the other blade
	*/
	c3gai res[6];
	int factorsTried[6];
	double largestNorm = -1.0f, nm;
	if (ga > gb) {
		if ( (nf = b.factor(factors)) != gb) return -1;	// should never happen
		lg = cg = ga;
		res[cg].copy(a);
	}
	else {
		if ( (nf = a.factor(factors)) != ga) return -1;	// should never happen
		lg = cg = gb;
		res[cg].copy(b);
	}

	// modification for bug of type 'join(e1, e1) = 0' (instead of e1) // 2003 10 28
	if (cg == gj) {	// if we have arrived at the grade of the join:
		copy(res[cg]);
		return gj;
	}

	/*
	Wegde as much factors as we need to get the right grade 
	*/
	factorsTried[cg] = 0;
	while (1) {
		// should we lower the current grade, and try the next factor?
		while (factorsTried[cg] >= nf) cg--;
		if (cg < lg) break;

		// wegde a factor to the result
		res[cg + 1].op(res[cg], factors[factorsTried[cg]]);
		factorsTried[cg + 1] = ++(factorsTried[cg]);
		cg++;

		if (cg == gj) {	// if we have arrived at the grade of the join:
			if ( (nm = res[cg].norm_a()) > largestNorm) {
				largestNorm = nm;
				copy(res[cg]);
			}
			cg--;
		}
	}

	return gj;
}

int c3gai::joinAlg1(const c3gai &a, const c3gai &b, int ga, int gb, int gj) {
	c3gai mv1, b1, b2, factors[5];
	int i, rg, gs; // gj = grade join, gd = grade delta product, rg = required grade, gs = grade size

	// check for pseudoscalar case:
	if (gj == 5) {
		copy(I);
		return gj;
	}

	/* we pick the highest-dimension blade (b1) to start with */
	c3gai be, pbe, tmp; // be = basis element, pbe = projected basis element
	double v1[10];
	double largestNorm = -1.0f, nm;
	if (ga > gb) {
		b1.copy(a);
		rg = gj - ga;
		b2.copy(b);
	}
	else {
		b1.copy(b);
		rg = gj - gb;
		b2.copy(a);
	}

	// project all possible basis elements of grade 'rg' onto blade b2; wegde them with b1
	gs = c3gai_gradeSize[rg];

	// modification for bug of type 'join(e1, e1) = 0' (instead of e1) // 2003 10 28
	if (gs == 0) { // nothing to do, since 'b1' already has the require grade
		copy(b1);
		return gj;
	}
	
	// modification for custom float (december 9 2002)
	c3gai_null(v1, gs);

	be.set(1 << rg, v1);
	for (i = 0; i < gs; i++) {
		be.c[i] = 1.0f;	// hack
		if (i) be.c[i-1] = 0.0f; // hack
		pbe.projectEM(b2, be);
		tmp.op(b1, pbe);
		if ( (nm = tmp.norm_a()) > largestNorm) {
			largestNorm = nm;
			copy(tmp);
		}
	}

	return gj;
}


int c3gai::random(int grade, double scale, int versor) {

	scale *= (double)2.0;

	// compute how many vector we have to multiply/wegd
	int nb = -1;
	while (grade) {
		grade >>= 1;
		nb++;
	}
	if (nb < 0) return -1;
	else if (nb == 0) {
		setScalar(scale * ((double)rand() / (double)2147483647 - (double)0.5));
	}
	else {
		int i, j, ct = 0;
		c3gai rv, tmp[2];
		double v[5], scalar = (double)1.0;

		tmp[0].setScalar(&scalar);
		for (i = 0; i < nb; i++) {
			// create a random vector
			for (j = 0; j < 5; j++)
				v[j] = scale * ((double)rand() / (double)2147483647 - (double)0.5);
			rv.setVector(v);

			// multiply/wegde it to the result
			if (versor) tmp[ct ^ 1].gp(tmp[ct], rv);
			else tmp[ct ^ 1].op(tmp[ct], rv);

			ct ^= 1;
		}

		copy(tmp[ct]);
	}

	return 0;
}

int c3gai::reciprocalFrame(c3gai f[], const c3gai e[], int nbVectors) {
	int cb = 0, i, err, ca, j;
	double scalar = 1.0f;
	c3gai B[2], Bi, tmp, einv, A[2];

	if ((nbVectors <= 0) || (nbVectors > 5)) return 0;

	// build the blade which is the pseudoscalar for the frame 
	B[cb].copy(e[0]);
	for (i = 1; i < nbVectors; i++) {
		B[cb^1].op(B[cb], e[i]);
		cb ^= 1;
	}

	// computer the inverse of the frame
	if (err = Bi.versorInverse(B[cb])) return err;

	// compute the reciprocal vectors
	for (i = 0; i < nbVectors; i++) {
		ca = 0;

		// compute te right scalar factor
		scalar = (i & 1) ? -1.0f : 1.0f;
		A[ca].setScalar(&scalar);

		// compute the blade, with omission of vector e[i]
		for (j = 0; j < nbVectors; j++) {
			if (j == i) continue;
			A[ca^1].op(A[ca], e[j]);
			ca ^= 1;
		}

		// compute reciprocal vector f[i]
		f[i].lcont(A[ca], Bi);
	}

	return 0;
}

int c3gai::mvType(int *grade /*= NULL*/, double epsilon /* = 1e-14 */) const {
// this code fails on 'e1 + (e2 ^ e3)' (says it versor, while it isn't)
	// a = *this
	// compute versor inverse of input
	if (grade) *grade = 0;

	c3gai reverse, scalar, ai;
	reverse.reverse(*this);
	scalar.scpem(*this, reverse); 
	if ((scalar.c == NULL) || (scalar.c[0] == 0.0f)) return GA_MULTIVECTOR;
	scalar.c[0] = 1.0f / scalar.c[0];
	ai.op(scalar, reverse);

	// check if ai * a = 1
	c3gai mv1, mv2, mv3;
	mv1.gpem(ai, *this); 
	mv1.compress(epsilon);
	if (mv1.gradeUsage() > GRADE0) return GA_MULTIVECTOR;
	if ((mv1.gradeUsage() == 0) || (mv1.c[0] < 1.0f - epsilon) || (mv1.c[0] > 1.0f + epsilon)) 
		return GA_MULTIVECTOR;

	// check if a * ai = 1
	mv1.gpem(*this, ai); 
	mv1.compress(epsilon);
	if (mv1.gradeUsage() > GRADE0) return GA_MULTIVECTOR;
	if ((mv1.gradeUsage() == 0) || (mv1.c[0] < 1.0f - epsilon) || (mv1.c[0] > 1.0f + epsilon)) 
		return GA_MULTIVECTOR;

	// test if ai * x * a is of the same grade as 'x' for all basis vectors
	int i, j, g;
	for (i = 0; i < 5; i++) { 
		mv1.gpem(ai, *c3gai::bv[i]);  // todo: EUCLIDEAN?
		mv2.gpem(mv1, *this);  
		mv2.compress(epsilon);
		if (mv2.gradeUsage() & (0xffff ^ GRADE1)) return GA_MULTIVECTOR;
	}

	// normalize 'a' (this is to make sure we don't misqualify 'small' (<epsilon) versors as blades
	scalar.setScalar(sqrt(fabs(scalar.c[0])));
	ai.op(scalar, *this);

	// test if a is of a single grade
	ai.compress(epsilon);
	i = ai.gradeUsage(); j = 0;
	g = GRADE0;
	while (i) {
		if (grade && (i & 1)) *grade = g;
		j += i & 1;
		i >>= 1;
		g <<= 1;
	}
	return (j <= 1) ? GA_BLADE : GA_VERSOR;
}

static int memberOf(char c, const char *set) { 
	int i = 0;
	while (set[i]) {
		if (c == set[i]) return 1;
		i++;
	}
	return 0;
}

int c3gai::parseString(const char *str, const c3ga_ben *ben /*= NULL*/) {
	int idx = 0, pmCnt, beCnt = 0;
	const int strLength = 256;
	double scalar;
	int floatStart, floatEnd, bvStart, bvEnd, i;
	c3gai blade, bv, BE, tmp;
	int stage = 0;
	char floatStr[strLength], bvStr[strLength];

	c3ga_ben defaultBen;
	if (ben == NULL) ben = &defaultBen;

	null();

	if (ben->m_startDelimiter) {
		// the first character found must be equal to m_startDelimiter
		while (str[idx] <= ' ') { // skip space until something happens
			if (str[idx] == 0) return -1; // nothing read
			idx++;
		}
		if (str[idx] != ben->m_startDelimiter) return -1; // first character is not the m_startDelimiter
		idx++;
	}

	for (;;) {
		blade.setScalar((double)1.0);
		scalar = (double)1;

		while (str[idx] <= ' ') { // skip space until something happens
			if (str[idx] == 0) return (ben->m_endDelimiter) ? -1 : idx; // done or error
			idx ++;
		}

		i = idx;
		pmCnt = 0; // plus minus count
		for (;;) { // parse [+|-]+
			if (str[idx] == '+') {scalar *= (double)+1; pmCnt++;}
			else if (str[idx] == '-') {scalar *= (double)-1; pmCnt++;}
			else if (memberOf(str[idx], "0123456789.")) break; // start of the float
			else if ((str[idx] > 0) && (str[idx] <= ' ')); // skip space
			else break;
			idx++;
		}
		if (beCnt && (!pmCnt)) return -1;

		if (memberOf(str[idx], "0123456789.")) { // parse float and '*' or '^'
			// parse the float
			floatStart = idx;
			while (memberOf(str[idx],  "0123456789.eE") ||
				(idx && ((str[idx-1] == 'e') || (str[idx-1] == 'E')) && ((str[idx] == '-') || (str[idx] == '+'))))  idx++;
			floatEnd = idx;
			memcpy(floatStr, str + floatStart, floatEnd - floatStart);
			floatStr[floatEnd - floatStart] = 0;
			if (floatEnd - floatStart <= 0) return -1;
			scalar *= (double)atof(floatStr);

			while (str[idx] <= ' ') { // skip space until something happens
				if (str[idx] == 0) {
					tmp.copy(*this); add(scalar, tmp);
					return (ben->m_endDelimiter) ? -1 : idx; // done or error
				}
				idx++;
			}

			// check if next char is +,-,* or 'ben->m_endDelimiter'
			if ((str[idx] == '+') || (str[idx] == '-')) {
				tmp.copy(*this); add(scalar, tmp);
				beCnt++;
				continue;
			}
			else if (ben->m_endDelimiter && (str[idx] == ben->m_endDelimiter)) { // end delimiter
				tmp.copy(*this); add(scalar, tmp);
				return idx+1;
			}
			else if ((str[idx] != '*') && (str[idx] != '^')) return -1; // must be either +,-, ^ or *
			else idx++; // skip over '*' or '^'

			while (str[idx] <= ' ') { // skip space until something happens
				if (str[idx] == 0) return -1; // error
				idx++;
			}
		}

		for (;;) { // parse a basis element ex ^ ey ^ ez
			bvStart = idx; // find the start and end of the basis vector name
			while ((str[idx] > ' ') && (str[idx] != '-') && (str[idx] != '+') && (str[idx] != '^') && (str[idx] != ben->m_endDelimiter)) idx ++;
			bvEnd = idx;

			// copy name, parse it 
			if ((bvEnd - bvStart + 1) >= strLength) return -1; // error (string too long)
			memcpy(bvStr, str + bvStart, bvEnd - bvStart);
			bvStr[bvEnd - bvStart] = 0;
			if (ben->lookupName(bvStr, BE) < 0) return -1; // basis vector name is invalid

			tmp.copy(blade); blade.op(tmp, BE); // wedge the basis element to the blade

			while (str[idx] <= ' ') { // skip space until something happens
				if ((str[idx] == 0) || (str[idx] == ben->m_endDelimiter))  break;
				idx++;
			}
			
			// next char must be a wedge, or this is the end of the blade
			if (str[idx] != '^') break;
			idx++;
		}

		tmp.op(scalar, blade);
		blade.copy(*this);
		add(blade, tmp);
		beCnt++;

		if (str[idx] == ben->m_endDelimiter) return idx + 1;

	}
	return idx; // the function never arrives here?
}

void c3gai::om(const c3gai &a, const c3gai_om &om) {
	int ia = 0;
	setUsage(a.usage);

	if (gradeUsage() & 1) {
		c3gai_opt_om_01x01(om.c + 0, a.c + ia, c + ia);
		ia += 1;
	}

	if (gradeUsage() & 2) {
		c3gai_opt_om_05x05(om.c + 1, a.c + ia, c + ia);
		ia += 5;
	}

	if (gradeUsage() & 4) {
		c3gai_opt_om_0Ax0A(om.c + 26, a.c + ia, c + ia);
		ia += 10;
	}

	if (gradeUsage() & 8) {
		c3gai_opt_om_0Ax0A(om.c + 126, a.c + ia, c + ia);
		ia += 10;
	}

	if (gradeUsage() & 16) {
		c3gai_opt_om_05x05(om.c + 226, a.c + ia, c + ia);
		ia += 5;
	}

	if (gradeUsage() & 32) {
		c3gai_opt_om_01x01(om.c + 251, a.c + ia, c + ia);
		ia += 1;
	}

}

void c3gai::expand(const double *pa[6]) const {
	int ia = 0;
	int i, j = 1;
	for (i = 0; i < 6; i++) {
		if (gradeUsage() & j) {
			pa[i] = c + ia;
			ia += c3gai_gradeSize[i];
		}
		else pa[i] = NULL;
		j <<= 1;
	}
}

void c3gai::expand2i(const c3gai &b, double const *pa[6], double const *pb[6]) const {
	int ia = 0;
	int i, j = 1;
	for (i = 0; i < 6; i++) {
		if (gradeUsage() & j) {
			pa[i] = c + ia;
			pb[i] = b.c + ia;
			ia += c3gai_gradeSize[i];
		}
		else pa[i] = pb[i] = NULL;
		j <<= 1;
	}
}

void c3gai::expand(const c3gai &b, double const *pa[6], double const *pb[6]) const {
	int ia = 0, ib = 0;
	int i, j = 1;
	for (i = 0; i < 6; i++) {
		if (gradeUsage() & j) {
			pa[i] = c + ia;
			ia += c3gai_gradeSize[i];
		}
		else pa[i] = NULL;
		if (b.gradeUsage() & j) {
			pb[i] = b.c + ib;
			ib += c3gai_gradeSize[i];
		}
		else pb[i] = NULL;
		j <<= 1;
	}
}

void c3gai::compress(double coordinates[32]) {
	int i, j, k, l, s, u;
	double cc[32];
	l = k = u = 0;
	for (i = 0; i < 6; i++) {
		s = c3gai_gradeSize[i];
		for (j = 0; j < s; j++)
			if (coordinates[k + j] != 0.0f) {
				u |= (1 << i);
				c3gai_copy(cc + l, coordinates + k, s);
				l += s;
				break;
			}
		k += s;
	}
	setUsage(u | (l << 6));
	c3gai_copy(c, cc, l);
}

const double *c3gai::coordinates(int grade) const {
	int ia = 0;
	int i, j = 1, gu = gradeUsage();
	static const double null[32] = {0}; // temp test for Brian Bouta problem
	for (i = 0; i < 6; i++) {
		if (j == grade) return (gu & j) ? c + ia : null;
		if (gu & j) ia += c3gai_gradeSize[i];
		j <<= 1;
	}
	return null;
}

int c3gai::fastDual(const c3gai &a) {
	setUsage(a.usage);
	int gua = a.gradeUsage(), gud = 0;
	int ia = c3gai_mvSize[gua], id = 0;
	const double *ca = a.c;
	double *cd = c;
	if (gua & GRADE5) {
		gud |= GRADE0;
		ia -= c3gai_gradeSize[5];
		cd[id + 0] = ca[ia + 0];
		id += c3gai_gradeSize[0];
	}
	if (gua & GRADE4) {
		gud |= GRADE1;
		ia -= c3gai_gradeSize[4];
		cd[id + 3] = -ca[ia + 0];
		cd[id + 4] = ca[ia + 1];
		cd[id + 2] = ca[ia + 2];
		cd[id + 1] = -ca[ia + 3];
		cd[id + 0] = ca[ia + 4];
		id += c3gai_gradeSize[1];
	}
	if (gua & GRADE3) {
		gud |= GRADE2;
		ia -= c3gai_gradeSize[3];
		cd[id + 9] = ca[ia + 0];
		cd[id + 5] = -ca[ia + 1];
		cd[id + 4] = ca[ia + 2];
		cd[id + 3] = -ca[ia + 3];
		cd[id + 8] = ca[ia + 4];
		cd[id + 7] = -ca[ia + 5];
		cd[id + 6] = ca[ia + 6];
		cd[id + 2] = -ca[ia + 7];
		cd[id + 1] = ca[ia + 8];
		cd[id + 0] = -ca[ia + 9];
		id += c3gai_gradeSize[2];
	}
	if (gua & GRADE2) {
		gud |= GRADE3;
		ia -= c3gai_gradeSize[2];
		cd[id + 9] = ca[ia + 0];
		cd[id + 8] = -ca[ia + 1];
		cd[id + 7] = ca[ia + 2];
		cd[id + 3] = ca[ia + 3];
		cd[id + 2] = -ca[ia + 4];
		cd[id + 1] = ca[ia + 5];
		cd[id + 6] = -ca[ia + 6];
		cd[id + 5] = ca[ia + 7];
		cd[id + 4] = -ca[ia + 8];
		cd[id + 0] = -ca[ia + 9];
		id += c3gai_gradeSize[3];
	}
	if (gua & GRADE1) {
		gud |= GRADE4;
		ia -= c3gai_gradeSize[1];
		cd[id + 4] = -ca[ia + 0];
		cd[id + 3] = ca[ia + 1];
		cd[id + 2] = -ca[ia + 2];
		cd[id + 0] = ca[ia + 3];
		cd[id + 1] = -ca[ia + 4];
		id += c3gai_gradeSize[4];
	}
	if (gua & GRADE0) {
		gud |= GRADE5;
		ia -= c3gai_gradeSize[0];
		cd[id + 0] = -ca[ia + 0];
		id += c3gai_gradeSize[5];
	}

	usage = gud | (usage ^ gua);
	return 0;
}

void c3gai::gp(const c3gai &a, const c3gai &b) {

	double const *pa[6], *pb[6];
	double cc[32];
	a.expand(b, pa, pb);
	c3gai_general_gp(pa, pb, cc);
	compress(cc);
}

void c3gai::scp(const c3gai &a, const c3gai &b) {

	double const *pa[6], *pb[6];
	double cc[32];
	a.expand(b, pa, pb);
	c3gai_general_scp(pa, pb, cc);
	compress(cc);
}

void c3gai::op(const c3gai &a, const c3gai &b) {

	double const *pa[6], *pb[6];
	double cc[32];
	a.expand(b, pa, pb);
	c3gai_general_op(pa, pb, cc);
	compress(cc);
}

void c3gai::op(double a, const c3gai &b) {

	double const *pa[6], *pb[6];
	double cc[32];
	b.expand(pb);
	memset(pa + 1, 0, sizeof(double*) * 5);
	pa[0] = &a;
	c3gai_general_op(pa, pb, cc);
	compress(cc);
}

void c3gai::lcont(const c3gai &a, const c3gai &b) {

	double const *pa[6], *pb[6];
	double cc[32];
	a.expand(b, pa, pb);
	c3gai_general_lcont(pa, pb, cc);
	compress(cc);
}

void c3gai::rcont(const c3gai &a, const c3gai &b) {

	double const *pa[6], *pb[6];
	double cc[32];
	a.expand(b, pa, pb);
	c3gai_general_rcont(pa, pb, cc);
	compress(cc);
}

void c3gai::hip(const c3gai &a, const c3gai &b) {

	double const *pa[6], *pb[6];
	double cc[32];
	a.expand(b, pa, pb);
	c3gai_general_hip(pa, pb, cc);
	compress(cc);
}

void c3gai::mhip(const c3gai &a, const c3gai &b) {

	double const *pa[6], *pb[6];
	double cc[32];
	a.expand(b, pa, pb);
	c3gai_general_mhip(pa, pb, cc);
	compress(cc);
}

void c3gai::gpem(const c3gai &a, const c3gai &b) {

	double const *pa[6], *pb[6];
	double cc[32];
	a.expand(b, pa, pb);
	c3gai_general_gpem(pa, pb, cc);
	compress(cc);
}

void c3gai::lcem(const c3gai &a, const c3gai &b) {

	double const *pa[6], *pb[6];
	double cc[32];
	a.expand(b, pa, pb);
	c3gai_general_lcem(pa, pb, cc);
	compress(cc);
}

void c3gai::scpem(const c3gai &a, const c3gai &b) {

	double const *pa[6], *pb[6];
	double cc[32];
	a.expand(b, pa, pb);
	c3gai_general_scpem(pa, pb, cc);
	compress(cc);
}
void c3gai_opt_zero_result(const double *a, const double *b, double *c) {};

int c3gai::resetProfile() {
	return 0;
}
int c3gai::printProfile(float threshold /* = 2.0 */) {
	return 0;
}
int c3gai::saveProfile(const char *filename /*  = NULL */) {
	return 0;
}

c3gai_om::c3gai_om() {
	// modification for custom float (december 9 2002)
	c3gai_null(c, 252);
}

c3gai_om::~c3gai_om() {
}

c3gai_om::c3gai_om(const c3gai vectorImages[5]) {
	initOuterMorphism(vectorImages);
}
c3gai_om::c3gai_om(const c3gai *vectorImages[5]) {
	initOuterMorphism(vectorImages);
}

int c3gai_om::initOuterMorphism(const c3gai vectorImages[5]) {
	const c3gai *vi[5];
	int i;
	for (i = 0; i < 5; i++)
		vi[i] = vectorImages + i;
	return initOuterMorphism(vi);
}

int c3gai_om::initOuterMorphism(const c3gai *vectorImages[5]) {
	int beComputed[32], i, j, k, ic, gs, bei;	// be = Basis Element
	c3gai be[32];
	double scalar = 1.0f;
	const double *bec;

	// set all vectors
	for (i = 1; i <= 5; i++) {
		be[i].takeGrade(*(vectorImages[i-1]), GRADE1);
		beComputed[i] = 1;
	}

	// compute all the other basis elements
	memset(beComputed + 5 + 1, 0, sizeof(int) * (32 - 5 - 1));
	for (i = 5 + 1; i < 32; i++)
		computeBE(be, beComputed, i);

	// insert all coordinates into the matrix
	ic = 1;
	bei = 1;
	for (i = 1; i <= 5; i++) {
		gs = c3gai_gradeSize[i];
		for (j = 0; j < gs; j++) {
			bec = be[bei].coordinates(1 << i);
			for (k = 0; k < gs; k++) {
				c[ic + k * gs] = bec[k];
			}
			ic++;
			bei++;
		}
		ic += gs * (gs-1);
	}
	return 0;
}

int c3gai_om::computeBE(c3gai be[32], int beComputed[32], int idx) {
	int i, j, err;
	c3gai tmp;

	if (!beComputed[i = c3gai_omct[idx * 3 + 0]])
		if (err = computeBE(be, beComputed, i)) return err;
	if (!beComputed[j = c3gai_omct[idx * 3 + 1]])
		if (err = computeBE(be, beComputed, j)) return err;

	if (c3gai_omct[idx * 3 + 2] < 0) {
		tmp.negate(be[i]);
		be[idx].op(tmp, be[j]);
	}
	else {
		be[idx].op(be[i], be[j]);
	}

	beComputed[idx] = 1;

	return 0;
}

int c3gai_om::initSpinor2(const c3gai &Sp) {
	int i;
	c3gai Spi, vectorImages[3], tmp, tmp2;
	Spi.versorInverse(Sp);

	for (i = 0; i < 5; i++) {
		tmp.gp(Sp, *(c3gai::bv[i]));
		tmp2.gp(tmp, Spi);
		vectorImages[i].takeGrade(tmp2, GRADE1);
	}
	
	return initOuterMorphism(vectorImages);
}

c3gai_be::c3gai_be(const char *name, const c3gai &mv) {
	initToNothing();

	if (name) m_name = strdup(name);
	m_mv.copy(mv);
}

c3gai_be::~c3gai_be() {
	if (m_name) free(m_name);
	initToNothing();
}

void c3gai_be::initToNothing() {
	m_name = NULL;
	m_mv.null();
}

int c3gai_be::compareName(const char *name)  const {
	if ((name == NULL) || (m_name == NULL)) return 0;
	return (!strcmp(name, m_name));
}

c3ga_ben::c3ga_ben() {
	initToNothing();
	setDefaults();
}

c3ga_ben::c3ga_ben(char startDelimiter, char endDelimiter) {
	initToNothing();
	setDefaults();
	setDelimiters(startDelimiter, endDelimiter);
}

c3ga_ben::~c3ga_ben() {
	removeAll();
	initToNothing();
}

void c3ga_ben::initToNothing() {
	m_ben = NULL;
	m_nbBen = 0;
	m_startDelimiter = m_endDelimiter = 0;
}

int c3ga_ben::removeAll() {
	int i;
	if (m_ben) {
		for (i = 0; i < m_nbBen; i++)
			if (m_ben[i]) delete m_ben[i];
		free(m_ben);
	}
	m_ben = NULL;
	m_nbBen = 0;
	return 0;
}

int c3ga_ben::addName(const char *name, const c3gai &mv) {
	c3gai tmpMv;
	if (lookupName(name, tmpMv) == 0) return -1; // already present in list
	
	if ( (m_ben = (c3gai_be**)realloc(m_ben, sizeof(c3gai_be*) * (m_nbBen + 1))) == NULL) {
		printf("c3ga_ben::addName(): memory allocation failure for '%d' bytes\n", sizeof(c3gai_be*) * (m_nbBen + 1));
		return -1;
	}

	if ( (m_ben[m_nbBen] = new c3gai_be(name, mv)) == NULL) {
		printf("c3ga_ben::addName(): memory allocation failure for '%d' bytes\n", sizeof(c3gai_be));
		return -1;
	}

	m_nbBen++;

	return 0;
}

int c3ga_ben::removeName(const char *name) {
	int i;

	for (i = 0; i < m_nbBen; i++)
		if (m_ben[i]->compareName(name)) {
			delete m_ben[i];
			m_ben[i] = m_ben[m_nbBen - 1];
			m_nbBen--;
			i--;
		}

	return 0;
}

int c3ga_ben::lookupName(const char *name, c3gai &mv) const {
	int i;

	for (i = 0; i < m_nbBen; i++)
		if (m_ben[i]->compareName(name)) {
			mv.copy(m_ben[i]->m_mv);
			return 0;
		}

	return -1;
}

int c3ga_ben::setDelimiters(char startDelimiter, char endDelimiter) {
	if ((startDelimiter < 0) || (endDelimiter < 0)) return -1;
	m_startDelimiter = startDelimiter;
	m_endDelimiter = endDelimiter;
	return 0;
}

int c3ga_ben::setDefaults() {
	int err;
	removeAll();
	m_startDelimiter = m_endDelimiter = 0;
	if (err = addName("e1", c3gai::e1)) return err;
	if (err = addName("e2", c3gai::e2)) return err;
	if (err = addName("e3", c3gai::e3)) return err;
	if (err = addName("no", c3gai::no)) return err;
	if (err = addName("ni", c3gai::ni)) return err;
	return 0;
}


//Merging /usr/local/include/gaigen/gaigenhl.cpp into generated code:

// DO NOT TRY TO COMPILE THIS FILE DIRECTLY.
// IT IS MEANT TO BE INCLUDED BY GENERATED CODE!

/*
 *
 * Gaigen, Copyright (c) 2001-2004, University of Amsterdam
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *      * Redistributions of source code must retain the above copyright
 *        notice, this list of conditions and the following disclaimer.
 *      * Redistributions in binary form must reproduce the above copyright
 *        notice, this list of conditions and the following disclaimer in
 *        the documentation and/or other materials provided with the
 *        distribution.
 *      * Neither the name of the University of Amsterdam nor the names of its
 *        contributors may be used to endorse or promote products derived
 *        from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
 * CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
 * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 */


#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#ifdef GAIM_NAMESPACE
namespace CLASSNAME_NS {
#endif // GAIM_NAMESPACE

CLASSNAME::CLASSNAME() {

}
/*
CLASSNAME::CLASSNAME(GAIM_CLASSNAME &a) {
	copy(a);
}
*/
CLASSNAME::~CLASSNAME() {

}

GAIM_RETURN_TYPE CLASSNAME::operator=(const CLASSNAME &a) {
	copy(a);
	return *this;
}

GAIM_RETURN_TYPE CLASSNAME::operator=(GAIM_FLOAT f) {
	set(GRADE0, &f);
	return *this;
}

#ifdef GAIM_FUNCTION_FASTTEMPVAR
GAIM_RETURN_TYPE CLASSNAME::getTemp() {
	// gets a temporary variable (based on Stroustup (heaven help you if you write an expression which requires more than MV_MAX_TEMP temporaries))
	static int idx = 0;
	static CLASSNAME *temp = NULL;
	if (!temp) {
		int i;
		temp = new CLASSNAME[MV_MAX_TEMP];
		for (i = 0; i < MV_MAX_TEMP; i++) {
			temp[i].setUsage(0xf | (0x7 << 4));
			temp[i].setUsage(0);
		}
	}
//	printf("Temp idx = %d\n", idx);
	if (idx == MV_MAX_TEMP) idx = 0;
	return temp[idx++];
}
#endif // GAIM_FUNCTION_FASTTEMPVAR

#ifdef GAIM_FUNCTION_TAKEGRADE
GAIM_RETURN_TYPE CLASSNAME::grade(int g) const {
	GAIM_RETURN_VAR(result);
//	GAIM_RETURN_VAR(result);
	result.takeGrade(*this, g);
	return result;
}
#endif // GAIM_FUNCTION_TAKEGRADE


#ifdef GAIM_FUNCTION_REVERSE
GAIM_RETURN_TYPE CLASSNAME::operator~() const {
	GAIM_RETURN_VAR(result);
	((GAIM_CLASSNAME&)result).reverse(*this);
	return result;
}
#endif // GAIM_FUNCTION_REVERSE

#ifdef GAIM_FUNCTION_CLIFFORDCONJUGATE
GAIM_RETURN_TYPE CLASSNAME::operator--() const {
	GAIM_RETURN_VAR(result);
	((GAIM_CLASSNAME&)result).cliffordConjugate(*this);
	return result;
}
#endif // GAIM_FUNCTION_CLIFFORDCONJUGATE

#ifdef GAIM_FUNCTION_GRADEINVOLUTION
GAIM_RETURN_TYPE CLASSNAME::operator++() const {
	GAIM_RETURN_VAR(result);
	((GAIM_CLASSNAME&)result).gradeInvolution(*this);
	return result;
}
#endif // GAIM_FUNCTION_GRADEINVOLUTION

#ifdef GAIM_PRODUCT_GP
GAIM_RETURN_TYPE CLASSNAME::operator*=(const CLASSNAME &a) {
	CLASSNAME tmp;
	tmp.gp(*this, a);
	this->copy(tmp);
	return *this;
}
GAIM_RETURN_TYPE CLASSNAME::operator*=(GAIM_FLOAT a) {
	CLASSNAME tmp;
	tmp.op(a, *this);
	this->copy(tmp);
	return *this;
}
GAIM_RETURN_TYPE gp(const CLASSNAME &a, const CLASSNAME &b) {
	GAIM_RETURN_VAR(result);
	result.gp(a, b);
	return result;
}
GAIM_RETURN_TYPE gp(GAIM_FLOAT a, const CLASSNAME &b) {
	GAIM_RETURN_VAR(result);
	result.op(a, b);
	return result;
}

#define USE_NEW_EXP

#ifdef USE_OLD_EXP
GAIM_RETURN_TYPE CLASSNAME::exp(int order /*= 9*/) const {
	int i, div = 1;
	GAIM_RETURN_VAR(result);

	result.setScalar(1.0);
	if (order == 0) return result;

	CLASSNAME tmp(*this);

	for (i = 1; i < order; i++) {
		result += tmp * (GAIM_FLOAT)(1.0 / (GAIM_FLOAT)div);

		if (i < order-1) {
			div *= (i+1);
			tmp *= *this;
		}
	}

	return result;
}
#endif /* USE_OLD_EXP */

#ifdef USE_NEW_EXP
GAIM_RETURN_TYPE CLASSNAME::exp(int order /*= 9*/) const {
	/*
	Improved version of exp thanks to Robert Valkenburg & students
	*/
    int i;
    CLASSNAME result;

    result.setScalar(1.0);
    if (order == 0) {
        GAIM_RETURN_VAR(r);
        r = result;
        return r;
    }

    // scale by power of 2 so that its norm is < 1
    unsigned long max = (unsigned long)largestCoordinate();
    unsigned long scale=1;
    if (max > 1) scale <<= 1;
    while (max)
    {
        max >>= 1;
        scale <<= 1;
    }

    CLASSNAME scaled = (*this) / (GAIM_FLOAT)(scale);

    // taylor approximation
    CLASSNAME tmp;

    tmp.setScalar(1.0);
    for (i = 1; i < order; i++) {
        tmp = tmp*scaled/(GAIM_FLOAT)(i);
        result += tmp;
    }

    // undo scaling
    while (scale > 1)
    {
        result *= result;
        scale >>= 1;
    }
    GAIM_RETURN_VAR(r);
    r = result;
    return r;
}
#endif /* USE_NEW_EXP */


#ifndef GAIM_FUNCTION_FASTDUAL
GAIM_RETURN_TYPE CLASSNAME::dual() const {
	GAIM_RETURN_VAR(result);
	result.gp(*this, Ii);
	return result;
}
#endif // GAIM_FUNCTION_FASTDUAL

#endif // GAIM_PRODUCT_GP

#ifdef GAIM_PRODUCT_GP_EM
GAIM_RETURN_TYPE gpem (const CLASSNAME &a, const CLASSNAME &b) {
	GAIM_RETURN_VAR(result);
	result. GAIM_PRODUCT_GP_EM (a, b);
	return result;
}
GAIM_RETURN_TYPE gpem (GAIM_FLOAT a, const CLASSNAME &b) {
	GAIM_RETURN_VAR(result);
	result.op(a, b);
	return result;
}
#endif // GAIM_PRODUCT_GP_EM


#ifdef GAIM_FUNCTION_FASTDUAL
GAIM_RETURN_TYPE CLASSNAME::fastDual() const {
	GAIM_RETURN_VAR(result);
	((GAIM_CLASSNAME&)result).fastDual(*this);
	return result;
}
#endif // GAIM_FUNCTION_FASTDUAL


#ifdef GAIM_FUNCTION_VERSORINVERSE
GAIM_RETURN_TYPE CLASSNAME::versorInverse() const {
	GAIM_RETURN_VAR(result);
	result.versorInverse(*this);
	return result;
}
#endif
#ifdef GAIM_FUNCTION_LOUNESTOINVERSE
GAIM_RETURN_TYPE CLASSNAME::lounestoInverse() const {
	GAIM_RETURN_VAR(result);
	result.lounestoInverse(*this);
	return result;
}
#endif
#ifdef GAIM_FUNCTION_GENERALINVERSE
GAIM_RETURN_TYPE CLASSNAME::generalInverse() const {
	GAIM_RETURN_VAR(result);
	result.generalInverse(*this);
	return result;
}
#endif

#ifdef GAIM_PRODUCT_IGP
GAIM_RETURN_TYPE CLASSNAME::inverse() const {
	GAIM_RETURN_VAR(result);
	result.inverse(*this);
	return result;
}

GAIM_RETURN_TYPE CLASSNAME::operator/=(const CLASSNAME &a) {
	CLASSNAME tmp, tmp2;
	tmp2.inverse(a);
	tmp.gp(*this, tmp2);
	this->copy(tmp);
	return *this;
}
GAIM_RETURN_TYPE CLASSNAME::operator/=(GAIM_FLOAT a) {
	CLASSNAME tmp;
	tmp.op(1.0f / a, *this);
	this->copy(tmp);
	return *this;
}
#endif // GAIM_PRODUCT_IGP

#ifdef GAIM_PRODUCT_SCP
GAIM_RETURN_TYPE CLASSNAME::operator%=(const CLASSNAME &a) {
	CLASSNAME tmp;
	tmp.scp(*this, a);
	this->copy(tmp);
	return *this;
}
GAIM_RETURN_TYPE CLASSNAME::operator%=(GAIM_FLOAT a) {
	GAIM_FLOAT f = scalar() * a;
	setScalar(&f);
	return *this;
}
GAIM_RETURN_TYPE scp(const CLASSNAME &a, const CLASSNAME &b) {
	GAIM_RETURN_VAR(result);
	result.scp(a, b);
	return result;
}
GAIM_RETURN_TYPE scp(GAIM_FLOAT a, const CLASSNAME &b) {
	GAIM_RETURN_VAR(result);
	result.set(GRADE0, mulScalar(a, b.scalar()));
	return result;
}
#endif // GAIM_PRODUCT_SCP

#ifdef GAIM_PRODUCT_LCONT
GAIM_RETURN_TYPE lcont(const CLASSNAME &a, const CLASSNAME &b) {
	GAIM_RETURN_VAR(result);
	result.lcont(a, b);
	return result;
}
GAIM_RETURN_TYPE CLASSNAME::operator<<=(const CLASSNAME &a) {
	CLASSNAME tmp;
	tmp.lcont(*this, a);
	this->copy(tmp);
	return *this;
}
#endif // GAIM_PRODUCT_LCONT

#ifdef GAIM_PRODUCT_LCONT_EM
GAIM_RETURN_TYPE lcem(const CLASSNAME &a, const CLASSNAME &b) {
	GAIM_RETURN_VAR(result);
	result. GAIM_PRODUCT_LCONT_EM (a, b);
	return result;
}
#endif // GAIM_PRODUCT_LCONT_EM

#ifdef GAIM_PRODUCT_RCONT
GAIM_RETURN_TYPE rcont(const CLASSNAME &a, const CLASSNAME &b) {
	GAIM_RETURN_VAR(result);
	result.rcont(a, b);
	return result;
}
GAIM_RETURN_TYPE CLASSNAME::operator>>=(const CLASSNAME &a) {
	CLASSNAME tmp;
	tmp.rcont(*this, a);
	this->copy(tmp);
	return *this;
}
#endif // GAIM_PRODUCT_RCONT

#ifdef GAIM_PRODUCT_HIP
GAIM_RETURN_TYPE hip(const CLASSNAME &a, const CLASSNAME &b) {
	GAIM_RETURN_VAR(result);
	result.hip(a, b);
	return result;
}
GAIM_RETURN_TYPE hip(GAIM_FLOAT a, const CLASSNAME &b) {
	GAIM_RETURN_VAR(result);
	CLASSNAME _a(a);
	result.hip(_a, b);
	return result;
}
GAIM_RETURN_TYPE hip(const CLASSNAME &a, GAIM_FLOAT b) {
	GAIM_RETURN_VAR(result);
	CLASSNAME _b(b);
	result.hip(a, _b);
	return result;
}
#endif // GAIM_PRODUCT_HIP

#ifdef GAIM_PRODUCT_MHIP
GAIM_RETURN_TYPE mhip(const CLASSNAME &a, const CLASSNAME &b) { // GAIM_RETURN_TYPE used to read CLASSNAME & (modified 10-10-2002)
	GAIM_RETURN_VAR(result);
	result.mhip(a, b);
	return result;
}
GAIM_RETURN_TYPE mhip(GAIM_FLOAT a, const CLASSNAME &b) {
	GAIM_RETURN_VAR(result);
	CLASSNAME _a(a);
	result.mhip(_a, b);
	return result;
}
GAIM_RETURN_TYPE mhip(const CLASSNAME &a, GAIM_FLOAT b) {
	GAIM_RETURN_VAR(result);
	CLASSNAME _b(b);
	result.mhip(a, _b);
	return result;
}
#endif // GAIM_PRODUCT_MHIP


#ifdef GAIM_PRODUCT_OP
GAIM_RETURN_TYPE op(GAIM_FLOAT a, const CLASSNAME &b) {
	GAIM_RETURN_VAR(result);
	result.op(a, b);
	return result;
}
GAIM_RETURN_TYPE op(const CLASSNAME &a, const CLASSNAME &b) {
	GAIM_RETURN_VAR(result);
	result.op(a, b);
	return result;
}
GAIM_RETURN_TYPE CLASSNAME::operator^=(const CLASSNAME &a) {
	CLASSNAME tmp;
	tmp.op(*this, a);
	this->copy(tmp);
	return *this;
}
GAIM_RETURN_TYPE CLASSNAME::operator^=(GAIM_FLOAT a) {
	CLASSNAME tmp;
	tmp.op(a, *this);
	this->copy(tmp);
	return *this;
}
#endif // GAIM_PRODUCT_OP

#ifdef GAIM_FUNCTION_MEETJOIN
GAIM_RETURN_TYPE meet(const CLASSNAME &a, const CLASSNAME &b) {
	GAIM_RETURN_VAR(result);
	result.meet(a, b);
	return result;
}

GAIM_RETURN_TYPE join(const CLASSNAME &a, const CLASSNAME &b) {
	GAIM_RETURN_VAR(result);
	result.join(a, b);
	return result;
}

#endif // GAIM_FUNCTION_MEETJOIN


#ifdef GAIM_FUNCTION_ADD
GAIM_RETURN_TYPE add(const CLASSNAME &a, const CLASSNAME &b) {
	GAIM_RETURN_VAR(result);
	result.add(a, b);
	return result;
}
GAIM_RETURN_TYPE add(GAIM_FLOAT a, const CLASSNAME &b) {
	GAIM_RETURN_VAR(result);
	result.add(a, b);
	return result;
}
GAIM_RETURN_TYPE CLASSNAME::operator+=(const CLASSNAME &a) {
	CLASSNAME tmp;
	tmp.add(*this, a);
	this->copy(tmp);
	return *this;
}
GAIM_RETURN_TYPE CLASSNAME::operator+=(GAIM_FLOAT a) {
	CLASSNAME tmp;
	tmp.add(a, *this);
	this->copy(tmp);
	return *this;
}
#endif // GAIM_FUNCTION_ADD

#ifdef GAIM_FUNCTION_SUBSTRACT
GAIM_RETURN_TYPE sub(const CLASSNAME &a, const CLASSNAME &b) {
	GAIM_RETURN_VAR(result);
	result.sub(a, b);
	return result;
}
GAIM_RETURN_TYPE sub(GAIM_FLOAT a, const CLASSNAME &b) {
	GAIM_RETURN_VAR(result);
	result.sub(a, b);
	return result;
}
GAIM_RETURN_TYPE CLASSNAME::operator-=(const CLASSNAME &a) {
	CLASSNAME tmp;
	tmp.sub(*this, a);
	this->copy(tmp);
	return *this;
}
GAIM_RETURN_TYPE CLASSNAME::operator-=(GAIM_FLOAT a) {
	CLASSNAME tmp;
	tmp.add(a, *this);
	this->copy(tmp);
	return *this;
}
#endif // GAIM_FUNCTION_SUBSTRACT

#ifdef GAIM_FUNCTION_NEGATE
GAIM_RETURN_TYPE negate(const CLASSNAME &a) {
	GAIM_RETURN_VAR(result);
	((GAIM_CLASSNAME&)result).negate(a);
	return result;
}
#endif //GAIM_FUNCTION_NEGATE



#ifdef GAIM_FUNCTION_NORMALIZE
GAIM_RETURN_TYPE CLASSNAME::normal(int norm /* = 1 */) const {
	GAIM_RETURN_VAR(result);
	result.normalize(*this, norm);
	return result;
}
#endif // GAIM_FUNCTION_NORMALIZE


#ifdef GAIM_PRODUCT_OM
CLASSNAME_OM::CLASSNAME_OM(const CLASSNAME *vectorImages[3]) {
	initVectorImages(vectorImages);
}

CLASSNAME_OM::CLASSNAME_OM(const CLASSNAME &spinor) {
	initSpinor(spinor);
}


int CLASSNAME_OM::initSpinor(const CLASSNAME &spinor) {
	CLASSNAME si(spinor.inverse()), v, vi[GA_MAX_DIM];
	GAIM_FLOAT coordinates[GA_MAX_DIM];
	int i;

	memset(coordinates, 0, sizeof(GAIM_FLOAT) * GA_MAX_DIM);

	for (i = 0; i < CLASSNAME::dim; i++) {
		coordinates[i] = 1.0;
		if (i > 0) coordinates[i-1] = 0.0;
		v.setVector(coordinates);
		vi[i] = ((spinor * v) * si)(GRADE1);

	}
	return initVectorImages(vi);
}


GAIM_RETURN_TYPE om(const CLASSNAME_OM &om, const CLASSNAME &a) {
	GAIM_RETURN_VAR(result);

	result.om(a, om);

	return result;
}


#ifdef GAIM_NAMESPACE
}
#endif // GAIM_NAMESPACE


#endif // GAIM_PRODUCT_OM


