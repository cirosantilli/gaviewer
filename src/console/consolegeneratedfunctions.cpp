// Generated on Fri May 07 11:18:18 2010


/*

GAViewer console functions, generated by little 'codegen' tool,
included in the console directory.

${AFN} will be substituted for Algebra Full Name (e3ga, p3ga, etc)
${AFNC} will be substituted for Algebra Full Name Capital (E3GA, P3GA, etc)
${AFNFLC} will be substituted for Algebra Full Name First Letter Capital (E3ga, P3ga, etc)
${ASN} will be substituted for Algebra Short Name (e, p, etc)
*/

/*
To add a new function, edit the 'consolecodetemplates.txt' file,
regenerate the code using the codegen tool. 
The code for the new function consists of two parts:
-the function body (put that inside the functionBodies codeblock)
-the function description (put that inside the functionList codeblock)
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

#include <vector>
#include <utility>

#include "../state.h"
#include "../uistate.h"
#include "../mvint.h"
#include "../util.h"
#include "../object.h"
#include "../osdep.h"
#include "../geosphere.h"
#include "../mainwindow.h"
#include "../mt19937-2.h"
#include "console.h"
#include "consolefunction.h"
#include "consolegafile.h"
#include "consolescope.h"
#include "consolevariable.h"
#include "../glwindow.h"

static const char *sc_tempVarPrefix = "temporary console variable ";

namespace {
	inline double asinhScalar(double x) {
		return log(x + sqrt(x*x+1));
	}
}


// ********************************* e3ga SCALAR *********************************
consoleVariable *cf_e3ga_scalar(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", e3ga(arg[0]->e().scalar()));
}

// ********************************* e3ga DUAL *********************************
consoleVariable *cf_e3ga_dual(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", arg[0]->e().dual());
}

// ********************************* e3ga DUAL2 *********************************
consoleVariable *cf_e3ga_dual2(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", arg[0]->e() << arg[1]->e().inverse());
}

// ********************************* e3ga REVERSE *********************************
consoleVariable *cf_e3ga_reverse(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", arg[0]->e().reverse());
}

// ********************************* e3ga CLIFFORD_CONJUGATE *********************************
consoleVariable *cf_e3ga_clifford_conjugate(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", arg[0]->e().cliffordConjugate());
}

// ********************************* e3ga GRADE INVOLUTION *********************************
consoleVariable *cf_e3ga_grade_involution(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", arg[0]->e().gradeInvolution());
}

// ********************************* e3ga INVERSE *********************************
consoleVariable *cf_e3ga_inverse(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", arg[0]->e().inverse());
}

// ********************************* e3ga GENERAL INVERSE *********************************
consoleVariable *cf_e3ga_general_inverse(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", arg[0]->e().generalInverse());
}

// ********************************* e3ga NEGATE *********************************
consoleVariable *cf_e3ga_negate(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", arg[0]->e().negate());
}

// ********************************* e3ga GP *********************************
consoleVariable *cf_e3ga_gp(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", gp(arg[0]->e(), arg[1]->e()));
}

// ********************************* e3ga IGP *********************************
consoleVariable *cf_e3ga_igp(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", igp(arg[0]->e(), arg[1]->e()));
}

// ********************************* e3ga OP *********************************
consoleVariable *cf_e3ga_op(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", op(arg[0]->e(), arg[1]->e()));
}

// ********************************* e3ga HIP *********************************
consoleVariable *cf_e3ga_hip(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", hip(arg[0]->e(), arg[1]->e()));
}

// ********************************* e3ga MHIP *********************************
consoleVariable *cf_e3ga_mhip(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", mhip(arg[0]->e(), arg[1]->e()));
}

// ********************************* e3ga LCONT *********************************
consoleVariable *cf_e3ga_lcont(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", lcont(arg[0]->e(), arg[1]->e()));
}

// ********************************* e3ga GPEM *********************************
consoleVariable *cf_e3ga_gpem(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", gpem(arg[0]->e(), arg[1]->e()));
}

// ********************************* e3ga LCEM *********************************
consoleVariable *cf_e3ga_lcem(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", lcem(arg[0]->e(), arg[1]->e()));
}

// ********************************* e3ga RCONT *********************************
consoleVariable *cf_e3ga_rcont(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", rcont(arg[0]->e(), arg[1]->e()));
}

// ********************************* e3ga SCP *********************************
consoleVariable *cf_e3ga_scp(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", scp(arg[0]->e(), arg[1]->e()));
}

// ********************************* e3ga ADD *********************************
consoleVariable *cf_e3ga_add(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", add(arg[0]->e(), arg[1]->e()));
}

// ********************************* e3ga SUB *********************************
consoleVariable *cf_e3ga_sub(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", sub(arg[0]->e(), arg[1]->e()));
}

// ********************************* e3ga MEET *********************************
consoleVariable *cf_e3ga_meet(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", meet(arg[0]->e(), arg[1]->e()));
}

// ********************************* e3ga JOIN *********************************
consoleVariable *cf_e3ga_join(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", join(arg[0]->e(), arg[1]->e()));
}

// ********************************* e3ga CP *********************************
consoleVariable *cf_e3ga_cp(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", 
	op(0.5, sub(gp(arg[0]->e(), arg[1]->e()),
	gp(arg[1]->e(), arg[0]->e()))));
}

// ********************************* e3ga PRINT *********************************
consoleVariable *cf_e3ga_print(consoleScope *s, consoleVariable *arg[]) {
/*	cprintf("%s = %s\n", 
		(arg[0]->name().find(std::string(sc_tempVarPrefix)) == 0) ? "ans" : arg[0]->name().c_str(), 
		arg[0]->e().string());
		
	return arg[0];*/
	std::string name = (arg[0]->name().find(std::string(sc_tempVarPrefix)) == 0) ? std::string("ans") : arg[0]->name();
	std::string val = arg[0]->e().string();
	char buf[2048];
	sprintf(buf, "%s = %s\n", name.c_str(), val.c_str());
	cprintf(buf);
	return arg[0];
}

consoleVariable *cf_e3ga_print_prec(consoleScope *s, consoleVariable *arg[]) {
	const char *name = arg[0]->name().c_str();
	char precstr[256];
	sprintf(precstr, "%c%s", '%', arg[1]->name().c_str());
	/*
	cprintf("%s = %s\n", 
		(strstr(name, sc_tempVarPrefix) == name) ? "ans" : name, 
		arg[0]->e().string(precstr));*/
	char buf[2048];
	sprintf(buf, "%s = %s\n", (strstr(name, sc_tempVarPrefix) == name) ? "ans" : name, 
		arg[0]->e().string(precstr));
	cprintf(buf);

	return arg[0];
}

// ********************************* e3ga ASSIGN *********************************
consoleVariable *cf_e3ga_assign(consoleScope *s, consoleVariable *arg[]) {
	consoleVariable *cv = s->assignVariable(arg[0], arg[1]);
	cv->name(arg[0]->name());
	return cv;
}

// ********************************* e3ga GRADE *********************************
consoleVariable *cf_e3ga_grade(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", arg[0]->e()(1 << ((int)arg[1]->e().scalar())));
}

// ********************************* e3ga GRADE *********************************
consoleVariable *cf_e3ga_grade_nb(consoleScope *s, consoleVariable *arg[]) {
	int grade, type = arg[0]->e().mvType(&grade); // epsilon?
	if (type == GA_BLADE)
		grade = (int)(log((double)grade) / log((double)2) + 0.45);
	else grade = -1;

	return new consoleVariable("",  e3ga((GAIM_FLOAT)grade));
}

// ********************************* e3ga VERSOR PARITY *********************************
consoleVariable *cf_e3ga_versor_parity(consoleScope *s, consoleVariable *arg[]) {
	int grade, type = arg[0]->e().mvType(&grade); // epsilon?
	if ((type == GA_BLADE) || (type == GA_VERSOR))
		grade = arg[0]->e().largestGrade() & 1;
	else grade = -1;

	return new consoleVariable("",  e3ga((GAIM_FLOAT)grade));
}

// ********************************* e3ga NORM *********************************
consoleVariable *cf_e3ga_norm(consoleScope *s, consoleVariable *arg[]) {
	GAIM_FLOAT n = arg[0]->e().norm_b();
	n = sqrt(fabs(n)) * ((n < 0) ? -1.0 : 1.0);
	return new consoleVariable("", e3ga(n));
}

// ********************************* e3ga NORM_A *********************************
consoleVariable *cf_e3ga_norm_2(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", e3ga(arg[0]->e().norm_a()));
}
// ********************************* e3ga NORM_B *********************************
consoleVariable *cf_e3ga_norm_r(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", e3ga(arg[0]->e().norm_b()));
}

// ********************************* e3ga NORMALIZE *********************************
consoleVariable *cf_e3ga_normalize(consoleScope *s, consoleVariable *arg[]) {
	GAIM_FLOAT n = sqrt(fabs(arg[0]->e().norm_b()));
	return new consoleVariable("", e3ga(arg[0]->e() * ((n == 0.0) ? 0.0 : (1.0 / n))));
}

// ********************************* e3ga SQRT *********************************
consoleVariable *cf_e3ga_sqrt(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", e3ga(sqrt(arg[0]->e().scalar())));
}

// ********************************* e3ga ABS *********************************
consoleVariable *cf_e3ga_abs(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", e3ga(fabs(arg[0]->e().scalar())));
}

// ********************************* e3ga TAN *********************************
consoleVariable *cf_e3ga_tan(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", e3ga(tan(arg[0]->e().scalar())));
}

// ********************************* e3ga COS *********************************
consoleVariable *cf_e3ga_cos(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", e3ga(cos(arg[0]->e().scalar())));
}

// ********************************* e3ga SIN *********************************
consoleVariable *cf_e3ga_sin(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", e3ga(sin(arg[0]->e().scalar())));
}

// ********************************* e3ga COSH *********************************
consoleVariable *cf_e3ga_cosh(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", e3ga(cosh(arg[0]->e().scalar())));
}

// ********************************* e3ga SINH *********************************
consoleVariable *cf_e3ga_sinh(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", e3ga(sinh(arg[0]->e().scalar())));
}

// ********************************* e3ga ACOSH *********************************
consoleVariable *cf_e3ga_acosh(consoleScope *s, consoleVariable *arg[]) {
	double x = arg[0]->e().scalar();
	double value = (x >= 1) ? log(x + sqrt(x*x-1)) : 0.0;
	return new consoleVariable("", e3ga(value));
}


// ********************************* e3ga ASINH *********************************
consoleVariable *cf_e3ga_asinh(consoleScope *s, consoleVariable *arg[]) {
	e3ga B = arg[0]->e().grade(GRADE2);
	if (B.norm_a() != 0.0) {
		double B2 = gp(B, B).scalar();
		if (B2 < 0.0) {
			double sqrtMB2 = sqrt(-B2);
			return new consoleVariable("", op(asin(sqrtMB2) / sqrtMB2, B));
		}
		else if (B2 == 0.0) {
			return new consoleVariable("", B);
		}
		else {
			double sqrtB2 = sqrt(B2);
			return new consoleVariable("", op(asinhScalar(sqrtB2) / sqrtB2, B));
		}
	}
	else {
		double x = arg[0]->e().scalar();
		double value = asinhScalar(x);
		return new consoleVariable("", e3ga(value));
	}
	
}

// ********************************* e3ga ATAN *********************************
consoleVariable *cf_e3ga_atan(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", e3ga(atan(arg[0]->e().scalar())));
}

// ********************************* e3ga ATAN2 *********************************
consoleVariable *cf_e3ga_atan2(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", e3ga(atan2(arg[0]->e().scalar(), arg[1]->e().scalar())));
}

// ********************************* e3ga MAX *********************************
consoleVariable *cf_e3ga_max(consoleScope *s, consoleVariable *arg[]) {
	GAIM_FLOAT val = (arg[0]->scalar() > arg[1]->scalar()) 
		? arg[0]->scalar() : arg[1]->scalar();
	return new consoleVariable("", e3ga(val));
}

// ********************************* e3ga MIN *********************************
consoleVariable *cf_e3ga_min(consoleScope *s, consoleVariable *arg[]) {
	GAIM_FLOAT val = (arg[0]->scalar() < arg[1]->scalar()) 
		? arg[0]->scalar() : arg[1]->scalar();
	return new consoleVariable("", e3ga(val));
}

// ********************************* e3ga ACOS *********************************
consoleVariable *cf_e3ga_acos(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", e3ga(acos(arg[0]->e().scalar())));
}

// ********************************* e3ga ASIN *********************************
consoleVariable *cf_e3ga_asin(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", e3ga(asin(arg[0]->e().scalar())));
}

// ********************************* e3ga SINC *********************************
consoleVariable *cf_e3ga_sinc(consoleScope *s, consoleVariable *arg[]) {
	double x = arg[0]->e().scalar();
	if (x == 0.0) return new consoleVariable("", e3ga(1.0));
	else return new consoleVariable("", e3ga(sin(x)/x));
}

// ********************************* e3ga EXP *********************************
consoleVariable *cf_e3ga_exp(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", e3ga(arg[0]->e().exp(12)));
}

// ********************************* e3ga LOG *********************************
consoleVariable *cf_e3ga_log(consoleScope *s, consoleVariable *arg[]) {
	double x = arg[0]->e().scalar();
	if (x == 0.0)	return new consoleVariable("", e3ga(0));
	else if (x > 0.0) return new consoleVariable("", e3ga(log(x)));
	else return new consoleVariable("", e3ga(M_PI * (e3ga::e1 ^ e3ga::e2) + log(-x)));
}

// ********************************* e3ga SCALAR_POW *********************************
consoleVariable *cf_e3ga_scalar_pow(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", e3ga(pow(arg[0]->e().scalar(), arg[1]->e().scalar())));
}

// ********************************* e3ga RANDOM SEED *********************************
consoleVariable *cf_e3ga_randSeed(consoleScope *s, consoleVariable *arg[]) {
	double _seed = arg[0]->e().scalar();
	unsigned long seed = (unsigned long )(_seed * 32768.0);
	sgenrand(seed);
		
	return new consoleVariable("", e3ga(0.0));
}


// ********************************* e3ga RANDOM GAUSS NUMBER *********************************
consoleVariable *cf_e3ga_randGauss(consoleScope *s, consoleVariable *arg[]) {
	double mean = arg[0]->e().scalar();
	double variance = arg[1]->e().scalar();
	return new consoleVariable("", e3ga(gaussNoise(mean, variance)));
}

// ********************************* e3ga POW *********************************
consoleVariable *cf_e3ga_pow(consoleScope *s, consoleVariable *arg[]) {
	int n = (int)(arg[1]->e().scalar() + 0.5), i;
	e3ga r(1.0);
	for (i = 0; i < n; i++)
		r = r * arg[0]->e();

	return new consoleVariable("", r);
}

// ********************************* e3ga VERSOR PRODUCT *********************************
consoleVariable *cf_e3ga_versorProduct(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", e3ga(arg[0]->e() * arg[1]->e() * arg[0]->e().inverse()));
}

// ********************************* e3ga INVERSE VERSOR PRODUCT *********************************
consoleVariable *cf_e3ga_inverseVersorProduct(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", e3ga(arg[0]->e().inverse() * arg[1]->e() * arg[0]->e()));
}

// ********************************* e3ga mierenneuk VERSOR PRODUCT *********************************
consoleVariable *cf_e3ga_MNversorProduct(consoleScope *s, consoleVariable *arg[]) {
	e3ga v = arg[0]->e();
	e3ga o = arg[1]->e();
	
	int vgrade = v.largestGrade() & 1;

	if (vgrade)	 return new consoleVariable("", e3ga(v * o.gradeInvolution() * v.inverse()));
	else return new consoleVariable("", e3ga(v * o * v.inverse()));
}

// ********************************* e3ga mierenneuk INVERSE VERSOR PRODUCT *********************************
consoleVariable *cf_e3ga_MNinverseVersorProduct(consoleScope *s, consoleVariable *arg[]) {
	e3ga v = arg[0]->e();
	e3ga o = arg[1]->e();
	
	int vgrade = v.largestGrade() & 1;

	if (vgrade)	 return new consoleVariable("", e3ga(v.inverse() * o.gradeInvolution() * v));
	else return new consoleVariable("", e3ga(v.inverse() * o * v));
}


// ********************************* e3ga PROJECT *********************************
consoleVariable *cf_e3ga_project(consoleScope *s, consoleVariable *arg[]) {
	e3ga tmp;
	tmp.project(arg[1]->e(), arg[0]->e());
	return new consoleVariable("", tmp);
}

// ********************************* e3ga reject *********************************
consoleVariable *cf_e3ga_reject(consoleScope *s, consoleVariable *arg[]) {
	e3ga tmp;
	tmp.reject(arg[1]->e(), arg[0]->e());
	return new consoleVariable("", tmp);
}

// ********************************* e3ga factor *********************************
consoleVariable *cf_e3ga_factor(consoleScope *s, consoleVariable *arg[]) {
	e3ga tmp[5];
	arg[0]->e().factor(tmp);

	int f = (int)(arg[1]->e().scalar()) - 1;
	if (f > 4) f = 4;
	else if (f < 0) f = 0;

	return new consoleVariable("", tmp[f]);
}

// ********************************* e3ga set_factor *********************************
consoleVariable *cf_e3ga_set_factor(consoleScope *s, consoleVariable *arg[]) {
	int idx = (int)arg[0]->scalar();
	g_state->setE3gaFactor(arg[1]->e(), idx);
	return arg[1];
}

// ********************************* e3ga equal *********************************
consoleVariable *cf_e3ga_equal(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", e3ga((arg[0]->e() - arg[1]->e()).norm_a() == 0.0));
}

// ********************************* e3ga ne *********************************
consoleVariable *cf_e3ga_ne(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", e3ga((arg[0]->e() - arg[1]->e()).norm_a() != 0.0));
}

// ********************************* e3ga less *********************************
consoleVariable *cf_e3ga_less(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", e3ga(arg[0]->e().scalar() < arg[1]->e().scalar()));
}
// ********************************* e3ga greater *********************************
consoleVariable *cf_e3ga_greater(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", e3ga(arg[0]->e().scalar() > arg[1]->e().scalar()));
}
// ********************************* e3ga le *********************************
consoleVariable *cf_e3ga_le(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", e3ga(arg[0]->e().scalar() <= arg[1]->e().scalar()));
}
// ********************************* e3ga ge *********************************
consoleVariable *cf_e3ga_ge(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", e3ga(arg[0]->e().scalar() >= arg[1]->e().scalar()));
}

// ********************************* e3ga and *********************************
consoleVariable *cf_e3ga_and(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", e3ga(((arg[0]->e().norm_a() != 0.0) && (arg[1]->e().norm_a() != 0.0))));
}
// ********************************* e3ga or *********************************
consoleVariable *cf_e3ga_or(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", e3ga(((arg[0]->e().norm_a() != 0.0) || (arg[1]->e().norm_a() != 0.0))));
}

// ********************************* e3ga not *********************************
consoleVariable *cf_e3ga_not(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", e3ga(arg[0]->e().norm_a() == 0.0));
}


// ********************************* p3ga SCALAR *********************************
consoleVariable *cf_p3ga_scalar(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", p3ga(arg[0]->p().scalar()));
}

// ********************************* p3ga DUAL *********************************
consoleVariable *cf_p3ga_dual(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", arg[0]->p().dual());
}

// ********************************* p3ga DUAL2 *********************************
consoleVariable *cf_p3ga_dual2(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", arg[0]->p() << arg[1]->p().inverse());
}

// ********************************* p3ga REVERSE *********************************
consoleVariable *cf_p3ga_reverse(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", arg[0]->p().reverse());
}

// ********************************* p3ga CLIFFORD_CONJUGATE *********************************
consoleVariable *cf_p3ga_clifford_conjugate(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", arg[0]->p().cliffordConjugate());
}

// ********************************* p3ga GRADE INVOLUTION *********************************
consoleVariable *cf_p3ga_grade_involution(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", arg[0]->p().gradeInvolution());
}

// ********************************* p3ga INVERSE *********************************
consoleVariable *cf_p3ga_inverse(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", arg[0]->p().inverse());
}

// ********************************* p3ga GENERAL INVERSE *********************************
consoleVariable *cf_p3ga_general_inverse(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", arg[0]->p().generalInverse());
}

// ********************************* p3ga NEGATE *********************************
consoleVariable *cf_p3ga_negate(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", arg[0]->p().negate());
}

// ********************************* p3ga GP *********************************
consoleVariable *cf_p3ga_gp(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", gp(arg[0]->p(), arg[1]->p()));
}

// ********************************* p3ga IGP *********************************
consoleVariable *cf_p3ga_igp(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", igp(arg[0]->p(), arg[1]->p()));
}

// ********************************* p3ga OP *********************************
consoleVariable *cf_p3ga_op(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", op(arg[0]->p(), arg[1]->p()));
}

// ********************************* p3ga HIP *********************************
consoleVariable *cf_p3ga_hip(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", hip(arg[0]->p(), arg[1]->p()));
}

// ********************************* p3ga MHIP *********************************
consoleVariable *cf_p3ga_mhip(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", mhip(arg[0]->p(), arg[1]->p()));
}

// ********************************* p3ga LCONT *********************************
consoleVariable *cf_p3ga_lcont(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", lcont(arg[0]->p(), arg[1]->p()));
}

// ********************************* p3ga GPEM *********************************
consoleVariable *cf_p3ga_gpem(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", gpem(arg[0]->p(), arg[1]->p()));
}

// ********************************* p3ga LCEM *********************************
consoleVariable *cf_p3ga_lcem(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", lcem(arg[0]->p(), arg[1]->p()));
}

// ********************************* p3ga RCONT *********************************
consoleVariable *cf_p3ga_rcont(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", rcont(arg[0]->p(), arg[1]->p()));
}

// ********************************* p3ga SCP *********************************
consoleVariable *cf_p3ga_scp(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", scp(arg[0]->p(), arg[1]->p()));
}

// ********************************* p3ga ADD *********************************
consoleVariable *cf_p3ga_add(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", add(arg[0]->p(), arg[1]->p()));
}

// ********************************* p3ga SUB *********************************
consoleVariable *cf_p3ga_sub(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", sub(arg[0]->p(), arg[1]->p()));
}

// ********************************* p3ga MEET *********************************
consoleVariable *cf_p3ga_meet(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", meet(arg[0]->p(), arg[1]->p()));
}

// ********************************* p3ga JOIN *********************************
consoleVariable *cf_p3ga_join(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", join(arg[0]->p(), arg[1]->p()));
}

// ********************************* p3ga CP *********************************
consoleVariable *cf_p3ga_cp(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", 
	op(0.5, sub(gp(arg[0]->p(), arg[1]->p()),
	gp(arg[1]->p(), arg[0]->p()))));
}

// ********************************* p3ga PRINT *********************************
consoleVariable *cf_p3ga_print(consoleScope *s, consoleVariable *arg[]) {
/*	cprintf("%s = %s\n", 
		(arg[0]->name().find(std::string(sc_tempVarPrefix)) == 0) ? "ans" : arg[0]->name().c_str(), 
		arg[0]->p().string());
		
	return arg[0];*/
	std::string name = (arg[0]->name().find(std::string(sc_tempVarPrefix)) == 0) ? std::string("ans") : arg[0]->name();
	std::string val = arg[0]->p().string();
	char buf[2048];
	sprintf(buf, "%s = %s\n", name.c_str(), val.c_str());
	cprintf(buf);
	return arg[0];
}

consoleVariable *cf_p3ga_print_prec(consoleScope *s, consoleVariable *arg[]) {
	const char *name = arg[0]->name().c_str();
	char precstr[256];
	sprintf(precstr, "%c%s", '%', arg[1]->name().c_str());
	/*
	cprintf("%s = %s\n", 
		(strstr(name, sc_tempVarPrefix) == name) ? "ans" : name, 
		arg[0]->p().string(precstr));*/
	char buf[2048];
	sprintf(buf, "%s = %s\n", (strstr(name, sc_tempVarPrefix) == name) ? "ans" : name, 
		arg[0]->p().string(precstr));
	cprintf(buf);

	return arg[0];
}

// ********************************* p3ga ASSIGN *********************************
consoleVariable *cf_p3ga_assign(consoleScope *s, consoleVariable *arg[]) {
	consoleVariable *cv = s->assignVariable(arg[0], arg[1]);
	cv->name(arg[0]->name());
	return cv;
}

// ********************************* p3ga GRADE *********************************
consoleVariable *cf_p3ga_grade(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", arg[0]->p()(1 << ((int)arg[1]->p().scalar())));
}

// ********************************* p3ga GRADE *********************************
consoleVariable *cf_p3ga_grade_nb(consoleScope *s, consoleVariable *arg[]) {
	int grade, type = arg[0]->p().mvType(&grade); // epsilon?
	if (type == GA_BLADE)
		grade = (int)(log((double)grade) / log((double)2) + 0.45);
	else grade = -1;

	return new consoleVariable("",  p3ga((GAIM_FLOAT)grade));
}

// ********************************* p3ga VERSOR PARITY *********************************
consoleVariable *cf_p3ga_versor_parity(consoleScope *s, consoleVariable *arg[]) {
	int grade, type = arg[0]->p().mvType(&grade); // epsilon?
	if ((type == GA_BLADE) || (type == GA_VERSOR))
		grade = arg[0]->p().largestGrade() & 1;
	else grade = -1;

	return new consoleVariable("",  p3ga((GAIM_FLOAT)grade));
}

// ********************************* p3ga NORM *********************************
consoleVariable *cf_p3ga_norm(consoleScope *s, consoleVariable *arg[]) {
	GAIM_FLOAT n = arg[0]->p().norm_b();
	n = sqrt(fabs(n)) * ((n < 0) ? -1.0 : 1.0);
	return new consoleVariable("", p3ga(n));
}

// ********************************* p3ga NORM_A *********************************
consoleVariable *cf_p3ga_norm_2(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", p3ga(arg[0]->p().norm_a()));
}
// ********************************* p3ga NORM_B *********************************
consoleVariable *cf_p3ga_norm_r(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", p3ga(arg[0]->p().norm_b()));
}

// ********************************* p3ga NORMALIZE *********************************
consoleVariable *cf_p3ga_normalize(consoleScope *s, consoleVariable *arg[]) {
	GAIM_FLOAT n = sqrt(fabs(arg[0]->p().norm_b()));
	return new consoleVariable("", p3ga(arg[0]->p() * ((n == 0.0) ? 0.0 : (1.0 / n))));
}

// ********************************* p3ga SQRT *********************************
consoleVariable *cf_p3ga_sqrt(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", p3ga(sqrt(arg[0]->p().scalar())));
}

// ********************************* p3ga ABS *********************************
consoleVariable *cf_p3ga_abs(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", p3ga(fabs(arg[0]->p().scalar())));
}

// ********************************* p3ga TAN *********************************
consoleVariable *cf_p3ga_tan(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", p3ga(tan(arg[0]->p().scalar())));
}

// ********************************* p3ga COS *********************************
consoleVariable *cf_p3ga_cos(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", p3ga(cos(arg[0]->p().scalar())));
}

// ********************************* p3ga SIN *********************************
consoleVariable *cf_p3ga_sin(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", p3ga(sin(arg[0]->p().scalar())));
}

// ********************************* p3ga COSH *********************************
consoleVariable *cf_p3ga_cosh(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", p3ga(cosh(arg[0]->p().scalar())));
}

// ********************************* p3ga SINH *********************************
consoleVariable *cf_p3ga_sinh(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", p3ga(sinh(arg[0]->p().scalar())));
}

// ********************************* p3ga ACOSH *********************************
consoleVariable *cf_p3ga_acosh(consoleScope *s, consoleVariable *arg[]) {
	double x = arg[0]->p().scalar();
	double value = (x >= 1) ? log(x + sqrt(x*x-1)) : 0.0;
	return new consoleVariable("", p3ga(value));
}


// ********************************* p3ga ASINH *********************************
consoleVariable *cf_p3ga_asinh(consoleScope *s, consoleVariable *arg[]) {
	p3ga B = arg[0]->p().grade(GRADE2);
	if (B.norm_a() != 0.0) {
		double B2 = gp(B, B).scalar();
		if (B2 < 0.0) {
			double sqrtMB2 = sqrt(-B2);
			return new consoleVariable("", op(asin(sqrtMB2) / sqrtMB2, B));
		}
		else if (B2 == 0.0) {
			return new consoleVariable("", B);
		}
		else {
			double sqrtB2 = sqrt(B2);
			return new consoleVariable("", op(asinhScalar(sqrtB2) / sqrtB2, B));
		}
	}
	else {
		double x = arg[0]->p().scalar();
		double value = asinhScalar(x);
		return new consoleVariable("", p3ga(value));
	}
	
}

// ********************************* p3ga ATAN *********************************
consoleVariable *cf_p3ga_atan(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", p3ga(atan(arg[0]->p().scalar())));
}

// ********************************* p3ga ATAN2 *********************************
consoleVariable *cf_p3ga_atan2(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", p3ga(atan2(arg[0]->p().scalar(), arg[1]->p().scalar())));
}

// ********************************* p3ga MAX *********************************
consoleVariable *cf_p3ga_max(consoleScope *s, consoleVariable *arg[]) {
	GAIM_FLOAT val = (arg[0]->scalar() > arg[1]->scalar()) 
		? arg[0]->scalar() : arg[1]->scalar();
	return new consoleVariable("", p3ga(val));
}

// ********************************* p3ga MIN *********************************
consoleVariable *cf_p3ga_min(consoleScope *s, consoleVariable *arg[]) {
	GAIM_FLOAT val = (arg[0]->scalar() < arg[1]->scalar()) 
		? arg[0]->scalar() : arg[1]->scalar();
	return new consoleVariable("", p3ga(val));
}

// ********************************* p3ga ACOS *********************************
consoleVariable *cf_p3ga_acos(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", p3ga(acos(arg[0]->p().scalar())));
}

// ********************************* p3ga ASIN *********************************
consoleVariable *cf_p3ga_asin(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", p3ga(asin(arg[0]->p().scalar())));
}

// ********************************* p3ga SINC *********************************
consoleVariable *cf_p3ga_sinc(consoleScope *s, consoleVariable *arg[]) {
	double x = arg[0]->p().scalar();
	if (x == 0.0) return new consoleVariable("", p3ga(1.0));
	else return new consoleVariable("", p3ga(sin(x)/x));
}

// ********************************* p3ga EXP *********************************
consoleVariable *cf_p3ga_exp(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", p3ga(arg[0]->p().exp(12)));
}

// ********************************* p3ga LOG *********************************
consoleVariable *cf_p3ga_log(consoleScope *s, consoleVariable *arg[]) {
	double x = arg[0]->p().scalar();
	if (x == 0.0)	return new consoleVariable("", p3ga(0));
	else if (x > 0.0) return new consoleVariable("", p3ga(log(x)));
	else return new consoleVariable("", p3ga(M_PI * (p3ga::e1 ^ p3ga::e2) + log(-x)));
}

// ********************************* p3ga SCALAR_POW *********************************
consoleVariable *cf_p3ga_scalar_pow(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", p3ga(pow(arg[0]->p().scalar(), arg[1]->p().scalar())));
}

// ********************************* p3ga RANDOM SEED *********************************
consoleVariable *cf_p3ga_randSeed(consoleScope *s, consoleVariable *arg[]) {
	double _seed = arg[0]->p().scalar();
	unsigned long seed = (unsigned long )(_seed * 32768.0);
	sgenrand(seed);
		
	return new consoleVariable("", p3ga(0.0));
}


// ********************************* p3ga RANDOM GAUSS NUMBER *********************************
consoleVariable *cf_p3ga_randGauss(consoleScope *s, consoleVariable *arg[]) {
	double mean = arg[0]->p().scalar();
	double variance = arg[1]->p().scalar();
	return new consoleVariable("", p3ga(gaussNoise(mean, variance)));
}

// ********************************* p3ga POW *********************************
consoleVariable *cf_p3ga_pow(consoleScope *s, consoleVariable *arg[]) {
	int n = (int)(arg[1]->p().scalar() + 0.5), i;
	p3ga r(1.0);
	for (i = 0; i < n; i++)
		r = r * arg[0]->p();

	return new consoleVariable("", r);
}

// ********************************* p3ga VERSOR PRODUCT *********************************
consoleVariable *cf_p3ga_versorProduct(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", p3ga(arg[0]->p() * arg[1]->p() * arg[0]->p().inverse()));
}

// ********************************* p3ga INVERSE VERSOR PRODUCT *********************************
consoleVariable *cf_p3ga_inverseVersorProduct(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", p3ga(arg[0]->p().inverse() * arg[1]->p() * arg[0]->p()));
}

// ********************************* p3ga mierenneuk VERSOR PRODUCT *********************************
consoleVariable *cf_p3ga_MNversorProduct(consoleScope *s, consoleVariable *arg[]) {
	p3ga v = arg[0]->p();
	p3ga o = arg[1]->p();
	
	int vgrade = v.largestGrade() & 1;

	if (vgrade)	 return new consoleVariable("", p3ga(v * o.gradeInvolution() * v.inverse()));
	else return new consoleVariable("", p3ga(v * o * v.inverse()));
}

// ********************************* p3ga mierenneuk INVERSE VERSOR PRODUCT *********************************
consoleVariable *cf_p3ga_MNinverseVersorProduct(consoleScope *s, consoleVariable *arg[]) {
	p3ga v = arg[0]->p();
	p3ga o = arg[1]->p();
	
	int vgrade = v.largestGrade() & 1;

	if (vgrade)	 return new consoleVariable("", p3ga(v.inverse() * o.gradeInvolution() * v));
	else return new consoleVariable("", p3ga(v.inverse() * o * v));
}


// ********************************* p3ga PROJECT *********************************
consoleVariable *cf_p3ga_project(consoleScope *s, consoleVariable *arg[]) {
	p3ga tmp;
	tmp.project(arg[1]->p(), arg[0]->p());
	return new consoleVariable("", tmp);
}

// ********************************* p3ga reject *********************************
consoleVariable *cf_p3ga_reject(consoleScope *s, consoleVariable *arg[]) {
	p3ga tmp;
	tmp.reject(arg[1]->p(), arg[0]->p());
	return new consoleVariable("", tmp);
}

// ********************************* p3ga factor *********************************
consoleVariable *cf_p3ga_factor(consoleScope *s, consoleVariable *arg[]) {
	p3ga tmp[5];
	arg[0]->p().factor(tmp);

	int f = (int)(arg[1]->p().scalar()) - 1;
	if (f > 4) f = 4;
	else if (f < 0) f = 0;

	return new consoleVariable("", tmp[f]);
}

// ********************************* p3ga set_factor *********************************
consoleVariable *cf_p3ga_set_factor(consoleScope *s, consoleVariable *arg[]) {
	int idx = (int)arg[0]->scalar();
	g_state->setP3gaFactor(arg[1]->p(), idx);
	return arg[1];
}

// ********************************* p3ga equal *********************************
consoleVariable *cf_p3ga_equal(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", p3ga((arg[0]->p() - arg[1]->p()).norm_a() == 0.0));
}

// ********************************* p3ga ne *********************************
consoleVariable *cf_p3ga_ne(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", p3ga((arg[0]->p() - arg[1]->p()).norm_a() != 0.0));
}

// ********************************* p3ga less *********************************
consoleVariable *cf_p3ga_less(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", p3ga(arg[0]->p().scalar() < arg[1]->p().scalar()));
}
// ********************************* p3ga greater *********************************
consoleVariable *cf_p3ga_greater(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", p3ga(arg[0]->p().scalar() > arg[1]->p().scalar()));
}
// ********************************* p3ga le *********************************
consoleVariable *cf_p3ga_le(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", p3ga(arg[0]->p().scalar() <= arg[1]->p().scalar()));
}
// ********************************* p3ga ge *********************************
consoleVariable *cf_p3ga_ge(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", p3ga(arg[0]->p().scalar() >= arg[1]->p().scalar()));
}

// ********************************* p3ga and *********************************
consoleVariable *cf_p3ga_and(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", p3ga(((arg[0]->p().norm_a() != 0.0) && (arg[1]->p().norm_a() != 0.0))));
}
// ********************************* p3ga or *********************************
consoleVariable *cf_p3ga_or(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", p3ga(((arg[0]->p().norm_a() != 0.0) || (arg[1]->p().norm_a() != 0.0))));
}

// ********************************* p3ga not *********************************
consoleVariable *cf_p3ga_not(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", p3ga(arg[0]->p().norm_a() == 0.0));
}


// ********************************* c3ga SCALAR *********************************
consoleVariable *cf_c3ga_scalar(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", c3ga(arg[0]->c().scalar()));
}

// ********************************* c3ga DUAL *********************************
consoleVariable *cf_c3ga_dual(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", arg[0]->c().dual());
}

// ********************************* c3ga DUAL2 *********************************
consoleVariable *cf_c3ga_dual2(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", arg[0]->c() << arg[1]->c().inverse());
}

// ********************************* c3ga REVERSE *********************************
consoleVariable *cf_c3ga_reverse(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", arg[0]->c().reverse());
}

// ********************************* c3ga CLIFFORD_CONJUGATE *********************************
consoleVariable *cf_c3ga_clifford_conjugate(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", arg[0]->c().cliffordConjugate());
}

// ********************************* c3ga GRADE INVOLUTION *********************************
consoleVariable *cf_c3ga_grade_involution(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", arg[0]->c().gradeInvolution());
}

// ********************************* c3ga INVERSE *********************************
consoleVariable *cf_c3ga_inverse(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", arg[0]->c().inverse());
}

// ********************************* c3ga GENERAL INVERSE *********************************
consoleVariable *cf_c3ga_general_inverse(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", arg[0]->c().generalInverse());
}

// ********************************* c3ga NEGATE *********************************
consoleVariable *cf_c3ga_negate(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", arg[0]->c().negate());
}

// ********************************* c3ga GP *********************************
consoleVariable *cf_c3ga_gp(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", gp(arg[0]->c(), arg[1]->c()));
}

// ********************************* c3ga IGP *********************************
consoleVariable *cf_c3ga_igp(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", igp(arg[0]->c(), arg[1]->c()));
}

// ********************************* c3ga OP *********************************
consoleVariable *cf_c3ga_op(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", op(arg[0]->c(), arg[1]->c()));
}

// ********************************* c3ga HIP *********************************
consoleVariable *cf_c3ga_hip(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", hip(arg[0]->c(), arg[1]->c()));
}

// ********************************* c3ga MHIP *********************************
consoleVariable *cf_c3ga_mhip(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", mhip(arg[0]->c(), arg[1]->c()));
}

// ********************************* c3ga LCONT *********************************
consoleVariable *cf_c3ga_lcont(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", lcont(arg[0]->c(), arg[1]->c()));
}

// ********************************* c3ga GPEM *********************************
consoleVariable *cf_c3ga_gpem(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", gpem(arg[0]->c(), arg[1]->c()));
}

// ********************************* c3ga LCEM *********************************
consoleVariable *cf_c3ga_lcem(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", lcem(arg[0]->c(), arg[1]->c()));
}

// ********************************* c3ga RCONT *********************************
consoleVariable *cf_c3ga_rcont(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", rcont(arg[0]->c(), arg[1]->c()));
}

// ********************************* c3ga SCP *********************************
consoleVariable *cf_c3ga_scp(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", scp(arg[0]->c(), arg[1]->c()));
}

// ********************************* c3ga ADD *********************************
consoleVariable *cf_c3ga_add(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", add(arg[0]->c(), arg[1]->c()));
}

// ********************************* c3ga SUB *********************************
consoleVariable *cf_c3ga_sub(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", sub(arg[0]->c(), arg[1]->c()));
}

// ********************************* c3ga MEET *********************************
consoleVariable *cf_c3ga_meet(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", meet(arg[0]->c(), arg[1]->c()));
}

// ********************************* c3ga JOIN *********************************
consoleVariable *cf_c3ga_join(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", join(arg[0]->c(), arg[1]->c()));
}

// ********************************* c3ga CP *********************************
consoleVariable *cf_c3ga_cp(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", 
	op(0.5, sub(gp(arg[0]->c(), arg[1]->c()),
	gp(arg[1]->c(), arg[0]->c()))));
}

// ********************************* c3ga PRINT *********************************
consoleVariable *cf_c3ga_print(consoleScope *s, consoleVariable *arg[]) {
/*	cprintf("%s = %s\n", 
		(arg[0]->name().find(std::string(sc_tempVarPrefix)) == 0) ? "ans" : arg[0]->name().c_str(), 
		arg[0]->c().string());
		
	return arg[0];*/
	std::string name = (arg[0]->name().find(std::string(sc_tempVarPrefix)) == 0) ? std::string("ans") : arg[0]->name();
	std::string val = arg[0]->c().string();
	char buf[2048];
	sprintf(buf, "%s = %s\n", name.c_str(), val.c_str());
	cprintf(buf);
	return arg[0];
}

consoleVariable *cf_c3ga_print_prec(consoleScope *s, consoleVariable *arg[]) {
	const char *name = arg[0]->name().c_str();
	char precstr[256];
	sprintf(precstr, "%c%s", '%', arg[1]->name().c_str());
	/*
	cprintf("%s = %s\n", 
		(strstr(name, sc_tempVarPrefix) == name) ? "ans" : name, 
		arg[0]->c().string(precstr));*/
	char buf[2048];
	sprintf(buf, "%s = %s\n", (strstr(name, sc_tempVarPrefix) == name) ? "ans" : name, 
		arg[0]->c().string(precstr));
	cprintf(buf);

	return arg[0];
}

// ********************************* c3ga ASSIGN *********************************
consoleVariable *cf_c3ga_assign(consoleScope *s, consoleVariable *arg[]) {
	consoleVariable *cv = s->assignVariable(arg[0], arg[1]);
	cv->name(arg[0]->name());
	return cv;
}

// ********************************* c3ga GRADE *********************************
consoleVariable *cf_c3ga_grade(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", arg[0]->c()(1 << ((int)arg[1]->c().scalar())));
}

// ********************************* c3ga GRADE *********************************
consoleVariable *cf_c3ga_grade_nb(consoleScope *s, consoleVariable *arg[]) {
	int grade, type = arg[0]->c().mvType(&grade); // epsilon?
	if (type == GA_BLADE)
		grade = (int)(log((double)grade) / log((double)2) + 0.45);
	else grade = -1;

	return new consoleVariable("",  c3ga((GAIM_FLOAT)grade));
}

// ********************************* c3ga VERSOR PARITY *********************************
consoleVariable *cf_c3ga_versor_parity(consoleScope *s, consoleVariable *arg[]) {
	int grade, type = arg[0]->c().mvType(&grade); // epsilon?
	if ((type == GA_BLADE) || (type == GA_VERSOR))
		grade = arg[0]->c().largestGrade() & 1;
	else grade = -1;

	return new consoleVariable("",  c3ga((GAIM_FLOAT)grade));
}

// ********************************* c3ga NORM *********************************
consoleVariable *cf_c3ga_norm(consoleScope *s, consoleVariable *arg[]) {
	GAIM_FLOAT n = arg[0]->c().norm_b();
	n = sqrt(fabs(n)) * ((n < 0) ? -1.0 : 1.0);
	return new consoleVariable("", c3ga(n));
}

// ********************************* c3ga NORM_A *********************************
consoleVariable *cf_c3ga_norm_2(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", c3ga(arg[0]->c().norm_a()));
}
// ********************************* c3ga NORM_B *********************************
consoleVariable *cf_c3ga_norm_r(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", c3ga(arg[0]->c().norm_b()));
}

// ********************************* c3ga NORMALIZE *********************************
consoleVariable *cf_c3ga_normalize(consoleScope *s, consoleVariable *arg[]) {
	GAIM_FLOAT n = sqrt(fabs(arg[0]->c().norm_b()));
	return new consoleVariable("", c3ga(arg[0]->c() * ((n == 0.0) ? 0.0 : (1.0 / n))));
}

// ********************************* c3ga SQRT *********************************
consoleVariable *cf_c3ga_sqrt(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", c3ga(sqrt(arg[0]->c().scalar())));
}

// ********************************* c3ga ABS *********************************
consoleVariable *cf_c3ga_abs(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", c3ga(fabs(arg[0]->c().scalar())));
}

// ********************************* c3ga TAN *********************************
consoleVariable *cf_c3ga_tan(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", c3ga(tan(arg[0]->c().scalar())));
}

// ********************************* c3ga COS *********************************
consoleVariable *cf_c3ga_cos(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", c3ga(cos(arg[0]->c().scalar())));
}

// ********************************* c3ga SIN *********************************
consoleVariable *cf_c3ga_sin(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", c3ga(sin(arg[0]->c().scalar())));
}

// ********************************* c3ga COSH *********************************
consoleVariable *cf_c3ga_cosh(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", c3ga(cosh(arg[0]->c().scalar())));
}

// ********************************* c3ga SINH *********************************
consoleVariable *cf_c3ga_sinh(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", c3ga(sinh(arg[0]->c().scalar())));
}

// ********************************* c3ga ACOSH *********************************
consoleVariable *cf_c3ga_acosh(consoleScope *s, consoleVariable *arg[]) {
	double x = arg[0]->c().scalar();
	double value = (x >= 1) ? log(x + sqrt(x*x-1)) : 0.0;
	return new consoleVariable("", c3ga(value));
}


// ********************************* c3ga ASINH *********************************
consoleVariable *cf_c3ga_asinh(consoleScope *s, consoleVariable *arg[]) {
	c3ga B = arg[0]->c().grade(GRADE2);
	if (B.norm_a() != 0.0) {
		double B2 = gp(B, B).scalar();
		if (B2 < 0.0) {
			double sqrtMB2 = sqrt(-B2);
			return new consoleVariable("", op(asin(sqrtMB2) / sqrtMB2, B));
		}
		else if (B2 == 0.0) {
			return new consoleVariable("", B);
		}
		else {
			double sqrtB2 = sqrt(B2);
			return new consoleVariable("", op(asinhScalar(sqrtB2) / sqrtB2, B));
		}
	}
	else {
		double x = arg[0]->c().scalar();
		double value = asinhScalar(x);
		return new consoleVariable("", c3ga(value));
	}
	
}

// ********************************* c3ga ATAN *********************************
consoleVariable *cf_c3ga_atan(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", c3ga(atan(arg[0]->c().scalar())));
}

// ********************************* c3ga ATAN2 *********************************
consoleVariable *cf_c3ga_atan2(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", c3ga(atan2(arg[0]->c().scalar(), arg[1]->c().scalar())));
}

// ********************************* c3ga MAX *********************************
consoleVariable *cf_c3ga_max(consoleScope *s, consoleVariable *arg[]) {
	GAIM_FLOAT val = (arg[0]->scalar() > arg[1]->scalar()) 
		? arg[0]->scalar() : arg[1]->scalar();
	return new consoleVariable("", c3ga(val));
}

// ********************************* c3ga MIN *********************************
consoleVariable *cf_c3ga_min(consoleScope *s, consoleVariable *arg[]) {
	GAIM_FLOAT val = (arg[0]->scalar() < arg[1]->scalar()) 
		? arg[0]->scalar() : arg[1]->scalar();
	return new consoleVariable("", c3ga(val));
}

// ********************************* c3ga ACOS *********************************
consoleVariable *cf_c3ga_acos(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", c3ga(acos(arg[0]->c().scalar())));
}

// ********************************* c3ga ASIN *********************************
consoleVariable *cf_c3ga_asin(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", c3ga(asin(arg[0]->c().scalar())));
}

// ********************************* c3ga SINC *********************************
consoleVariable *cf_c3ga_sinc(consoleScope *s, consoleVariable *arg[]) {
	double x = arg[0]->c().scalar();
	if (x == 0.0) return new consoleVariable("", c3ga(1.0));
	else return new consoleVariable("", c3ga(sin(x)/x));
}

// ********************************* c3ga EXP *********************************
consoleVariable *cf_c3ga_exp(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", c3ga(arg[0]->c().exp(12)));
}

// ********************************* c3ga LOG *********************************
consoleVariable *cf_c3ga_log(consoleScope *s, consoleVariable *arg[]) {
	double x = arg[0]->c().scalar();
	if (x == 0.0)	return new consoleVariable("", c3ga(0));
	else if (x > 0.0) return new consoleVariable("", c3ga(log(x)));
	else return new consoleVariable("", c3ga(M_PI * (c3ga::e1 ^ c3ga::e2) + log(-x)));
}

// ********************************* c3ga SCALAR_POW *********************************
consoleVariable *cf_c3ga_scalar_pow(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", c3ga(pow(arg[0]->c().scalar(), arg[1]->c().scalar())));
}

// ********************************* c3ga RANDOM SEED *********************************
consoleVariable *cf_c3ga_randSeed(consoleScope *s, consoleVariable *arg[]) {
	double _seed = arg[0]->c().scalar();
	unsigned long seed = (unsigned long )(_seed * 32768.0);
	sgenrand(seed);
		
	return new consoleVariable("", c3ga(0.0));
}


// ********************************* c3ga RANDOM GAUSS NUMBER *********************************
consoleVariable *cf_c3ga_randGauss(consoleScope *s, consoleVariable *arg[]) {
	double mean = arg[0]->c().scalar();
	double variance = arg[1]->c().scalar();
	return new consoleVariable("", c3ga(gaussNoise(mean, variance)));
}

// ********************************* c3ga POW *********************************
consoleVariable *cf_c3ga_pow(consoleScope *s, consoleVariable *arg[]) {
	int n = (int)(arg[1]->c().scalar() + 0.5), i;
	c3ga r(1.0);
	for (i = 0; i < n; i++)
		r = r * arg[0]->c();

	return new consoleVariable("", r);
}

// ********************************* c3ga VERSOR PRODUCT *********************************
consoleVariable *cf_c3ga_versorProduct(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", c3ga(arg[0]->c() * arg[1]->c() * arg[0]->c().inverse()));
}

// ********************************* c3ga INVERSE VERSOR PRODUCT *********************************
consoleVariable *cf_c3ga_inverseVersorProduct(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", c3ga(arg[0]->c().inverse() * arg[1]->c() * arg[0]->c()));
}

// ********************************* c3ga mierenneuk VERSOR PRODUCT *********************************
consoleVariable *cf_c3ga_MNversorProduct(consoleScope *s, consoleVariable *arg[]) {
	c3ga v = arg[0]->c();
	c3ga o = arg[1]->c();
	
	int vgrade = v.largestGrade() & 1;

	if (vgrade)	 return new consoleVariable("", c3ga(v * o.gradeInvolution() * v.inverse()));
	else return new consoleVariable("", c3ga(v * o * v.inverse()));
}

// ********************************* c3ga mierenneuk INVERSE VERSOR PRODUCT *********************************
consoleVariable *cf_c3ga_MNinverseVersorProduct(consoleScope *s, consoleVariable *arg[]) {
	c3ga v = arg[0]->c();
	c3ga o = arg[1]->c();
	
	int vgrade = v.largestGrade() & 1;

	if (vgrade)	 return new consoleVariable("", c3ga(v.inverse() * o.gradeInvolution() * v));
	else return new consoleVariable("", c3ga(v.inverse() * o * v));
}


// ********************************* c3ga PROJECT *********************************
consoleVariable *cf_c3ga_project(consoleScope *s, consoleVariable *arg[]) {
	c3ga tmp;
	tmp.project(arg[1]->c(), arg[0]->c());
	return new consoleVariable("", tmp);
}

// ********************************* c3ga reject *********************************
consoleVariable *cf_c3ga_reject(consoleScope *s, consoleVariable *arg[]) {
	c3ga tmp;
	tmp.reject(arg[1]->c(), arg[0]->c());
	return new consoleVariable("", tmp);
}

// ********************************* c3ga factor *********************************
consoleVariable *cf_c3ga_factor(consoleScope *s, consoleVariable *arg[]) {
	c3ga tmp[5];
	arg[0]->c().factor(tmp);

	int f = (int)(arg[1]->c().scalar()) - 1;
	if (f > 4) f = 4;
	else if (f < 0) f = 0;

	return new consoleVariable("", tmp[f]);
}

// ********************************* c3ga set_factor *********************************
consoleVariable *cf_c3ga_set_factor(consoleScope *s, consoleVariable *arg[]) {
	int idx = (int)arg[0]->scalar();
	g_state->setC3gaFactor(arg[1]->c(), idx);
	return arg[1];
}

// ********************************* c3ga equal *********************************
consoleVariable *cf_c3ga_equal(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", c3ga((arg[0]->c() - arg[1]->c()).norm_a() == 0.0));
}

// ********************************* c3ga ne *********************************
consoleVariable *cf_c3ga_ne(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", c3ga((arg[0]->c() - arg[1]->c()).norm_a() != 0.0));
}

// ********************************* c3ga less *********************************
consoleVariable *cf_c3ga_less(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", c3ga(arg[0]->c().scalar() < arg[1]->c().scalar()));
}
// ********************************* c3ga greater *********************************
consoleVariable *cf_c3ga_greater(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", c3ga(arg[0]->c().scalar() > arg[1]->c().scalar()));
}
// ********************************* c3ga le *********************************
consoleVariable *cf_c3ga_le(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", c3ga(arg[0]->c().scalar() <= arg[1]->c().scalar()));
}
// ********************************* c3ga ge *********************************
consoleVariable *cf_c3ga_ge(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", c3ga(arg[0]->c().scalar() >= arg[1]->c().scalar()));
}

// ********************************* c3ga and *********************************
consoleVariable *cf_c3ga_and(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", c3ga(((arg[0]->c().norm_a() != 0.0) && (arg[1]->c().norm_a() != 0.0))));
}
// ********************************* c3ga or *********************************
consoleVariable *cf_c3ga_or(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", c3ga(((arg[0]->c().norm_a() != 0.0) || (arg[1]->c().norm_a() != 0.0))));
}

// ********************************* c3ga not *********************************
consoleVariable *cf_c3ga_not(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", c3ga(arg[0]->c().norm_a() == 0.0));
}


// ********************************* c5ga SCALAR *********************************
consoleVariable *cf_c5ga_scalar(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", c5ga(arg[0]->c5().scalar()));
}

// ********************************* c5ga DUAL *********************************
consoleVariable *cf_c5ga_dual(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", arg[0]->c5().dual());
}

// ********************************* c5ga DUAL2 *********************************
consoleVariable *cf_c5ga_dual2(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", arg[0]->c5() << arg[1]->c5().inverse());
}

// ********************************* c5ga REVERSE *********************************
consoleVariable *cf_c5ga_reverse(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", arg[0]->c5().reverse());
}

// ********************************* c5ga CLIFFORD_CONJUGATE *********************************
consoleVariable *cf_c5ga_clifford_conjugate(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", arg[0]->c5().cliffordConjugate());
}

// ********************************* c5ga GRADE INVOLUTION *********************************
consoleVariable *cf_c5ga_grade_involution(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", arg[0]->c5().gradeInvolution());
}

// ********************************* c5ga INVERSE *********************************
consoleVariable *cf_c5ga_inverse(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", arg[0]->c5().inverse());
}

// ********************************* c5ga GENERAL INVERSE *********************************
consoleVariable *cf_c5ga_general_inverse(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", arg[0]->c5().generalInverse());
}

// ********************************* c5ga NEGATE *********************************
consoleVariable *cf_c5ga_negate(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", arg[0]->c5().negate());
}

// ********************************* c5ga GP *********************************
consoleVariable *cf_c5ga_gp(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", gp(arg[0]->c5(), arg[1]->c5()));
}

// ********************************* c5ga IGP *********************************
consoleVariable *cf_c5ga_igp(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", igp(arg[0]->c5(), arg[1]->c5()));
}

// ********************************* c5ga OP *********************************
consoleVariable *cf_c5ga_op(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", op(arg[0]->c5(), arg[1]->c5()));
}

// ********************************* c5ga HIP *********************************
consoleVariable *cf_c5ga_hip(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", hip(arg[0]->c5(), arg[1]->c5()));
}

// ********************************* c5ga MHIP *********************************
consoleVariable *cf_c5ga_mhip(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", mhip(arg[0]->c5(), arg[1]->c5()));
}

// ********************************* c5ga LCONT *********************************
consoleVariable *cf_c5ga_lcont(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", lcont(arg[0]->c5(), arg[1]->c5()));
}

// ********************************* c5ga GPEM *********************************
consoleVariable *cf_c5ga_gpem(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", gpem(arg[0]->c5(), arg[1]->c5()));
}

// ********************************* c5ga LCEM *********************************
consoleVariable *cf_c5ga_lcem(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", lcem(arg[0]->c5(), arg[1]->c5()));
}

// ********************************* c5ga RCONT *********************************
consoleVariable *cf_c5ga_rcont(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", rcont(arg[0]->c5(), arg[1]->c5()));
}

// ********************************* c5ga SCP *********************************
consoleVariable *cf_c5ga_scp(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", scp(arg[0]->c5(), arg[1]->c5()));
}

// ********************************* c5ga ADD *********************************
consoleVariable *cf_c5ga_add(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", add(arg[0]->c5(), arg[1]->c5()));
}

// ********************************* c5ga SUB *********************************
consoleVariable *cf_c5ga_sub(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", sub(arg[0]->c5(), arg[1]->c5()));
}

// ********************************* c5ga MEET *********************************
consoleVariable *cf_c5ga_meet(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", meet(arg[0]->c5(), arg[1]->c5()));
}

// ********************************* c5ga JOIN *********************************
consoleVariable *cf_c5ga_join(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", join(arg[0]->c5(), arg[1]->c5()));
}

// ********************************* c5ga CP *********************************
consoleVariable *cf_c5ga_cp(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", 
	op(0.5, sub(gp(arg[0]->c5(), arg[1]->c5()),
	gp(arg[1]->c5(), arg[0]->c5()))));
}

// ********************************* c5ga PRINT *********************************
consoleVariable *cf_c5ga_print(consoleScope *s, consoleVariable *arg[]) {
/*	cprintf("%s = %s\n", 
		(arg[0]->name().find(std::string(sc_tempVarPrefix)) == 0) ? "ans" : arg[0]->name().c_str(), 
		arg[0]->c5().string());
		
	return arg[0];*/
	std::string name = (arg[0]->name().find(std::string(sc_tempVarPrefix)) == 0) ? std::string("ans") : arg[0]->name();
	std::string val = arg[0]->c5().string();
	char buf[2048];
	sprintf(buf, "%s = %s\n", name.c_str(), val.c_str());
	cprintf(buf);
	return arg[0];
}

consoleVariable *cf_c5ga_print_prec(consoleScope *s, consoleVariable *arg[]) {
	const char *name = arg[0]->name().c_str();
	char precstr[256];
	sprintf(precstr, "%c%s", '%', arg[1]->name().c_str());
	/*
	cprintf("%s = %s\n", 
		(strstr(name, sc_tempVarPrefix) == name) ? "ans" : name, 
		arg[0]->c5().string(precstr));*/
	char buf[2048];
	sprintf(buf, "%s = %s\n", (strstr(name, sc_tempVarPrefix) == name) ? "ans" : name, 
		arg[0]->c5().string(precstr));
	cprintf(buf);

	return arg[0];
}

// ********************************* c5ga ASSIGN *********************************
consoleVariable *cf_c5ga_assign(consoleScope *s, consoleVariable *arg[]) {
	consoleVariable *cv = s->assignVariable(arg[0], arg[1]);
	cv->name(arg[0]->name());
	return cv;
}

// ********************************* c5ga GRADE *********************************
consoleVariable *cf_c5ga_grade(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", arg[0]->c5()(1 << ((int)arg[1]->c5().scalar())));
}

// ********************************* c5ga GRADE *********************************
consoleVariable *cf_c5ga_grade_nb(consoleScope *s, consoleVariable *arg[]) {
	int grade, type = arg[0]->c5().mvType(&grade); // epsilon?
	if (type == GA_BLADE)
		grade = (int)(log((double)grade) / log((double)2) + 0.45);
	else grade = -1;

	return new consoleVariable("",  c5ga((GAIM_FLOAT)grade));
}

// ********************************* c5ga VERSOR PARITY *********************************
consoleVariable *cf_c5ga_versor_parity(consoleScope *s, consoleVariable *arg[]) {
	int grade, type = arg[0]->c5().mvType(&grade); // epsilon?
	if ((type == GA_BLADE) || (type == GA_VERSOR))
		grade = arg[0]->c5().largestGrade() & 1;
	else grade = -1;

	return new consoleVariable("",  c5ga((GAIM_FLOAT)grade));
}

// ********************************* c5ga NORM *********************************
consoleVariable *cf_c5ga_norm(consoleScope *s, consoleVariable *arg[]) {
	GAIM_FLOAT n = arg[0]->c5().norm_b();
	n = sqrt(fabs(n)) * ((n < 0) ? -1.0 : 1.0);
	return new consoleVariable("", c5ga(n));
}

// ********************************* c5ga NORM_A *********************************
consoleVariable *cf_c5ga_norm_2(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", c5ga(arg[0]->c5().norm_a()));
}
// ********************************* c5ga NORM_B *********************************
consoleVariable *cf_c5ga_norm_r(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", c5ga(arg[0]->c5().norm_b()));
}

// ********************************* c5ga NORMALIZE *********************************
consoleVariable *cf_c5ga_normalize(consoleScope *s, consoleVariable *arg[]) {
	GAIM_FLOAT n = sqrt(fabs(arg[0]->c5().norm_b()));
	return new consoleVariable("", c5ga(arg[0]->c5() * ((n == 0.0) ? 0.0 : (1.0 / n))));
}

// ********************************* c5ga SQRT *********************************
consoleVariable *cf_c5ga_sqrt(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", c5ga(sqrt(arg[0]->c5().scalar())));
}

// ********************************* c5ga ABS *********************************
consoleVariable *cf_c5ga_abs(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", c5ga(fabs(arg[0]->c5().scalar())));
}

// ********************************* c5ga TAN *********************************
consoleVariable *cf_c5ga_tan(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", c5ga(tan(arg[0]->c5().scalar())));
}

// ********************************* c5ga COS *********************************
consoleVariable *cf_c5ga_cos(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", c5ga(cos(arg[0]->c5().scalar())));
}

// ********************************* c5ga SIN *********************************
consoleVariable *cf_c5ga_sin(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", c5ga(sin(arg[0]->c5().scalar())));
}

// ********************************* c5ga COSH *********************************
consoleVariable *cf_c5ga_cosh(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", c5ga(cosh(arg[0]->c5().scalar())));
}

// ********************************* c5ga SINH *********************************
consoleVariable *cf_c5ga_sinh(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", c5ga(sinh(arg[0]->c5().scalar())));
}

// ********************************* c5ga ACOSH *********************************
consoleVariable *cf_c5ga_acosh(consoleScope *s, consoleVariable *arg[]) {
	double x = arg[0]->c5().scalar();
	double value = (x >= 1) ? log(x + sqrt(x*x-1)) : 0.0;
	return new consoleVariable("", c5ga(value));
}


// ********************************* c5ga ASINH *********************************
consoleVariable *cf_c5ga_asinh(consoleScope *s, consoleVariable *arg[]) {
	c5ga B = arg[0]->c5().grade(GRADE2);
	if (B.norm_a() != 0.0) {
		double B2 = gp(B, B).scalar();
		if (B2 < 0.0) {
			double sqrtMB2 = sqrt(-B2);
			return new consoleVariable("", op(asin(sqrtMB2) / sqrtMB2, B));
		}
		else if (B2 == 0.0) {
			return new consoleVariable("", B);
		}
		else {
			double sqrtB2 = sqrt(B2);
			return new consoleVariable("", op(asinhScalar(sqrtB2) / sqrtB2, B));
		}
	}
	else {
		double x = arg[0]->c5().scalar();
		double value = asinhScalar(x);
		return new consoleVariable("", c5ga(value));
	}
	
}

// ********************************* c5ga ATAN *********************************
consoleVariable *cf_c5ga_atan(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", c5ga(atan(arg[0]->c5().scalar())));
}

// ********************************* c5ga ATAN2 *********************************
consoleVariable *cf_c5ga_atan2(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", c5ga(atan2(arg[0]->c5().scalar(), arg[1]->c5().scalar())));
}

// ********************************* c5ga MAX *********************************
consoleVariable *cf_c5ga_max(consoleScope *s, consoleVariable *arg[]) {
	GAIM_FLOAT val = (arg[0]->scalar() > arg[1]->scalar()) 
		? arg[0]->scalar() : arg[1]->scalar();
	return new consoleVariable("", c5ga(val));
}

// ********************************* c5ga MIN *********************************
consoleVariable *cf_c5ga_min(consoleScope *s, consoleVariable *arg[]) {
	GAIM_FLOAT val = (arg[0]->scalar() < arg[1]->scalar()) 
		? arg[0]->scalar() : arg[1]->scalar();
	return new consoleVariable("", c5ga(val));
}

// ********************************* c5ga ACOS *********************************
consoleVariable *cf_c5ga_acos(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", c5ga(acos(arg[0]->c5().scalar())));
}

// ********************************* c5ga ASIN *********************************
consoleVariable *cf_c5ga_asin(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", c5ga(asin(arg[0]->c5().scalar())));
}

// ********************************* c5ga SINC *********************************
consoleVariable *cf_c5ga_sinc(consoleScope *s, consoleVariable *arg[]) {
	double x = arg[0]->c5().scalar();
	if (x == 0.0) return new consoleVariable("", c5ga(1.0));
	else return new consoleVariable("", c5ga(sin(x)/x));
}

// ********************************* c5ga EXP *********************************
consoleVariable *cf_c5ga_exp(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", c5ga(arg[0]->c5().exp(12)));
}

// ********************************* c5ga LOG *********************************
consoleVariable *cf_c5ga_log(consoleScope *s, consoleVariable *arg[]) {
	double x = arg[0]->c5().scalar();
	if (x == 0.0)	return new consoleVariable("", c5ga(0));
	else if (x > 0.0) return new consoleVariable("", c5ga(log(x)));
	else return new consoleVariable("", c5ga(M_PI * (c5ga::e1 ^ c5ga::e2) + log(-x)));
}

// ********************************* c5ga SCALAR_POW *********************************
consoleVariable *cf_c5ga_scalar_pow(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", c5ga(pow(arg[0]->c5().scalar(), arg[1]->c5().scalar())));
}

// ********************************* c5ga RANDOM SEED *********************************
consoleVariable *cf_c5ga_randSeed(consoleScope *s, consoleVariable *arg[]) {
	double _seed = arg[0]->c5().scalar();
	unsigned long seed = (unsigned long )(_seed * 32768.0);
	sgenrand(seed);
		
	return new consoleVariable("", c5ga(0.0));
}


// ********************************* c5ga RANDOM GAUSS NUMBER *********************************
consoleVariable *cf_c5ga_randGauss(consoleScope *s, consoleVariable *arg[]) {
	double mean = arg[0]->c5().scalar();
	double variance = arg[1]->c5().scalar();
	return new consoleVariable("", c5ga(gaussNoise(mean, variance)));
}

// ********************************* c5ga POW *********************************
consoleVariable *cf_c5ga_pow(consoleScope *s, consoleVariable *arg[]) {
	int n = (int)(arg[1]->c5().scalar() + 0.5), i;
	c5ga r(1.0);
	for (i = 0; i < n; i++)
		r = r * arg[0]->c5();

	return new consoleVariable("", r);
}

// ********************************* c5ga VERSOR PRODUCT *********************************
consoleVariable *cf_c5ga_versorProduct(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", c5ga(arg[0]->c5() * arg[1]->c5() * arg[0]->c5().inverse()));
}

// ********************************* c5ga INVERSE VERSOR PRODUCT *********************************
consoleVariable *cf_c5ga_inverseVersorProduct(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", c5ga(arg[0]->c5().inverse() * arg[1]->c5() * arg[0]->c5()));
}

// ********************************* c5ga mierenneuk VERSOR PRODUCT *********************************
consoleVariable *cf_c5ga_MNversorProduct(consoleScope *s, consoleVariable *arg[]) {
	c5ga v = arg[0]->c5();
	c5ga o = arg[1]->c5();
	
	int vgrade = v.largestGrade() & 1;

	if (vgrade)	 return new consoleVariable("", c5ga(v * o.gradeInvolution() * v.inverse()));
	else return new consoleVariable("", c5ga(v * o * v.inverse()));
}

// ********************************* c5ga mierenneuk INVERSE VERSOR PRODUCT *********************************
consoleVariable *cf_c5ga_MNinverseVersorProduct(consoleScope *s, consoleVariable *arg[]) {
	c5ga v = arg[0]->c5();
	c5ga o = arg[1]->c5();
	
	int vgrade = v.largestGrade() & 1;

	if (vgrade)	 return new consoleVariable("", c5ga(v.inverse() * o.gradeInvolution() * v));
	else return new consoleVariable("", c5ga(v.inverse() * o * v));
}


// ********************************* c5ga PROJECT *********************************
consoleVariable *cf_c5ga_project(consoleScope *s, consoleVariable *arg[]) {
	c5ga tmp;
	tmp.project(arg[1]->c5(), arg[0]->c5());
	return new consoleVariable("", tmp);
}

// ********************************* c5ga reject *********************************
consoleVariable *cf_c5ga_reject(consoleScope *s, consoleVariable *arg[]) {
	c5ga tmp;
	tmp.reject(arg[1]->c5(), arg[0]->c5());
	return new consoleVariable("", tmp);
}

// ********************************* c5ga factor *********************************
consoleVariable *cf_c5ga_factor(consoleScope *s, consoleVariable *arg[]) {
	c5ga tmp[5];
	arg[0]->c5().factor(tmp);

	int f = (int)(arg[1]->c5().scalar()) - 1;
	if (f > 4) f = 4;
	else if (f < 0) f = 0;

	return new consoleVariable("", tmp[f]);
}

// ********************************* c5ga set_factor *********************************
consoleVariable *cf_c5ga_set_factor(consoleScope *s, consoleVariable *arg[]) {
	int idx = (int)arg[0]->scalar();
	g_state->setC5gaFactor(arg[1]->c5(), idx);
	return arg[1];
}

// ********************************* c5ga equal *********************************
consoleVariable *cf_c5ga_equal(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", c5ga((arg[0]->c5() - arg[1]->c5()).norm_a() == 0.0));
}

// ********************************* c5ga ne *********************************
consoleVariable *cf_c5ga_ne(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", c5ga((arg[0]->c5() - arg[1]->c5()).norm_a() != 0.0));
}

// ********************************* c5ga less *********************************
consoleVariable *cf_c5ga_less(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", c5ga(arg[0]->c5().scalar() < arg[1]->c5().scalar()));
}
// ********************************* c5ga greater *********************************
consoleVariable *cf_c5ga_greater(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", c5ga(arg[0]->c5().scalar() > arg[1]->c5().scalar()));
}
// ********************************* c5ga le *********************************
consoleVariable *cf_c5ga_le(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", c5ga(arg[0]->c5().scalar() <= arg[1]->c5().scalar()));
}
// ********************************* c5ga ge *********************************
consoleVariable *cf_c5ga_ge(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", c5ga(arg[0]->c5().scalar() >= arg[1]->c5().scalar()));
}

// ********************************* c5ga and *********************************
consoleVariable *cf_c5ga_and(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", c5ga(((arg[0]->c5().norm_a() != 0.0) && (arg[1]->c5().norm_a() != 0.0))));
}
// ********************************* c5ga or *********************************
consoleVariable *cf_c5ga_or(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", c5ga(((arg[0]->c5().norm_a() != 0.0) || (arg[1]->c5().norm_a() != 0.0))));
}

// ********************************* c5ga not *********************************
consoleVariable *cf_c5ga_not(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", c5ga(arg[0]->c5().norm_a() == 0.0));
}


// ********************************* i2ga SCALAR *********************************
consoleVariable *cf_i2ga_scalar(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", i2ga(arg[0]->i2().scalar()));
}

// ********************************* i2ga DUAL *********************************
consoleVariable *cf_i2ga_dual(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", arg[0]->i2().dual());
}

// ********************************* i2ga DUAL2 *********************************
consoleVariable *cf_i2ga_dual2(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", arg[0]->i2() << arg[1]->i2().inverse());
}

// ********************************* i2ga REVERSE *********************************
consoleVariable *cf_i2ga_reverse(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", arg[0]->i2().reverse());
}

// ********************************* i2ga CLIFFORD_CONJUGATE *********************************
consoleVariable *cf_i2ga_clifford_conjugate(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", arg[0]->i2().cliffordConjugate());
}

// ********************************* i2ga GRADE INVOLUTION *********************************
consoleVariable *cf_i2ga_grade_involution(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", arg[0]->i2().gradeInvolution());
}

// ********************************* i2ga INVERSE *********************************
consoleVariable *cf_i2ga_inverse(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", arg[0]->i2().inverse());
}

// ********************************* i2ga GENERAL INVERSE *********************************
consoleVariable *cf_i2ga_general_inverse(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", arg[0]->i2().generalInverse());
}

// ********************************* i2ga NEGATE *********************************
consoleVariable *cf_i2ga_negate(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", arg[0]->i2().negate());
}

// ********************************* i2ga GP *********************************
consoleVariable *cf_i2ga_gp(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", gp(arg[0]->i2(), arg[1]->i2()));
}

// ********************************* i2ga IGP *********************************
consoleVariable *cf_i2ga_igp(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", igp(arg[0]->i2(), arg[1]->i2()));
}

// ********************************* i2ga OP *********************************
consoleVariable *cf_i2ga_op(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", op(arg[0]->i2(), arg[1]->i2()));
}

// ********************************* i2ga HIP *********************************
consoleVariable *cf_i2ga_hip(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", hip(arg[0]->i2(), arg[1]->i2()));
}

// ********************************* i2ga MHIP *********************************
consoleVariable *cf_i2ga_mhip(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", mhip(arg[0]->i2(), arg[1]->i2()));
}

// ********************************* i2ga LCONT *********************************
consoleVariable *cf_i2ga_lcont(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", lcont(arg[0]->i2(), arg[1]->i2()));
}

// ********************************* i2ga GPEM *********************************
consoleVariable *cf_i2ga_gpem(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", gpem(arg[0]->i2(), arg[1]->i2()));
}

// ********************************* i2ga LCEM *********************************
consoleVariable *cf_i2ga_lcem(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", lcem(arg[0]->i2(), arg[1]->i2()));
}

// ********************************* i2ga RCONT *********************************
consoleVariable *cf_i2ga_rcont(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", rcont(arg[0]->i2(), arg[1]->i2()));
}

// ********************************* i2ga SCP *********************************
consoleVariable *cf_i2ga_scp(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", scp(arg[0]->i2(), arg[1]->i2()));
}

// ********************************* i2ga ADD *********************************
consoleVariable *cf_i2ga_add(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", add(arg[0]->i2(), arg[1]->i2()));
}

// ********************************* i2ga SUB *********************************
consoleVariable *cf_i2ga_sub(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", sub(arg[0]->i2(), arg[1]->i2()));
}

// ********************************* i2ga MEET *********************************
consoleVariable *cf_i2ga_meet(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", meet(arg[0]->i2(), arg[1]->i2()));
}

// ********************************* i2ga JOIN *********************************
consoleVariable *cf_i2ga_join(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", join(arg[0]->i2(), arg[1]->i2()));
}

// ********************************* i2ga CP *********************************
consoleVariable *cf_i2ga_cp(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", 
	op(0.5, sub(gp(arg[0]->i2(), arg[1]->i2()),
	gp(arg[1]->i2(), arg[0]->i2()))));
}

// ********************************* i2ga PRINT *********************************
consoleVariable *cf_i2ga_print(consoleScope *s, consoleVariable *arg[]) {
/*	cprintf("%s = %s\n", 
		(arg[0]->name().find(std::string(sc_tempVarPrefix)) == 0) ? "ans" : arg[0]->name().c_str(), 
		arg[0]->i2().string());
		
	return arg[0];*/
	std::string name = (arg[0]->name().find(std::string(sc_tempVarPrefix)) == 0) ? std::string("ans") : arg[0]->name();
	std::string val = arg[0]->i2().string();
	char buf[2048];
	sprintf(buf, "%s = %s\n", name.c_str(), val.c_str());
	cprintf(buf);
	return arg[0];
}

consoleVariable *cf_i2ga_print_prec(consoleScope *s, consoleVariable *arg[]) {
	const char *name = arg[0]->name().c_str();
	char precstr[256];
	sprintf(precstr, "%c%s", '%', arg[1]->name().c_str());
	/*
	cprintf("%s = %s\n", 
		(strstr(name, sc_tempVarPrefix) == name) ? "ans" : name, 
		arg[0]->i2().string(precstr));*/
	char buf[2048];
	sprintf(buf, "%s = %s\n", (strstr(name, sc_tempVarPrefix) == name) ? "ans" : name, 
		arg[0]->i2().string(precstr));
	cprintf(buf);

	return arg[0];
}

// ********************************* i2ga ASSIGN *********************************
consoleVariable *cf_i2ga_assign(consoleScope *s, consoleVariable *arg[]) {
	consoleVariable *cv = s->assignVariable(arg[0], arg[1]);
	cv->name(arg[0]->name());
	return cv;
}

// ********************************* i2ga GRADE *********************************
consoleVariable *cf_i2ga_grade(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", arg[0]->i2()(1 << ((int)arg[1]->i2().scalar())));
}

// ********************************* i2ga GRADE *********************************
consoleVariable *cf_i2ga_grade_nb(consoleScope *s, consoleVariable *arg[]) {
	int grade, type = arg[0]->i2().mvType(&grade); // epsilon?
	if (type == GA_BLADE)
		grade = (int)(log((double)grade) / log((double)2) + 0.45);
	else grade = -1;

	return new consoleVariable("",  i2ga((GAIM_FLOAT)grade));
}

// ********************************* i2ga VERSOR PARITY *********************************
consoleVariable *cf_i2ga_versor_parity(consoleScope *s, consoleVariable *arg[]) {
	int grade, type = arg[0]->i2().mvType(&grade); // epsilon?
	if ((type == GA_BLADE) || (type == GA_VERSOR))
		grade = arg[0]->i2().largestGrade() & 1;
	else grade = -1;

	return new consoleVariable("",  i2ga((GAIM_FLOAT)grade));
}

// ********************************* i2ga NORM *********************************
consoleVariable *cf_i2ga_norm(consoleScope *s, consoleVariable *arg[]) {
	GAIM_FLOAT n = arg[0]->i2().norm_b();
	n = sqrt(fabs(n)) * ((n < 0) ? -1.0 : 1.0);
	return new consoleVariable("", i2ga(n));
}

// ********************************* i2ga NORM_A *********************************
consoleVariable *cf_i2ga_norm_2(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", i2ga(arg[0]->i2().norm_a()));
}
// ********************************* i2ga NORM_B *********************************
consoleVariable *cf_i2ga_norm_r(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", i2ga(arg[0]->i2().norm_b()));
}

// ********************************* i2ga NORMALIZE *********************************
consoleVariable *cf_i2ga_normalize(consoleScope *s, consoleVariable *arg[]) {
	GAIM_FLOAT n = sqrt(fabs(arg[0]->i2().norm_b()));
	return new consoleVariable("", i2ga(arg[0]->i2() * ((n == 0.0) ? 0.0 : (1.0 / n))));
}

// ********************************* i2ga SQRT *********************************
consoleVariable *cf_i2ga_sqrt(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", i2ga(sqrt(arg[0]->i2().scalar())));
}

// ********************************* i2ga ABS *********************************
consoleVariable *cf_i2ga_abs(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", i2ga(fabs(arg[0]->i2().scalar())));
}

// ********************************* i2ga TAN *********************************
consoleVariable *cf_i2ga_tan(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", i2ga(tan(arg[0]->i2().scalar())));
}

// ********************************* i2ga COS *********************************
consoleVariable *cf_i2ga_cos(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", i2ga(cos(arg[0]->i2().scalar())));
}

// ********************************* i2ga SIN *********************************
consoleVariable *cf_i2ga_sin(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", i2ga(sin(arg[0]->i2().scalar())));
}

// ********************************* i2ga COSH *********************************
consoleVariable *cf_i2ga_cosh(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", i2ga(cosh(arg[0]->i2().scalar())));
}

// ********************************* i2ga SINH *********************************
consoleVariable *cf_i2ga_sinh(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", i2ga(sinh(arg[0]->i2().scalar())));
}

// ********************************* i2ga ACOSH *********************************
consoleVariable *cf_i2ga_acosh(consoleScope *s, consoleVariable *arg[]) {
	double x = arg[0]->i2().scalar();
	double value = (x >= 1) ? log(x + sqrt(x*x-1)) : 0.0;
	return new consoleVariable("", i2ga(value));
}


// ********************************* i2ga ASINH *********************************
consoleVariable *cf_i2ga_asinh(consoleScope *s, consoleVariable *arg[]) {
	i2ga B = arg[0]->i2().grade(GRADE2);
	if (B.norm_a() != 0.0) {
		double B2 = gp(B, B).scalar();
		if (B2 < 0.0) {
			double sqrtMB2 = sqrt(-B2);
			return new consoleVariable("", op(asin(sqrtMB2) / sqrtMB2, B));
		}
		else if (B2 == 0.0) {
			return new consoleVariable("", B);
		}
		else {
			double sqrtB2 = sqrt(B2);
			return new consoleVariable("", op(asinhScalar(sqrtB2) / sqrtB2, B));
		}
	}
	else {
		double x = arg[0]->i2().scalar();
		double value = asinhScalar(x);
		return new consoleVariable("", i2ga(value));
	}
	
}

// ********************************* i2ga ATAN *********************************
consoleVariable *cf_i2ga_atan(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", i2ga(atan(arg[0]->i2().scalar())));
}

// ********************************* i2ga ATAN2 *********************************
consoleVariable *cf_i2ga_atan2(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", i2ga(atan2(arg[0]->i2().scalar(), arg[1]->i2().scalar())));
}

// ********************************* i2ga MAX *********************************
consoleVariable *cf_i2ga_max(consoleScope *s, consoleVariable *arg[]) {
	GAIM_FLOAT val = (arg[0]->scalar() > arg[1]->scalar()) 
		? arg[0]->scalar() : arg[1]->scalar();
	return new consoleVariable("", i2ga(val));
}

// ********************************* i2ga MIN *********************************
consoleVariable *cf_i2ga_min(consoleScope *s, consoleVariable *arg[]) {
	GAIM_FLOAT val = (arg[0]->scalar() < arg[1]->scalar()) 
		? arg[0]->scalar() : arg[1]->scalar();
	return new consoleVariable("", i2ga(val));
}

// ********************************* i2ga ACOS *********************************
consoleVariable *cf_i2ga_acos(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", i2ga(acos(arg[0]->i2().scalar())));
}

// ********************************* i2ga ASIN *********************************
consoleVariable *cf_i2ga_asin(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", i2ga(asin(arg[0]->i2().scalar())));
}

// ********************************* i2ga SINC *********************************
consoleVariable *cf_i2ga_sinc(consoleScope *s, consoleVariable *arg[]) {
	double x = arg[0]->i2().scalar();
	if (x == 0.0) return new consoleVariable("", i2ga(1.0));
	else return new consoleVariable("", i2ga(sin(x)/x));
}

// ********************************* i2ga EXP *********************************
consoleVariable *cf_i2ga_exp(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", i2ga(arg[0]->i2().exp(12)));
}

// ********************************* i2ga LOG *********************************
consoleVariable *cf_i2ga_log(consoleScope *s, consoleVariable *arg[]) {
	double x = arg[0]->i2().scalar();
	if (x == 0.0)	return new consoleVariable("", i2ga(0));
	else if (x > 0.0) return new consoleVariable("", i2ga(log(x)));
	else return new consoleVariable("", i2ga(M_PI * (i2ga::e1 ^ i2ga::e2) + log(-x)));
}

// ********************************* i2ga SCALAR_POW *********************************
consoleVariable *cf_i2ga_scalar_pow(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", i2ga(pow(arg[0]->i2().scalar(), arg[1]->i2().scalar())));
}

// ********************************* i2ga RANDOM SEED *********************************
consoleVariable *cf_i2ga_randSeed(consoleScope *s, consoleVariable *arg[]) {
	double _seed = arg[0]->i2().scalar();
	unsigned long seed = (unsigned long )(_seed * 32768.0);
	sgenrand(seed);
		
	return new consoleVariable("", i2ga(0.0));
}


// ********************************* i2ga RANDOM GAUSS NUMBER *********************************
consoleVariable *cf_i2ga_randGauss(consoleScope *s, consoleVariable *arg[]) {
	double mean = arg[0]->i2().scalar();
	double variance = arg[1]->i2().scalar();
	return new consoleVariable("", i2ga(gaussNoise(mean, variance)));
}

// ********************************* i2ga POW *********************************
consoleVariable *cf_i2ga_pow(consoleScope *s, consoleVariable *arg[]) {
	int n = (int)(arg[1]->i2().scalar() + 0.5), i;
	i2ga r(1.0);
	for (i = 0; i < n; i++)
		r = r * arg[0]->i2();

	return new consoleVariable("", r);
}

// ********************************* i2ga VERSOR PRODUCT *********************************
consoleVariable *cf_i2ga_versorProduct(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", i2ga(arg[0]->i2() * arg[1]->i2() * arg[0]->i2().inverse()));
}

// ********************************* i2ga INVERSE VERSOR PRODUCT *********************************
consoleVariable *cf_i2ga_inverseVersorProduct(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", i2ga(arg[0]->i2().inverse() * arg[1]->i2() * arg[0]->i2()));
}

// ********************************* i2ga mierenneuk VERSOR PRODUCT *********************************
consoleVariable *cf_i2ga_MNversorProduct(consoleScope *s, consoleVariable *arg[]) {
	i2ga v = arg[0]->i2();
	i2ga o = arg[1]->i2();
	
	int vgrade = v.largestGrade() & 1;

	if (vgrade)	 return new consoleVariable("", i2ga(v * o.gradeInvolution() * v.inverse()));
	else return new consoleVariable("", i2ga(v * o * v.inverse()));
}

// ********************************* i2ga mierenneuk INVERSE VERSOR PRODUCT *********************************
consoleVariable *cf_i2ga_MNinverseVersorProduct(consoleScope *s, consoleVariable *arg[]) {
	i2ga v = arg[0]->i2();
	i2ga o = arg[1]->i2();
	
	int vgrade = v.largestGrade() & 1;

	if (vgrade)	 return new consoleVariable("", i2ga(v.inverse() * o.gradeInvolution() * v));
	else return new consoleVariable("", i2ga(v.inverse() * o * v));
}


// ********************************* i2ga PROJECT *********************************
consoleVariable *cf_i2ga_project(consoleScope *s, consoleVariable *arg[]) {
	i2ga tmp;
	tmp.project(arg[1]->i2(), arg[0]->i2());
	return new consoleVariable("", tmp);
}

// ********************************* i2ga reject *********************************
consoleVariable *cf_i2ga_reject(consoleScope *s, consoleVariable *arg[]) {
	i2ga tmp;
	tmp.reject(arg[1]->i2(), arg[0]->i2());
	return new consoleVariable("", tmp);
}

// ********************************* i2ga factor *********************************
consoleVariable *cf_i2ga_factor(consoleScope *s, consoleVariable *arg[]) {
	i2ga tmp[5];
	arg[0]->i2().factor(tmp);

	int f = (int)(arg[1]->i2().scalar()) - 1;
	if (f > 4) f = 4;
	else if (f < 0) f = 0;

	return new consoleVariable("", tmp[f]);
}

// ********************************* i2ga set_factor *********************************
consoleVariable *cf_i2ga_set_factor(consoleScope *s, consoleVariable *arg[]) {
	int idx = (int)arg[0]->scalar();
	g_state->setI2gaFactor(arg[1]->i2(), idx);
	return arg[1];
}

// ********************************* i2ga equal *********************************
consoleVariable *cf_i2ga_equal(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", i2ga((arg[0]->i2() - arg[1]->i2()).norm_a() == 0.0));
}

// ********************************* i2ga ne *********************************
consoleVariable *cf_i2ga_ne(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", i2ga((arg[0]->i2() - arg[1]->i2()).norm_a() != 0.0));
}

// ********************************* i2ga less *********************************
consoleVariable *cf_i2ga_less(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", i2ga(arg[0]->i2().scalar() < arg[1]->i2().scalar()));
}
// ********************************* i2ga greater *********************************
consoleVariable *cf_i2ga_greater(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", i2ga(arg[0]->i2().scalar() > arg[1]->i2().scalar()));
}
// ********************************* i2ga le *********************************
consoleVariable *cf_i2ga_le(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", i2ga(arg[0]->i2().scalar() <= arg[1]->i2().scalar()));
}
// ********************************* i2ga ge *********************************
consoleVariable *cf_i2ga_ge(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", i2ga(arg[0]->i2().scalar() >= arg[1]->i2().scalar()));
}

// ********************************* i2ga and *********************************
consoleVariable *cf_i2ga_and(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", i2ga(((arg[0]->i2().norm_a() != 0.0) && (arg[1]->i2().norm_a() != 0.0))));
}
// ********************************* i2ga or *********************************
consoleVariable *cf_i2ga_or(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", i2ga(((arg[0]->i2().norm_a() != 0.0) || (arg[1]->i2().norm_a() != 0.0))));
}

// ********************************* i2ga not *********************************
consoleVariable *cf_i2ga_not(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", i2ga(arg[0]->i2().norm_a() == 0.0));
}


// ********************************* e3ga CAST *********************************
consoleVariable *cf_e3ga_to_e3ga(consoleScope *s, consoleVariable *arg[]) {
	return arg[0]->castToE3ga();
}

// ********************************* e3ga CAST *********************************
consoleVariable *cf_e3ga_to_p3ga(consoleScope *s, consoleVariable *arg[]) {
	return arg[0]->castToP3ga();
}

// ********************************* e3ga CAST *********************************
consoleVariable *cf_e3ga_to_c3ga(consoleScope *s, consoleVariable *arg[]) {
	return arg[0]->castToC3ga();
}

// ********************************* e3ga CAST *********************************
consoleVariable *cf_e3ga_to_c5ga(consoleScope *s, consoleVariable *arg[]) {
	return arg[0]->castToC5ga();
}

// ********************************* e3ga CAST *********************************
consoleVariable *cf_e3ga_to_i2ga(consoleScope *s, consoleVariable *arg[]) {
	return arg[0]->castToI2ga();
}

// ********************************* p3ga CAST *********************************
consoleVariable *cf_p3ga_to_e3ga(consoleScope *s, consoleVariable *arg[]) {
	return arg[0]->castToE3ga();
}

// ********************************* p3ga CAST *********************************
consoleVariable *cf_p3ga_to_p3ga(consoleScope *s, consoleVariable *arg[]) {
	return arg[0]->castToP3ga();
}

// ********************************* p3ga CAST *********************************
consoleVariable *cf_p3ga_to_c3ga(consoleScope *s, consoleVariable *arg[]) {
	return arg[0]->castToC3ga();
}

// ********************************* p3ga CAST *********************************
consoleVariable *cf_p3ga_to_c5ga(consoleScope *s, consoleVariable *arg[]) {
	return arg[0]->castToC5ga();
}

// ********************************* p3ga CAST *********************************
consoleVariable *cf_p3ga_to_i2ga(consoleScope *s, consoleVariable *arg[]) {
	return arg[0]->castToI2ga();
}

// ********************************* c3ga CAST *********************************
consoleVariable *cf_c3ga_to_e3ga(consoleScope *s, consoleVariable *arg[]) {
	return arg[0]->castToE3ga();
}

// ********************************* c3ga CAST *********************************
consoleVariable *cf_c3ga_to_p3ga(consoleScope *s, consoleVariable *arg[]) {
	return arg[0]->castToP3ga();
}

// ********************************* c3ga CAST *********************************
consoleVariable *cf_c3ga_to_c3ga(consoleScope *s, consoleVariable *arg[]) {
	return arg[0]->castToC3ga();
}

// ********************************* c3ga CAST *********************************
consoleVariable *cf_c3ga_to_c5ga(consoleScope *s, consoleVariable *arg[]) {
	return arg[0]->castToC5ga();
}

// ********************************* c3ga CAST *********************************
consoleVariable *cf_c3ga_to_i2ga(consoleScope *s, consoleVariable *arg[]) {
	return arg[0]->castToI2ga();
}

// ********************************* c5ga CAST *********************************
consoleVariable *cf_c5ga_to_e3ga(consoleScope *s, consoleVariable *arg[]) {
	return arg[0]->castToE3ga();
}

// ********************************* c5ga CAST *********************************
consoleVariable *cf_c5ga_to_p3ga(consoleScope *s, consoleVariable *arg[]) {
	return arg[0]->castToP3ga();
}

// ********************************* c5ga CAST *********************************
consoleVariable *cf_c5ga_to_c3ga(consoleScope *s, consoleVariable *arg[]) {
	return arg[0]->castToC3ga();
}

// ********************************* c5ga CAST *********************************
consoleVariable *cf_c5ga_to_c5ga(consoleScope *s, consoleVariable *arg[]) {
	return arg[0]->castToC5ga();
}

// ********************************* c5ga CAST *********************************
consoleVariable *cf_c5ga_to_i2ga(consoleScope *s, consoleVariable *arg[]) {
	return arg[0]->castToI2ga();
}

// ********************************* i2ga CAST *********************************
consoleVariable *cf_i2ga_to_e3ga(consoleScope *s, consoleVariable *arg[]) {
	return arg[0]->castToE3ga();
}

// ********************************* i2ga CAST *********************************
consoleVariable *cf_i2ga_to_p3ga(consoleScope *s, consoleVariable *arg[]) {
	return arg[0]->castToP3ga();
}

// ********************************* i2ga CAST *********************************
consoleVariable *cf_i2ga_to_c3ga(consoleScope *s, consoleVariable *arg[]) {
	return arg[0]->castToC3ga();
}

// ********************************* i2ga CAST *********************************
consoleVariable *cf_i2ga_to_c5ga(consoleScope *s, consoleVariable *arg[]) {
	return arg[0]->castToC5ga();
}

// ********************************* i2ga CAST *********************************
consoleVariable *cf_i2ga_to_i2ga(consoleScope *s, consoleVariable *arg[]) {
	return arg[0]->castToI2ga();
}

consoleVariable *cf_p3ga_point3(consoleScope *s, consoleVariable *arg[]) {
	p3ga pt(arg[0]->e().scalar() * p3ga::e1 + arg[1]->e().scalar() * p3ga::e2 + arg[2]->e().scalar() * p3ga::e3 + p3ga::e0);
	return new consoleVariable("", pt);
}

consoleVariable *cf_p3ga_point1(consoleScope *s, consoleVariable *arg[]) {
	const GAIM_FLOAT *c = arg[0]->e()[GRADE1];
	p3ga pt(c[E3GA_E1] * p3ga::e1 + c[E3GA_E2] * p3ga::e2 + c[E3GA_E3] * p3ga::e3 + p3ga::e0);
	return new consoleVariable("", pt);
}

consoleVariable *cf_c3ga_point3(consoleScope *s, consoleVariable *arg[]) {
	GAIM_FLOAT e1c = arg[0]->e().scalar(), e2c = arg[1]->e().scalar(), e3c = arg[2]->e().scalar();
	c3ga pt(GRADE1, e1c, e2c, e3c, 1.0, 0.5 * (e1c * e1c + e2c * e2c + e3c * e3c));
	return new consoleVariable("", pt);
}

consoleVariable *cf_c3ga_point1(consoleScope *s, consoleVariable *arg[]) {
	const GAIM_FLOAT *c = arg[0]->e()[GRADE1];
	GAIM_FLOAT e1c = c[E3GA_E1], e2c  = c[E3GA_E2], e3c = c[E3GA_E3];
	c3ga pt(GRADE1, e1c, e2c, e3c, 1.0, 0.5 * (e1c * e1c + e2c * e2c + e3c * e3c));
	return new consoleVariable("", pt);
}

consoleVariable *cf_c3ga_pointP1(consoleScope *s, consoleVariable *arg[]) {
	const GAIM_FLOAT *c = arg[0]->p()[GRADE1];
	GAIM_FLOAT e0c = c[P3GA_E0];
	GAIM_FLOAT e1c, e2c, e3c;
	if (e0c != 0.0)	{e1c = c[P3GA_E1] / e0c; e2c  = c[P3GA_E2] / e0c; e3c = c[P3GA_E3] / e0c;}
	else {e1c = c[P3GA_E1]; e2c  = c[P3GA_E2]; e3c = c[P3GA_E3];}

	c3ga pt(GRADE1, e1c, e2c, e3c, 1.0, 0.5 * (e1c * e1c + e2c * e2c + e3c * e3c));
	return new consoleVariable("", pt);
}



consoleVariable *cf_translation_versor3(consoleScope *s, consoleVariable *arg[]) {
	GAIM_FLOAT e1c = arg[0]->e().scalar(), e2c = arg[1]->e().scalar(), e3c = arg[2]->e().scalar();
	c3ga t(GRADE1, e1c, e2c, e3c, 0.0, 0.0);
	c3ga tv = 1 - 0.5 * (t ^ c3ga::ni);
	return new consoleVariable("", tv);
}

consoleVariable *cf_translation_versor1(consoleScope *s, consoleVariable *arg[]) {
	const GAIM_FLOAT *c = arg[0]->e()[GRADE1];
	GAIM_FLOAT e1c = c[E3GA_E1], e2c  = c[E3GA_E2], e3c = c[E3GA_E3];
	c3ga t(GRADE1, e1c, e2c, e3c, 0.0, 0.0);
	c3ga tv = 1 - 0.5 * (t ^ c3ga::ni);
	return new consoleVariable("", tv);
}


// ********************************* CLF *********************************
consoleVariable *cf_clf(consoleScope *s, consoleVariable *arg[]) {
	g_state->removeAllObjects();
	g_state->setDefaultGlobalScopeVariables();
	
	gui_state->setStatus("");
	return new consoleVariable("", e3ga(0.0));
}

// ********************************* CLC *********************************
consoleVariable *cf_clc(consoleScope *s, consoleVariable *arg[]) {
	if (gui_state && (gui_state->m_console))
		gui_state->m_console->clear();
	if (g_state)
		g_state->removeAllConsoleControls();

	return new consoleVariable("", e3ga(0.0));
}


// ********************************* RED .. GRAY *********************************

consoleVariable *cf_set_object_X_color4(const std::string &objectName,
	int X, 
	float R, float G, float B, float A) {
	e3ga tmp(0.0);
	object *O = g_state->getObjectPtrByName(objectName);
	if (O == NULL) {	
		return new consoleVariable("", tmp);
	}
	else {
		float C[4] = {R, G, B, A};
		if (X == 0) O->setFgColor(C);
		else if (X == 1) O->setBgColor(C);
		else if (X == 2) O->setOlColor(C);
	}

	return new consoleVariable("", tmp);
}

consoleVariable *cf_set_object_X_color3(const std::string &objectName,
	int X,
	float R, float G, float B) {
	e3ga tmp(0.0);
	object *O = g_state->getObjectPtrByName(objectName);
	if (O == NULL) {	
		return new consoleVariable("", tmp);
	}
	else {
		float A = 1.0;
		if (X == 0) A = O->fgColor(3);
		else if (X == 1) A = O->bgColor(3);
		else if (X == 2) A = O->olColor(3);
		return cf_set_object_X_color4(objectName, X, R, G, B, A);
	}
}

consoleVariable *cf_set_object_fg_color_vector(consoleScope *s, consoleVariable *arg[]) {
	const std::string &objectName = arg[0]->name();
	return cf_set_object_X_color3(objectName, 0, (float)arg[1]->e()[GRADE1][0], (float)arg[1]->e()[GRADE1][1], (float)arg[1]->e()[GRADE1][2]);
}

consoleVariable *cf_set_object_fg_color_RGB(consoleScope *s, consoleVariable *arg[]) {
	const std::string &objectName = arg[0]->name();
	return cf_set_object_X_color3(objectName, 0, (float)arg[1]->e().scalar(), (float)arg[2]->e().scalar(), (float)arg[3]->e().scalar());
}
consoleVariable *cf_set_object_fg_color_RGBA(consoleScope *s, consoleVariable *arg[]) {
	const std::string &objectName = arg[0]->name();
	return cf_set_object_X_color4(objectName, 0, (float)arg[1]->e().scalar(), (float)arg[2]->e().scalar(), (float)arg[3]->e().scalar(), (float)arg[4]->e().scalar());
}

static consoleVariable *cf_set_color3_internal(consoleScope *s, consoleVariable *arg[], float c[3]) {
	arg[0]->color3(c);
	arg[0]->modifiedColor();
	return arg[0];
}

consoleVariable *cf_red(consoleScope *s, consoleVariable *arg[]) {
	float c[4];	::getColor("red", c); return cf_set_color3_internal(s, arg, c);
}

consoleVariable *cf_green(consoleScope *s, consoleVariable *arg[]) {
	float c[4];	::getColor("green", c); return cf_set_color3_internal(s, arg, c);
}

consoleVariable *cf_blue(consoleScope *s, consoleVariable *arg[]) {
	float c[4];	::getColor("blue", c); return cf_set_color3_internal(s, arg, c);
}

consoleVariable *cf_white(consoleScope *s, consoleVariable *arg[]) {
	float c[4];	::getColor("white", c); return cf_set_color3_internal(s, arg, c);
}

consoleVariable *cf_magenta(consoleScope *s, consoleVariable *arg[]) {
	float c[4];	::getColor("magenta", c); return cf_set_color3_internal(s, arg, c);
}

consoleVariable *cf_yellow(consoleScope *s, consoleVariable *arg[]) {
	float c[4];	::getColor("yellow", c); return cf_set_color3_internal(s, arg, c);
}

consoleVariable *cf_cyan(consoleScope *s, consoleVariable *arg[]) {
	float c[4];	::getColor("cyan", c); return cf_set_color3_internal(s, arg, c);
}

consoleVariable *cf_black(consoleScope *s, consoleVariable *arg[]) {
	float c[4];	::getColor("black", c); return cf_set_color3_internal(s, arg, c);
}

consoleVariable *cf_grey(consoleScope *s, consoleVariable *arg[]) {
	float c[4];	::getColor("grey", c); return cf_set_color3_internal(s, arg, c);
}

consoleVariable *cf_color1(consoleScope *s, consoleVariable *arg[]) {
	const GAIM_FLOAT *c = arg[1]->e()[GRADE1];
	arg[0]->color3((float)c[E3GA_E1], (float)c[E3GA_E2], (float)c[E3GA_E3]);
	arg[0]->modifiedColor();
	return arg[0];
}

consoleVariable *cf_color3(consoleScope *s, consoleVariable *arg[]) {
	arg[0]->color3((float)arg[1]->e().scalar(), (float)arg[2]->e().scalar(), (float)arg[3]->e().scalar());
	arg[0]->modifiedColor();
	return arg[0];
}

consoleVariable *cf_color4(consoleScope *s, consoleVariable *arg[]) {
	arg[0]->color4((float)arg[1]->e().scalar(), (float)arg[2]->e().scalar(), (float)arg[3]->e().scalar(), (float)arg[4]->e().scalar());
	arg[0]->modifiedColor();
	arg[0]->modifiedAlpha();
	return arg[0];
}

static consoleVariable *cf_alpha_internal(consoleVariable *arg0, float arg1) {
	arg0->alpha(arg1);
	arg0->modifiedAlpha();
	return arg0;
}

consoleVariable *cf_alpha(consoleScope *s, consoleVariable *arg[]) {
	return cf_alpha_internal(arg[0], (float)arg[1]->e().scalar());
}

consoleVariable *cf_versor(consoleScope *s, consoleVariable *arg[]) {
	arg[0]->creationFlags(arg[0]->creationFlags() | OC_VERSOR);	
	return arg[0];
}

consoleVariable *cf_blade(consoleScope *s, consoleVariable *arg[]) {
	arg[0]->creationFlags(arg[0]->creationFlags() | OC_BLADE);	
	return arg[0];
}

consoleVariable *cf_dm1(consoleScope *s, consoleVariable *arg[]) {
	arg[0]->creationFlags((arg[0]->creationFlags() ^ (arg[0]->creationFlags() & OC_DM7)) | OC_DM1);	
	arg[0]->modifiedDrawMethod();
	return arg[0];
}
consoleVariable *cf_dm2(consoleScope *s, consoleVariable *arg[]) {
	arg[0]->creationFlags((arg[0]->creationFlags() ^ (arg[0]->creationFlags() & OC_DM7)) | OC_DM2);	
	arg[0]->modifiedDrawMethod();
	return arg[0];
}
consoleVariable *cf_dm3(consoleScope *s, consoleVariable *arg[]) {
	arg[0]->creationFlags((arg[0]->creationFlags() ^ (arg[0]->creationFlags() & OC_DM7)) | OC_DM3);	
	arg[0]->modifiedDrawMethod();
	return arg[0];
}
consoleVariable *cf_dm4(consoleScope *s, consoleVariable *arg[]) {
	arg[0]->creationFlags((arg[0]->creationFlags() ^ (arg[0]->creationFlags() & OC_DM7)) | OC_DM4);	
	arg[0]->modifiedDrawMethod();
	return arg[0];
}
consoleVariable *cf_dm5(consoleScope *s, consoleVariable *arg[]) {
	arg[0]->creationFlags((arg[0]->creationFlags() ^ (arg[0]->creationFlags() & OC_DM7)) | OC_DM5);	
	arg[0]->modifiedDrawMethod();
	return arg[0];
}
consoleVariable *cf_dm6(consoleScope *s, consoleVariable *arg[]) {
	arg[0]->creationFlags((arg[0]->creationFlags() ^ (arg[0]->creationFlags() & OC_DM7)) | OC_DM6);	
	arg[0]->modifiedDrawMethod();
	return arg[0];
}
consoleVariable *cf_dm7(consoleScope *s, consoleVariable *arg[]) {
	arg[0]->creationFlags((arg[0]->creationFlags() ^ (arg[0]->creationFlags() & OC_DM7)) | OC_DM7);	
	arg[0]->modifiedDrawMethod();
	return arg[0];
}

consoleVariable *cf_stipple(consoleScope *s, consoleVariable *arg[]) {
	arg[0]->drawMode(arg[0]->drawMode() | OD_STIPPLE);	
	arg[0]->modifiedStipple();
	return arg[0];
}

consoleVariable *cf_no_stipple(consoleScope *s, consoleVariable *arg[]) {
	arg[0]->drawMode(arg[0]->drawMode() ^ (arg[0]->drawMode() & OD_STIPPLE));	
	arg[0]->modifiedStipple();
	return arg[0];
}

consoleVariable *cf_ori(consoleScope *s, consoleVariable *arg[]) {
	arg[0]->drawMode(arg[0]->drawMode() | OD_ORI);	
	arg[0]->modifiedOri();
	return arg[0];
}

consoleVariable *cf_no_ori(consoleScope *s, consoleVariable *arg[]) {
	arg[0]->drawMode(arg[0]->drawMode() ^ (arg[0]->drawMode() & OD_ORI));	
	arg[0]->modifiedOri();
	return arg[0];
}

consoleVariable *cf_mute(consoleScope *s, consoleVariable *arg[]) {
	arg[0]->drawMode(arg[0]->drawMode() | OD_MUTE);	
	arg[0]->modifiedMute();
	return arg[0];
}

consoleVariable *cf_unmute(consoleScope *s, consoleVariable *arg[]) {
	arg[0]->drawMode(arg[0]->drawMode() ^ (arg[0]->drawMode() & OD_MUTE));	
	arg[0]->modifiedMute();
	return arg[0];
}

consoleVariable *cf_hide(consoleScope *s, consoleVariable *arg[]) {
	arg[0]->drawMode(arg[0]->drawMode() | OD_HIDE);	
	arg[0]->modifiedHide();
	return arg[0];
}

consoleVariable *cf_show(consoleScope *s, consoleVariable *arg[]) {
	arg[0]->drawMode(arg[0]->drawMode() ^ (arg[0]->drawMode() & OD_HIDE));
	arg[0]->modifiedHide();
	return arg[0];
}

consoleVariable *cf_wireframe(consoleScope *s, consoleVariable *arg[]) {
	arg[0]->drawMode(arg[0]->drawMode() | OD_WIREFRAME);	
	arg[0]->modifiedWireframe();
	return arg[0];
}

consoleVariable *cf_no_wireframe(consoleScope *s, consoleVariable *arg[]) {
	arg[0]->drawMode(arg[0]->drawMode() ^ (arg[0]->drawMode() & OD_WIREFRAME));
	arg[0]->modifiedWireframe();
	return arg[0];
}

consoleVariable *cf_shade(consoleScope *s, consoleVariable *arg[]) {
	arg[0]->drawMode(arg[0]->drawMode() | OD_SHADE);
	arg[0]->modifiedShade();
	return arg[0];
}

consoleVariable *cf_no_shade(consoleScope *s, consoleVariable *arg[]) {
	arg[0]->drawMode(arg[0]->drawMode() ^ (arg[0]->drawMode() & OD_SHADE));	
	arg[0]->modifiedShade();
	return arg[0];
}

consoleVariable *cf_outline(consoleScope *s, consoleVariable *arg[]) {
	arg[0]->drawMode(arg[0]->drawMode() | OD_OUTLINE);	
	arg[0]->modifiedOutline();
	return arg[0];
}

consoleVariable *cf_no_outline(consoleScope *s, consoleVariable *arg[]) {
	arg[0]->drawMode(arg[0]->drawMode() ^ (arg[0]->drawMode() & OD_OUTLINE));	
	arg[0]->modifiedOutline();
	return arg[0];
}

consoleVariable *cf_no_weight(consoleScope *s, consoleVariable *arg[]) {
	arg[0]->drawMode(arg[0]->drawMode() ^ (arg[0]->drawMode() & OD_MAGNITUDE));	
	arg[0]->modifiedMagnitude();
	return arg[0];
}

consoleVariable *cf_weight(consoleScope *s, consoleVariable *arg[]) {
	arg[0]->drawMode(arg[0]->drawMode() | OD_MAGNITUDE);	
	arg[0]->modifiedMagnitude();
	return arg[0];
}


consoleVariable *cf_get_color(consoleScope *s, consoleVariable *arg[]) {
	const float *c = arg[0]->color();
	return new consoleVariable("", e3ga(GRADE1, c[0], c[1], c[2]));
}

consoleVariable *cf_get_alpha(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", e3ga((GAIM_FLOAT)arg[0]->alpha()));
}

consoleVariable *cf_get_stipple(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", e3ga((GAIM_FLOAT)((arg[0]->drawMode() & OD_STIPPLE) != 0)));
}
consoleVariable *cf_get_wireframe(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", e3ga((GAIM_FLOAT)((arg[0]->drawMode() & OD_WIREFRAME) != 0)));
}
consoleVariable *cf_get_outline(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", e3ga((GAIM_FLOAT)((arg[0]->drawMode() & OD_OUTLINE) != 0)));
}
consoleVariable *cf_get_weight(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", e3ga((GAIM_FLOAT)((arg[0]->drawMode() & OD_MAGNITUDE) != 0)));
}
consoleVariable *cf_get_ori(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", e3ga((GAIM_FLOAT)((arg[0]->drawMode() & OD_ORI) != 0)));
}
consoleVariable *cf_get_hide(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", e3ga((GAIM_FLOAT)((arg[0]->drawMode() & OD_HIDE) != 0)));
}


consoleVariable *cf_bit_not(consoleScope *s, consoleVariable *arg[]) {
	GAIM_FLOAT s1 = arg[0]->scalar();
	s1 += (s1 >= 0.0) ? 0.5 : -0.5;
	unsigned int i1 = (unsigned int)(s1 + ((s1 >= 0.0) ? 0.5 : -0.5));
	i1 = (unsigned int)0xFFFFFFFF ^ i1;
	return new consoleVariable("", e3ga((GAIM_FLOAT)i1));
}

consoleVariable *cf_bit_and(consoleScope *s, consoleVariable *arg[]) {
	GAIM_FLOAT s1 = arg[0]->scalar();
	unsigned int i1 = (unsigned int)(s1 + ((s1 >= 0.0) ? 0.5 : -0.5));

	GAIM_FLOAT s2 = arg[1]->scalar();
	unsigned int i2 = (unsigned int)(s2 + ((s2 >= 0.0) ? 0.5 : -0.5));

	return new consoleVariable("", e3ga((GAIM_FLOAT)(i1 & i2)));
}

consoleVariable *cf_bit_or(consoleScope *s, consoleVariable *arg[]) {
	GAIM_FLOAT s1 = arg[0]->scalar();
	unsigned int i1 = (unsigned int)(s1 + ((s1 >= 0.0) ? 0.5 : -0.5));

	GAIM_FLOAT s2 = arg[1]->scalar();
	unsigned int i2 = (unsigned int)(s2 + ((s2 >= 0.0) ? 0.5 : -0.5));

	return new consoleVariable("", e3ga((GAIM_FLOAT)(i1 | i2)));
}

consoleVariable *cf_bit_xor(consoleScope *s, consoleVariable *arg[]) {
	GAIM_FLOAT s1 = arg[0]->scalar();
	unsigned int i1 = (unsigned int)(s1 + ((s1 >= 0.0) ? 0.5 : -0.5));

	GAIM_FLOAT s2 = arg[1]->scalar();
	unsigned int i2 = (unsigned int)(s2 + ((s2 >= 0.0) ? 0.5 : -0.5));

	return new consoleVariable("", e3ga((GAIM_FLOAT)(i1 ^ i2)));
}

consoleVariable *cf_bit_shift(consoleScope *s, consoleVariable *arg[]) {
	GAIM_FLOAT s1 = arg[0]->scalar();
	unsigned int i1 = (unsigned int)(s1 + ((s1 >= 0.0) ? 0.5 : -0.5));

	GAIM_FLOAT s2 = arg[1]->scalar();
	int i2 = (int)(s2 + ((s2 >= 0.0) ? 0.5 : -0.5));

	if (i2 < 0) return new consoleVariable("", e3ga((GAIM_FLOAT)(i1 >> (-i2))));
	else return new consoleVariable("", e3ga((GAIM_FLOAT)(i1 << (i2))));
}




// ********************************* CREATE POLYGON  *********************************
	
consoleVariable *cf_create_polygon(consoleScope *s, consoleVariable *arg[], int N) { 
	const std::string &polyName = arg[0]->name();
	const std::string &fillMode = arg[1]->name();
	
//	printf("Fillmode = '%s'\n", fillMode.c_str());
	int creationFlags = OC_DM1;
	if (fillMode == "strip") creationFlags = OC_DM2;
	else if (fillMode == "loop") creationFlags = OC_DM3;
	int drawMode = 0;
	
	polygonObject *PO = new polygonObject(polyName, drawMode, creationFlags);
	
	for (int i = 0; i < N; i++) {
		PO->addVertex(arg[2 + i]->name().c_str());
	}	
	
	g_state->addObject(PO);

	
	e3ga tmp(0.0);
	return new consoleVariable("", tmp);
}

consoleVariable *cf_create_polygon_3(consoleScope *s, consoleVariable *arg[]) { 
	return cf_create_polygon(s, arg, 3);
}
consoleVariable *cf_create_polygon_4(consoleScope *s, consoleVariable *arg[]) { 
	return cf_create_polygon(s, arg, 4);
}
consoleVariable *cf_create_polygon_5(consoleScope *s, consoleVariable *arg[]) { 
	return cf_create_polygon(s, arg, 5);
}
consoleVariable *cf_create_polygon_6(consoleScope *s, consoleVariable *arg[]) { 
	return cf_create_polygon(s, arg, 6);
}

consoleVariable *cf_create_arc(consoleScope *s, consoleVariable *arg[]) { 
	// arg 0: name
	// arg 1: versor
	// arg 2: point
	// arg 3: nb of segments
	const std::string &arcName = arg[0]->name();
	c3ga V = arg[1]->c();
	c3ga p = arg[2]->c();
	int nbSegments = arg[3]->scalar();
	
	int polyDrawMode = 0;
	polygonObject *PO = new polygonObject(arcName, polyDrawMode, OC_DM2); // OC_DM2 = strip

	c3ga Vi = V.inverse();
	for (int i = 0; i <= nbSegments; i++) {
		char pointName[1024];
		sprintf(pointName, "%s_point_%d", arcName.c_str(), i);
		g_state->addC3gaObject(p, pointName);
		PO->addVertex(pointName);
		g_state->removeObject(pointName);
		p = V * p * Vi;
	}

	g_state->addObject(PO);
	
	e3ga tmp(0.0);
	return new consoleVariable("", tmp);
}



// ********************************* SCREENSHOT  *********************************
consoleVariable *cf_screenshot(consoleScope *s, consoleVariable *arg[]) {
	int width = (int)(arg[1]->scalar() + 0.5);
	int height = (int)(arg[2]->scalar() + 0.5);
	bool wol = arg[3]->scalar() != 0.0;

	gui_state->setupScreenshot(arg[0]->name(), width, height, wol);

	return new consoleVariable("", e3ga(0.0));
}

// ********************************* SET WINDOW TITLE  *********************************
consoleVariable *cf_set_window_title(consoleScope *s, consoleVariable *arg[]) {
	static char title[1024];
	strcpy(title, (std::string("GAViewer: ") + arg[0]->name()).c_str());
//	strcpy(title, arg[0]->name().c_str());
	if (gui_state->m_mainWindow)
		gui_state->m_mainWindow->label(title);

	return new consoleVariable("", e3ga(0.0));
}


// ********************************* ADD NET PORT  *********************************
consoleVariable *cf_add_net_port(consoleScope *s, consoleVariable *arg[]) {
	char buf[16];
	sprintf(buf, "%d", (int)arg[0]->scalar());
	g_state->openNetServer(buf);

	e3ga tmp(0.0);
	return new consoleVariable("", tmp);
}	

// ********************************* REMOVE NET PORT  *********************************
consoleVariable *cf_remove_net_port(consoleScope *s, consoleVariable *arg[]) {
	char buf[16];
	sprintf(buf, "%d", (int)arg[0]->scalar());
	g_state->closeNetServer(buf);

	e3ga tmp(0.0);
	return new consoleVariable("", tmp);
}	

// ********************************* DISPLAY NET STATUS *********************************
consoleVariable *cf_net_status(consoleScope *s, consoleVariable *arg[]) {
	g_state->displayNetStatus();

	e3ga tmp(0.0);
	return new consoleVariable("", tmp);
}	

// ********************************* CLOSES ALL NETWORK STUFF *********************************
consoleVariable *cf_net_close(consoleScope *s, consoleVariable *arg[]) {
	g_state->closeNetServers();
	
	e3ga tmp(0.0);
	return new consoleVariable("", tmp);
}	

// ********************************* MOUSE INTERACTION *********************************
consoleVariable *cf_disable_mouse_interaction(consoleScope *s, consoleVariable *arg[]) {
	gui_state->setInteractiveMouse(false);
	e3ga tmp(0.0);
	return new consoleVariable("", tmp);
}	

consoleVariable *cf_enable_mouse_interaction(consoleScope *s, consoleVariable *arg[]) {
	gui_state->setInteractiveMouse(true);
	e3ga tmp(0.0);
	return new consoleVariable("", tmp);
}	

// ********************************* SET POINT SIZE  *********************************
consoleVariable *cf_set_point_size(consoleScope *s, consoleVariable *arg[]) {
	gui_state->setPointSize(arg[0]->scalar());
	e3ga tmp(0.0);
	return new consoleVariable("", tmp);
}	

// ********************************* SET NEAR FAR CLIP PLANES*********************************
consoleVariable *cf_set_near_far_clip_planes(consoleScope *s, consoleVariable *arg[]) {
	gui_state->m_glWindow->setNearFarClipPlanes(arg[0]->scalar(), arg[1]->scalar());
	e3ga tmp(0.0);
	return new consoleVariable("", tmp);
}	


// ********************************* SET TEXT SCALE *********************************
consoleVariable *cf_set_text_scale(consoleScope *s, consoleVariable *arg[]) {
	gui_state->setTextScale(fabs(arg[0]->scalar()));
	e3ga tmp(0.0);
	return new consoleVariable("", tmp);
}	

// ********************************* SET LINE WIDTH *********************************
consoleVariable *cf_set_line_width(consoleScope *s, consoleVariable *arg[]) {
	gui_state->setLineWidth(fabs(arg[0]->scalar()));
	e3ga tmp(0.0);
	return new consoleVariable("", tmp);
}	

// ********************************* SET GL LINES *********************************
consoleVariable *cf_set_gl_lines(consoleScope *s, consoleVariable *arg[]) {
	// first set to opposite of requested:
	gui_state->m_tubeDraw.setUseOpenGL(arg[0]->scalar() == 0.0);		
	// then call menu callback (which toggles the value):
	ui_menuCallback(NULL, (void*)MI_GLLINES);
	
	e3ga tmp(0.0);
	return new consoleVariable("", tmp);
}	

// ********************************* SET VECTOR HEAD SIZE *********************************
consoleVariable *cf_set_vector_head_size(consoleScope *s, consoleVariable *arg[]) {
	gui_state->setVectorHeadSize(arg[0]->scalar());
	e3ga tmp(0.0);
	return new consoleVariable("", tmp);
}	

// ********************************* SET POINT SUB DIV *********************************
consoleVariable *cf_set_point_sub_div(consoleScope *s, consoleVariable *arg[]) {
	int subDiv = (int)(arg[0]->scalar() + 0.5);
	if (subDiv < 1) subDiv = 1;
	if (subDiv > 5) subDiv = 5;
	
	gsFree(&g_pointSphere);
	gsCompute(&g_pointSphere, subDiv);
	
	e3ga tmp(0.0);
	return new consoleVariable("", tmp);
}	

// ********************************* SET SPHERE SUB DIV *********************************
consoleVariable *cf_set_sphere_sub_div(consoleScope *s, consoleVariable *arg[]) {
	int subDiv = (int)(arg[0]->scalar() + 0.5);
	if (subDiv < 1) subDiv = 1;
	if (subDiv > 5) subDiv = 5;
	
	gsFree(&g_sphereSphere);
	gsCompute(&g_sphereSphere, subDiv);
	
	e3ga tmp(0.0);
	return new consoleVariable("", tmp);
}	

consoleVariable *cf_cmd(consoleScope *s, consoleVariable *arg[]) {
	e3ga tmp(0.0);

	//cprintf("cmd: '%s'\n", arg[0]->name().c_str());
	g_state->m_consoleGAfile->read(g_state, arg[0]->name().c_str());

	return new consoleVariable("", tmp);
}	

// ********************************* RANDOM NUMBER *********************************
consoleVariable *cf_rand(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", e3ga(genrand()));
//	return new consoleVariable("", i2ga(genrand()));
}

// *********************************  TIME *********************************
consoleVariable *cf_time(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", e3ga(u_timeGet()));
//	return new consoleVariable("", i2ga(u_timeGet()));
}

// ********************************* RANDOM GAUSS NUMBER *********************************
consoleVariable *cf_randGaussStd(consoleScope *s, consoleVariable *arg[]) {
	double mean = 0.0;
	double variance = 1.0;
	return new consoleVariable("", e3ga(gaussNoise(mean, variance)));
	//return new consoleVariable("", i2ga(gaussNoise(mean, variance)));
}



// ********************************* CLD *********************************
consoleVariable *cf_cld(consoleScope *s, consoleVariable *arg[]) {
	g_state->removeAllDynStmt();
	return new consoleVariable("", e3ga(0.0));
}

// ********************************* CLD *********************************
consoleVariable *cf_cld_1(consoleScope *s, consoleVariable *arg[]) {
	g_state->removeDynStmt(arg[0]->name());
	return new consoleVariable("", e3ga(0.0));
}

// ********************************* START ANIMATION *********************************
consoleVariable *cf_start_animation(consoleScope *s, consoleVariable *arg[]) {
	g_state->startAnimation();
	return new consoleVariable("", e3ga(0.0));
}

// ********************************* STOP ANIMATION *********************************
consoleVariable *cf_stop_animation(consoleScope *s, consoleVariable *arg[]) {
	g_state->stopAnimation();
	return new consoleVariable("", e3ga(0.0));
}

// ********************************* PAUSE ANIMATION *********************************
consoleVariable *cf_pause_animation(consoleScope *s, consoleVariable *arg[]) {
	g_state->pauseAnimation();
	return new consoleVariable("", e3ga(0.0));
}


// ********************************* RESET *********************************
consoleVariable *cf_reset(consoleScope *s, consoleVariable *arg[]) {
	if (!s->globalScope()) {
		cprintf("Error: reset() can only be called in global scope\n");
	}
	else s->resetRequested(1);
	return new consoleVariable("", e3ga(0.0));
}

// ********************************* CPRINT *********************************
consoleVariable *cf_cprint(consoleScope *s, consoleVariable *arg[]) {
	e3ga tmp(0.0);

	cprintf("%s\n", arg[0]->name().c_str());

	return new consoleVariable("", tmp);
}	

// ********************************* PROMPT *********************************
consoleVariable *cf_prompt(consoleScope *s, consoleVariable *arg[]) {
	if (gui_state && gui_state->m_console)
		gui_state->m_console->prompt(arg[0]->name().c_str());
	return new consoleVariable("", e3ga(0.0));
}	

// ********************************* PROMPT_DEFAULT *********************************
consoleVariable *cf_prompt_default(consoleScope *s, consoleVariable *arg[]) {
	if (gui_state && gui_state->m_console)
		gui_state->m_console->prompt(">> ");
	return new consoleVariable("", e3ga(0.0));
}	

// ********************************* MUTE WARNINGS *********************************
consoleVariable *cf_mute_warnings(consoleScope *s, consoleVariable *arg[]) {
	if (g_state)
		g_state->m_globalScope->supressWarnings(1);
	return new consoleVariable("", e3ga(0.0));
}

// ********************************* UNMUTE WARNINGS *********************************
consoleVariable *cf_unmute_warnings(consoleScope *s, consoleVariable *arg[]) {
	if (g_state)
		g_state->m_globalScope->supressWarnings(0);
	return new consoleVariable("", e3ga(0.0));
}

// ********************************* DIARY *********************************
consoleVariable *cf_diary(consoleScope *s, consoleVariable *arg[]) {
	const char *filename = NULL;
	gui_state->saveDiary(filename);
	return new consoleVariable("", e3ga(0.0));
}

// ********************************* DIARY *********************************
consoleVariable *cf_diary_filename(consoleScope *s, consoleVariable *arg[]) {
	const char *filename = arg[0]->name().c_str();
	gui_state->saveDiary(filename);
	return new consoleVariable("", e3ga(0.0));
}


// ********************************* SELECT *********************************
consoleVariable *cf_select(consoleScope *s, consoleVariable *arg[]) {
// todo: if select was issued, don't override it in consoleScope:showassignmentlist
	if (gui_state) {
		gui_state->setCurrentObjectByName(arg[0]->name());
	}
	return arg[0];
}	

// ********************************* REMOVE *********************************
consoleVariable *cf_remove(consoleScope *s, consoleVariable *arg[]) {
	if (g_state->removeObject(arg[0]->name()) < 0) {
		cprintf("Error: '%s' does not exist in global scope\n", arg[0]->name().c_str());
	}
	return new consoleVariable("", e3ga(0.0));
}

// ********************************* ADD CONST *********************************
consoleVariable *cf_add_const(consoleScope *s, consoleVariable *arg[]) {
	if (!s->globalScope()) {
		cprintf("add_const() can only be called in the global scope!");
	}
	else {
		((consoleGlobalScope*)s)->addConstant(arg[0]->name(), arg[0]);
	}
	return new consoleVariable("", e3ga(0.0));
}

// ********************************* RENAME BUILTIN CONST *********************************
consoleVariable *cf_rename_builtin_const(consoleScope *s, consoleVariable *arg[]) {
	if (!s->globalScope()) {
		cprintf("rename_builtin_const() can only be called in the global scope!");
	}
	else {
		((consoleGlobalScope*)s)->renameBuiltinConstant(arg[0]->name(), arg[1]->name());
	}
	return new consoleVariable("", e3ga(0.0));
}

// ********************************* REMOVE CONST *********************************
consoleVariable *cf_remove_const(consoleScope *s, consoleVariable *arg[]) {
	if (!s->globalScope()) {
		cprintf("remove_const() can only be called in the global scope!");
	}
	else {
		((consoleGlobalScope*)s)->removeConstant(arg[0]->name());
	}
	return new consoleVariable("", e3ga(0.0));
}

// ********************************* LABEL *********************************
consoleVariable *cf_label(consoleScope *s, consoleVariable *arg[]) {
	g_state->addTextObject(arg[0]->name().c_str(), 	arg[0]->name(), arg[0]->name() + "_label", LABEL_DYNAMIC | LABEL_3D, -1);
	return new consoleVariable("", e3ga(0.0));
}

// ********************************* LABEL 2 *********************************
consoleVariable *cf_label2(consoleScope *s, consoleVariable *arg[]) {
	g_state->addTextObject(arg[1]->name().c_str(), 	arg[0]->name(), arg[0]->name() + "_label", LABEL_DYNAMIC | LABEL_3D, -1);
	return new consoleVariable("", e3ga(0.0));
}


// ********************************* CAMROTFUNC *********************************
consoleVariable *cf_camrotfunc(consoleScope *s, consoleVariable *arg[]) {
	g_state->setRot(arg[0]->e(), arg[1]->scalar());
/*	if (g_state->removeObject(arg[0]->name()) < 0) {
		cprintf("Error: '%s' does not exist in global scope\n", arg[0]->name().c_str());
	}*/
	return new consoleVariable("", e3ga(0.0));
}


// ********************************* GET DRAW FLAGS *********************************
consoleVariable *cf_get_draw_flags(consoleScope *s, consoleVariable *arg[]) {
	return new consoleVariable("", e3ga((GAIM_FLOAT)arg[0]->forceFlags()));
}

// ********************************* GET INTERPRETATION *********************************
consoleVariable *cf_get_interpretation(consoleScope *s, consoleVariable *arg[]) {
	mvInt *mvi = arg[0]->interpretation();
	int interpretation = (mvi && mvi->m_valid) ? mvi->m_type : 0;
	if (mvi) delete mvi;
	return new consoleVariable("", e3ga((GAIM_FLOAT)interpretation));
}

// ********************************* AUTO COLOR *********************************

/*function sign_radiussquared(mv,interpretation)
// interpretation is get_interpretation result minus MVI_C3GA
// compute the sign of the radius squared of a blade
// the answer is 0 for objects without a sensible radius
{
    MVI_BLADE = 256;
    MVI_DUAL = 2048;
    MVI_ROUND = MVI_BLADE + 128;
    if (bit_and(interpretation, MVI_ROUND) ) {
        nimv = ni.mv;
        alphasize = mv ~mv/ (nimv ~nimv);
        if (bit_and(interpretation, MVI_DUAL) ) {
                if (alphasize > 0) return(1); else return(-1);
        } else {
                if (alphasize < 0) return(1); else return(-1);
        }
    } else {
        return(0);
    }
}*/

consoleVariable *cf_autocolorfunc(consoleScope *s, consoleVariable *arg[]) {
	int drawFlags = arg[0]->forceFlags();

	mvInt *mvi = arg[0]->interpretation();
	int interpretation = (mvi && mvi->m_valid) ? mvi->m_type : 0;

	int gr = arg[0]->grade();

	// default grade-related colors
	if (!((drawFlags & OFF_COLOR))) {
		switch(gr) {
		case 0:
			cf_black(s, arg);
			break;
		case 1:
			cf_red(s, arg);
			break;
		case 2:
			cf_blue(s, arg);
			break;
		case 3:
			cf_green(s, arg);
			break;
		case 4:
			cf_yellow(s, arg);
			break;
		case 5:
			cf_white(s, arg);
			break;
		}
	}

	if (!((drawFlags & OFF_ALPHA))) {
		if (interpretation == MVI_E3GA + MVI_TRIVECTOR) 
			cf_alpha_internal(arg[0], 0.5f);
		else if (interpretation == MVI_C3GA + MVI_SPHERE) 
			cf_alpha_internal(arg[0], 0.5f);
		else if (interpretation == MVI_C3GA + MVI_SPHERE + MVI_DUAL) 
			cf_alpha_internal(arg[0], 0.5f);
		else if (interpretation == MVI_C3GA + MVI_PLANE) 
			cf_alpha_internal(arg[0], 0.5f);
		else if (interpretation == MVI_C3GA + MVI_PLANE + MVI_DUAL) 
			cf_alpha_internal(arg[0], 0.5f);
		else    
			cf_alpha_internal(arg[0], 1.0f); // default: solid
	}

	if (!((drawFlags & OFF_STIPPLE))) {
		if ((interpretation & MVI_MODEL_MASK) == MVI_C3GA) {     
			cf_no_stipple(s, arg);
//			if ((interpretation & MVI_FREE_FLAT) == MVI_FREE_FLAT)
			if ((interpretation & MVI_BLADE_TYPE_MASK) == MVI_FREE_FLAT)
				cf_stipple(s, arg);
			else if (mvi && ((interpretation & MVI_BLADE_TYPE_MASK) == MVI_ROUND))
				if (mvi->m_scalar[0] < 0) 
					cf_stipple(s, arg);
		}
	}
	
	if (!((drawFlags & OFF_MAGNITUDE))) {
		if ((interpretation & MVI_MODEL_MASK) == MVI_C3GA) {
			if (((interpretation & MVI_BLADE_TYPE_MASK) == MVI_ROUND) ||
				((interpretation & MVI_BLADE_TYPE_MASK) == MVI_BOUND_FLAT) ||
				((interpretation & (MVI_BLADE_TYPE_MASK | 15)) == MVI_POINT) ||
				((interpretation & (MVI_BLADE_TYPE_MASK | 15)) == MVI_FREE_SCALAR)) {
				cf_no_weight(s, arg);
			}
		}
		else if ((interpretation & MVI_MODEL_MASK) == MVI_P3GA) {
			if ((interpretation & MVI_BLADE_TYPE_MASK) == MVI_BOUND_FLAT)
				cf_no_weight(s, arg);
		}
	}

	if (mvi) delete mvi;

	return arg[0];
}

consoleVariable *cf_console_ctrl_remove(consoleScope *s, consoleVariable *arg[]) {
	g_state->removeConsoleControl(arg[0]->name());

	return new consoleVariable("", e3ga(0.0));
}

consoleVariable *cf_console_ctrl_bool(consoleScope *s, consoleVariable *arg[]) {
	g_state->addConsoleControlBool(arg[0]->name(), arg[0]->isTrue());
	return new consoleVariable("", e3ga(0.0));
}

consoleVariable *cf_console_ctrl_bool_with_callback(consoleScope *s, consoleVariable *arg[]) {
	g_state->addConsoleControlBool(arg[0]->name(), arg[0]->isTrue(), arg[1]->name());
	return new consoleVariable("", e3ga(0.0));
}

consoleVariable *cf_console_ctrl_range_cb(consoleScope *s, consoleVariable *arg[], bool callback) {
	GAIM_FLOAT minValue = arg[1]->scalar();
	GAIM_FLOAT maxValue = arg[2]->scalar();

	double step = (maxValue - minValue) / 200;
	// 'round' step
	double rStep = 10e-40;
	while ((rStep*10) < fabs(step)) rStep *= 10;
	if (step < 0) rStep = -rStep;
	
	std::string callbackName = (callback) ? arg[3]->name() : "";
	
	g_state->addConsoleControlRange(arg[0]->name(), arg[0]->scalar(), minValue, maxValue, rStep, callbackName);

	return new consoleVariable("", e3ga(0.0));
}

consoleVariable *cf_console_ctrl_range(consoleScope *s, consoleVariable *arg[]) {
	return cf_console_ctrl_range_cb(s, arg, false);
}

consoleVariable *cf_console_ctrl_range_with_callback(consoleScope *s, consoleVariable *arg[]) {
	return cf_console_ctrl_range_cb(s, arg, true);
}


consoleVariable *cf_console_ctrl_range_step_cb(consoleScope *s, consoleVariable *arg[], bool callback) {
	GAIM_FLOAT minValue = arg[1]->scalar();
	GAIM_FLOAT maxValue = arg[2]->scalar();
	GAIM_FLOAT step = arg[3]->scalar();

	std::string callbackName = (callback) ? arg[4]->name() : "";

	g_state->addConsoleControlRange(arg[0]->name(), arg[0]->scalar(), minValue, maxValue, step, callbackName);

	return new consoleVariable("", e3ga(0.0));
}

consoleVariable *cf_console_ctrl_range_step(consoleScope *s, consoleVariable *arg[]) {
	return cf_console_ctrl_range_step_cb(s, arg, false);
}

consoleVariable *cf_console_ctrl_range_step_with_callback(consoleScope *s, consoleVariable *arg[]) {
	return cf_console_ctrl_range_step_cb(s, arg, true);
}

consoleVariable *cf_console_ctrl_selectionN_cb(consoleScope *s, consoleVariable *arg[], int nbSelection, bool callback) {
	std::vector<std::pair<std::string, GAIM_FLOAT> > options;
	int i;
	
	for (i = 1; i <= nbSelection; i++)
		options.push_back(std::make_pair(arg[i]->name(), arg[i]->scalar()));
	
	std::string callbackName = (callback) ? arg[nbSelection+1]->name() : "";

	g_state->addConsoleControlSelection(arg[0]->name(), arg[0]->scalar(), options, callbackName);

	return new consoleVariable("", e3ga(0.0));
}


consoleVariable *cf_console_ctrl_selection1(consoleScope *s, consoleVariable *arg[]) {
	return cf_console_ctrl_selectionN_cb(s, arg, 1, false);
}
consoleVariable *cf_console_ctrl_selection2(consoleScope *s, consoleVariable *arg[]) {
	return cf_console_ctrl_selectionN_cb(s, arg, 2, false);
}
consoleVariable *cf_console_ctrl_selection3(consoleScope *s, consoleVariable *arg[]) {
	return cf_console_ctrl_selectionN_cb(s, arg, 3, false);
}
consoleVariable *cf_console_ctrl_selection4(consoleScope *s, consoleVariable *arg[]) {
	return cf_console_ctrl_selectionN_cb(s, arg, 4, false);
}
consoleVariable *cf_console_ctrl_selection5(consoleScope *s, consoleVariable *arg[]) {
	return cf_console_ctrl_selectionN_cb(s, arg, 5, false);
}
consoleVariable *cf_console_ctrl_selection6(consoleScope *s, consoleVariable *arg[]) {
	return cf_console_ctrl_selectionN_cb(s, arg, 6, false);
}
consoleVariable *cf_console_ctrl_selection7(consoleScope *s, consoleVariable *arg[]) {
	return cf_console_ctrl_selectionN_cb(s, arg, 7, false);
}

consoleVariable *cf_console_ctrl_selection1_with_callback(consoleScope *s, consoleVariable *arg[]) {
	return cf_console_ctrl_selectionN_cb(s, arg, 1, true);
}
consoleVariable *cf_console_ctrl_selection2_with_callback(consoleScope *s, consoleVariable *arg[]) {
	return cf_console_ctrl_selectionN_cb(s, arg, 2, true);
}
consoleVariable *cf_console_ctrl_selection3_with_callback(consoleScope *s, consoleVariable *arg[]) {
	return cf_console_ctrl_selectionN_cb(s, arg, 3, true);
}
consoleVariable *cf_console_ctrl_selection4_with_callback(consoleScope *s, consoleVariable *arg[]) {
	return cf_console_ctrl_selectionN_cb(s, arg, 4, true);
}
consoleVariable *cf_console_ctrl_selection5_with_callback(consoleScope *s, consoleVariable *arg[]) {
	return cf_console_ctrl_selectionN_cb(s, arg, 5, true);
}
consoleVariable *cf_console_ctrl_selection6_with_callback(consoleScope *s, consoleVariable *arg[]) {
	return cf_console_ctrl_selectionN_cb(s, arg, 6, true);
}



consoleVariable *cf_help_general(consoleScope *s, consoleVariable *arg[]) {
	e3ga tmp(0.0);

	cprintf("\nHelp is available on the following topics:\n"
	"help(system)\n"
	"help(constants)\n"
	"help(operators)\n"
	"help(products)\n"
	"help(functions)\n"
	"help(boolean)\n"
	"help(projective)\n"
	"help(conformal)\n"
	"help(cast)\n"
	"help(display)\n"
	"help(controls)\n"
	"help(all) -- lists all help\n"
	);

	cprintf("\n\n");

	return new consoleVariable("", tmp);
}


consoleVariable *cf_help(consoleScope *s, consoleVariable *arg[]) {
	e3ga tmp(0.0);
	int all = arg[0]->name() == "all";

	if (all || (arg[0]->name() == "system")) {
		cprintf("\nSystem commands:\n"
		"cprint(arg1): prints the string 'arg1' to the console(NO printf like formatting!)\n"
		"cmd(arg1): executes the command 'arg1' as if it had been read from a .geo file\n"
		"prompt(): sets the default console prompt\n"
		"prompt(arg1): sets the console prompt to arg1\n"
		"mute_warnings(): disables the printing of warnings to the console\n"
		"unmute_warnings(): enables the printing of warnings to the console\n"
		"diary(): saves command and output history to file\n"
		"select(arg1): selects arg1 (arg1 in global scope)\n"
		"remove(arg1): removes arg1 (arg1 in global scope)\n"
		"dynamic{arg1}: adds 'arg1' to the list of dynamic statements\n"
		"cld(): clears list of dynamic statements\n"
		"cld(name): removes the dynamic statement named 'name'\n"
		"start_animation(): starts the animation of dynamics depending on 'atime'\n"
		"stop_animation(): stops animation\n"
		"pause_animation(): pauses animation\n"
		"resume_animation(): resumes animation (synonym of start_animation())\n"
		"reset(): resets the entire viewer (console, dynamics, variables, etc)\n"
		"add_const(arg1): adds a constant. E.g.: add_const(I3 = e1 ^ e2 ^ e3);\n"
		"remove_const(arg1): removes a constant. E.g.: remove_const(I3);\n"
		"rename_builtin_const(arg1, arg2): renames builtin constant 'arg1' to 'arg2'.\n"
		"default_model([e3ga|p3ga|c3ga|c5ga|i2ga]): sets default model of scalars, e1, e2, e3 to the argument\n"
		"default_model(): sets model to the default\n"
		"inner_product(functionName): sets the function used to evaluate the inner product to 'functionName' (hip, mhip, lcont and rcont and the recommended functions)\n"
		"get_interpretation(arg1): returns an integer that gives information about how 'arg1' is interpreted (useful to make your own autocolor)\n"
		"get_draw_flags(arg1): returns an integer that gives information about how what drawing properties of 'arg1' have been explicitly set (useful to make your own autocolor)\n"
		"label(arg1): draws a label at the position of arg1, the text of the label will be 'arg1'\n"
		"label(arg1, arg2): draws a label at the position of arg1, then text will be 'arg2'\n"
		"add_net_port(arg1): opens a new TCP network server on port 'arg1'\n"
		"remove_net_port(arg1): remove the TCP network server listening on port 'arg1'\n"
		"net_status(): gives a summary of network ports and connections\n"
		"net_close(): immediatelly shuts down all network ports and connections\n"
		"screenshot(filename, width, height, alsoWithoutLabels): renders screenshot\n"
		"set_window_title(title): sets the main window title to 'title'\n"
		"disable_mouse_interaction(): disables editing multivectors using the ctrl-right-mouse.\n"
		"enable_mouse_interaction(): enables editing multivectors using the ctrl-right-mouse.\n"
		);
	}

	if (all || (arg[0]->name() == "constants")) {
		cprintf("\nAvailable constants:\n-All scalar numbers\n"
		"-e1, e2, e3: Euclidean basisvector\n"
		"-e0: Projective origin basisvector\n"
		"-ni, no: Conformal infinity and origin\n"
		"-gi, go: Grayscale infinity and origin\n"
		"-einf: Synonym for conformal infinity\n"
		"-pi: 3.1415926535897932384626433832795\n"
		"-e_: 2.7182818284590452353602874713527\n"
		);
	}
	
	if (all || (arg[0]->name() == "operators")) {
		cprintf("\nAvailable unary operators:\n~ : reversion\n"
		"-  negation\n"
		"!  inversion\n"
		"Example of unary operator use: a = -e1\n");

		cprintf("\nAvailable binary operators (in order of precedence):\n"
		"^  outer product (precedence level 9)\n"
		"|  join (precedence level 8)\n"
		"&  meet (precedence level 8)\n"
		".  inner product (precedence level 7)\n"
		"'space' geometric product (precedence level 6)\n"
		"*  synonym for geometric product (precedence level 6)\n"
		"/  inverse geometric product (precedence level 6)\n"
		"+  addition (precedence level 5)\n"
		"-  subtraction (precedence level 5)\n"
		"< less (precedence level 4)\n"
		"> greater (precedence level 4)\n"
		"<= less or equal (precedence level 4)\n"
		">= greater or equal (precedence level 4)\n"
		"== equal (precedence level 3)\n"
		"!= not equal (precedence level 3)\n"
		"&& and (precedence level 2)\n"
		"|| or (precedence level 1)\n"
		"=  assignment (precedence level 0, right associative)\n"
		"All operators are left associative, except assignment (which isn't really an operator)\n"
		"Example of binary operator use: a = (e1 ^ e2) . c\n");
	}

	if (all || (arg[0]->name() == "products")) {
		cprintf("\nAvailable products:\n"
		"gp(arg1, arg2): returns the geometric product of arg1 and arg2\n"
		"igp(arg1, arg2): returns the inverse geometric product of arg1 and arg2\n"
		"op(arg1, arg2): returns the outer product of arg1 and arg2\n"
		"hip(arg1, arg2): returns the Hestenes inner product of arg1 and arg2\n"
		"mhip(arg1, arg2): returns the modifiedHestenes inner product of arg1 and arg2\n"
		"lcont(arg1, arg2): returns the left contraction of arg1 and arg2\n"
		"rcont(arg1, arg2): returns the right contraction of arg1 and arg2\n"
		"scp(arg1, arg2): returns the scalar product of arg1 and arg2\n"
		"gpem(arg1, arg2): returns the Euclidean Metric geometric product of arg1 and arg2\n"
		"lcem(arg1, arg2): returns the Euclidean Metric left contraction of arg1 and arg2\n"
		"meet(arg1, arg2): returns the meet of arg1 and arg2\n"
		"join(arg1, arg2): returns the join of arg1 and arg2\n"
		"cp(arg1, arg2): returns the commutator product of arg1 and arg2\n");
	}

	if (all || (arg[0]->name() == "functions")) {
		cprintf("\nAvailable functions:\n"
		"print(arg1): prints coordinates of arg1 to the console, returns 0\n"
		"print(arg1, arg2): prints coordinates of arg1 to the console with precision arg2 (e.g., arg2 = \"e\"), returns 0\n"
		"assign(arg1, arg2): assigns the value of arg2 to arg1, returns arg2\n"
		"add(arg1, arg2): returns arg1 + arg2\n"
		"sub(arg1, arg2): returns arg1 - arg2\n"
		"scalar(arg1): returns the scalar part of arg1\n"
		"dual(arg1): returns the dual of arg1 with respect to the full space\n"
		"dual(arg1, arg2): returns the dual of arg1 with respect to arg2\n"
		"reverse(arg1): returns the reverse of arg1\n"
		"clifford_conjugate(arg1): returns the clifford conjugate of arg1\n"
		"grade_involution(arg1): returns the grade involution of arg1\n"
		"inverse(arg1): returns the (versor) inverse of arg1\n"
		"general_inverse(arg1): returns the inverse of arg1 even if it is not a versor (returns 0 if inverse does not exist)\n"
		"negate(arg1): returns the negation of arg1\n");


		cprintf("\n"
		"grade(arg1, arg2): returns the grade 'arg2' part of arg1, e.g. grade(a, 2)\n"
		"grade(arg1): if arg1 is a blade, returns the grade of arg1, otherwise returns -1\n"
		"versor_parity(arg1): if arg1 is an even versor returns: 0, odd versor: 1; not a versor : -1.\n"
		"norm_2(arg1): returns the sum of the square of all coordinates of arg1\n"
		"norm_r(arg1): returns scp(arg1, reverse(arg1))\n"
		"norm(arg1): returns sqrt(abs(norm_r(arg1))) * sign(norm_r(arg1))\n"
		"normalize(arg1): returns arg1 / abs(norm_r(arg1))\n"
		);

		cprintf("\n"
		"sqrt(arg1): returns sqrt(scalar(arg1))\n"
		"abs(arg1): returns abs(scalar(arg1))\n"
		"max(arg1, arg2): returns max(scalar(arg1), scalar(arg2))\n"
		"min(arg1, arg2): returns min(scalar(arg1), scalar(arg2))\n"
		"tan(arg1): returns tan(scalar(arg1)) -- [radians]\n"
		"sin(arg1): returns sin(scalar(arg1)) -- [radians]\n"
		"cos(arg1): returns cos(scalar(arg1)) -- [radians]\n"
		"atan(arg1): returns atan(scalar(arg1)) -- [radians]\n"
		"asin(arg1): returns asin(scalar(arg1)) -- [radians]\n"
		"acos(arg1): returns acos(scalar(arg1)) -- [radians]\n"
		"atan2(arg1): returns atan2(scalar(arg1), scalar(arg2)) -- [radians]\n"	
		"sinh(arg1): returns sinh(scalar(arg1)) -- [radians]\n"
		"cosh(arg1): returns cosh(scalar(arg1)) -- [radians]\n"
		"asinh(arg1): returns asinh(scalar(arg1)) -- [radians]\n"
		"acosh(arg1): returns acosh(scalar(arg1)) -- [radians]\n"
		"sinc(arg1): returns sin(scalar(arg1)) / scalar(arg1) -- [radians]\n"
		"log(arg1): returns natural logarithm of scalar(arg1) (also of negative numbers)\n"
		"exp(arg1): returns exp(arg1) (inaccurate series expansion)\n"
		"pow(arg1, arg2): returns arg1 multiplied arg2 times with itself (arg2: integer >= 0))\n"
		"scalar_pow(arg1, arg2): arg1 raised to the power of arg2\n"
		);
		
		cprintf("\n"
		"rand(): returns random number (uniform distribution between 0.0 and 1.0)\n"
		"randSeed(arg1): sets the random seed to arg1\n"
		"time(): returns current time, millisecond resolution. May be used for randSeed()\n"
		"randGauss(arg1, arg2): returns random number (gaussion distribution with specified mean; arg1 = mean, arg2 = variance)\n"
		"randGaussStd(): returns random number (gaussion distribution with mean = 0.0; variance = 1.0)\n"
		);

		cprintf("\n"
		"versor_product(arg1, arg2): returns (arg1 arg2 inverse(arg1))\n"
		"vp(arg1, arg2): synonym of versor_product(arg1, arg2)\n"
		"inverse_versor_product(arg1, arg2): returns (inverse(arg1) arg2 arg1)\n"
		"ivp(arg1, arg2): synonym of inverse_versor_product(arg1, arg2)\n"
		"project(arg1, arg2): returns the projection of arg1 onto arg2\n"
		"reject(arg1, arg2): returns the rejection of arg1 from arg2\n"
		"factor(arg1, arg2): returns factor 'arg2' of arg1 (arg2 = integer from 1 to the grade of arg1)\n"
		);
		
		cprintf("\n"
		"create_polygon(poly_name, [fill|loop|strip], vertex1, vertex2, ..., vertexN): creates a new polygon (max. 6 vertices)\n"
		
		);
		cprintf("\n"
		"create_arc(arc_name, versor, point, nbSegments): creates a new arc of 'nbSegments' segments by applying 'versor' to 'point' repeatedly\n"
		);
	}

	if (all || (arg[0]->name() == "boolean")) {
		cprintf("\nBoolean functions (false = 0.0, true = any other value):\n"
		"equal(arg1, arg2): returns true if (arg1 - arg2) equals 0\n"
		"ne(arg1, arg2): returns true if (arg1 - arg2) does not equal 0\n"
		"less(arg1, arg2): returns true if scalar(arg1) < scalar(arg2)\n"
		"greater(arg1, arg2): returns true if scalar(arg1) > scalar(arg2)\n"
		"le(arg1, arg2): (less or equal) returns true if scalar(arg1) <= scalar(arg2)\n"
		"ge(arg1, arg2): (greater or equal) returns true if scalar(arg1) >= scalar(arg2)\n"
		"and(arg1, arg2): returns true if arg1 is true and arg2 is true\n"
		"or(arg1, arg2): returns true if arg1 is true or arg2 is true\n"
		"not(arg1): returns false if arg1 is true, and true if arg1 is false\n"
		"\n"
		"Bitwise functions (performed on 32 bit unsigned integers):\n"
		"bit_not(arg1): returns the bitwise 'not' of int(scalar(arg1))\n"
		"bit_and(arg1, arg2): returns the bitwise 'and' of int(scalar(arg1)) and int(scalar(arg2))\n"
		"bit_or(arg1, arg2): returns the bitwise 'or' of int(scalar(arg1)) and int(scalar(arg2))\n"
		"bit_xor(arg1, arg2): returns the bitwise 'xor' of int(scalar(arg1)) and int(scalar(arg2))\n"
		"bit_shift(arg1, arg2): returns bitwise shift left of int(scalar(arg1)) by int(scalar(arg2)) (can be negative for right shift)\n"
		);
	}


	if (all || (arg[0]->name() == "projective")) {
		cprintf("\nSpecial functions for the projective model\n"
		"p3ga_point(arg1, arg2, arg3): returns the projective point constructed from the vector [arg1 e1 + arg2 e2 + arg3 e3]\n"	
		"p3ga_point(arg1): returns the projective point constructed from the vector arg1\n"	
		);
	}


	if (all || (arg[0]->name() == "conformal")) {
		cprintf("\nSpecial functions for the conformal model\n"
		"c3ga_point(arg1, arg2, arg3): returns the conformal point constructed from the vector [arg1 e1 + arg2 e2 + arg3 e3]\n"	
		"c3ga_point(arg1): returns the conformal point constructed from the vector arg1\n"	
		"c3ga_point(arg1): returns the conformal point constructed from the projective point arg1\n"
		"translation_versor(arg1): returns a conformal versor that translates over vector arg1\n"
		"tv(arg1): synonym of translation_versor(arg1)\n"
		"translation_versor(arg1, arg2, arg3): returns a conformal versor that translates over vector [arg1 e1 + arg2 e2 + arg3 e3]\n"
		"tv(arg1, arg2, arg3): synonym of translation_versor(arg1, arg2, arg3)\n"
		);
	}

	if (all || (arg[0]->name() == "cast")) {
		cprintf("\nCasting functions between models:\n"
		"C-like casting:\n"
		"(e3ga)arg1: casts arg1 to euclidean model\n"	
		"(p3ga)arg1: casts arg1 to projective model\n"	
		"(c3ga)arg1: casts arg1 to conformal model of 3-D Euclidean space\n"	
		"(c5ga)arg1: casts arg1 to conformal model of 5-D Euclidean space\n"	
		"(i2ga)arg1: casts arg1 to image algebra \n"	
/*		"\nFunction-like casting:\n"
		"cast_e3ga(arg1): casts arg1 to euclidean model\n"	
		"cast_p3ga(arg1): casts arg1 to projective model\n"	
		"cast_c3ga(arg1): casts arg1 to conformal model\n"	*/
		);
	}

	if (all || (arg[0]->name() == "display")) {
		cprintf("\nSpecial functions for controlling display & drawing:\n"
		"clf(): clears the display (removes all variables/objects)\n"
		"clc(): clears the console\n");

/*		cprintf("\n"
		"set_object_color(arg1, colorName): sets color of 'arg1' to colorName (red, green, blue, white, magenta, yellow, cyan, black, gray, grey)\n"
		"set_object_color(arg1, R, G, B): sets color of 'arg1' to RGB\n"
		"set_object_color(arg1, R, G, B, A): sets color of 'arg1' to RGBA\n");*/
		
		cprintf("\n"
		"red(arg1), green(arg1), blue(arg1), ...\n"
		"white(arg1), magenta(arg1), yellow(arg1), ...\n"
		"cyan(arg1), black(arg1), grey(arg1), ...\n"
		"gray(arg1): (DEPRECATED) sets the color of arg1\n");

		cprintf("\n"
		"color(arg1, arg2, arg3, arg4): sets the color of arg1 to rgb value (arg2, arg3, arg4)\n"
		"color(arg1, arg2, arg3, arg4, arg5): sets the color of arg1 to rgba value (arg2, arg3, arg4, arg5)\n"
		"alpha(arg1, arg2): sets the alpha (opacity) of arg1 to arg2\n");

		cprintf("\n"
		"dm1(arg1), dm2(arg1), dm3(arg1), dm4(arg1), ...\n"
		"dm5(arg1), dm6(arg1), dm7(arg1): sets the 'draw method' of arg1\n");

		cprintf("\n"
		"stipple(arg1): draws arg1 stippled\n"
		"no_stipple(arg1): draws arg1 not stippled\n"
		"wireframe(arg1): draws arg1 in wireframe\n"
		"no_wireframe(arg1): draws arg1 without wireframe\n"
		"outline(arg1): outlines arg1\n"
		"no_outline(arg1): does not outline arg1\n"
		"weight(arg1): draws the weight of arg1\n"
		"no_weight(arg1): does not draw the weight of arg1\n"
		"ori(arg1): draws the orientation of arg1\n"
		"no_ori(arg1): does not draw the orientation of arg1\n"
		"mute(arg1): disables printing of arg1 to console\n"
		"unmute(arg1): enables printing of arg1 to console\n"
		"hide(arg1): hides arg1\n"
		"show(arg1): shows arg1\n");

		cprintf("\n"
		"get_color(arg1): returns a vector with rgb color of arg1\n"
		"get_alpha(arg1): returns a scalar with alpha of arg1\n"
		"get_stipple(arg1): returns a boolean scalar with flag stipple of arg1\n"
		"get_wireframe(arg1): returns a boolean scalar with flag wireframe of arg1\n"
		"get_outline(arg1): returns a boolean scalar with flag outline of arg1\n"
		"get_weight(arg1): returns a boolean scalar with flag weight of arg1\n"
		"get_ori(arg1): returns a boolean scalar with flag ori of arg1\n"
		"get_hide(arg1): returns a boolean scalar with flag hide of arg1\n");

		cprintf("\n"
		"versor(arg1): forces versor interpretation of arg1\n"
		"blade(arg1): forces blade interpretation of arg1\n");
		
		cprintf("\n"
		"set_point_size(arg): sets the (drawing) size of points to 'arg' (default = 0.1)\n"
		"set_text_scale(arg): sets the scaling of text and labels to 'arg' (default = 1.0)\n"
		"set_line_width(arg): sets the width of most lines to 'arg' (default = 2.0)\n"
		"set_gl_lines(arg): sets the use of regular OpenGL lines (arg != 0), or 'tubes' (arg == 0).\n"
		"set_vector_head_size(arg): sets the size of vector 'heads' to 'arg' (default = -1.0 = auto size)\n"
		"set_point_sub_div(arg): sets the amount of subdivision of the geosphere used for rendering points (default = 2)\n"
		"set_sphere_sub_div(arg): sets the amount of subdivision of the geosphere used for rendering spheres (default = 3)\n"
		"set_near_far_clip_planes(near, far): sets the closest and furthest distance at which objects get drawn. Passing invalid (e.g. negative) values causes a reset to the default (default near=0.95, far=100.0).\n"
		);
	}

	if (all || (arg[0]->name() == "controls")) {
		cprintf("\nFunctions for creating and removing console controls:\n"
		"ctrl_bool(name = value): creates a boolean control with 'name', set to value\n"
		"ctrl_range(name = value, min_value, max_value): creates a slider control with 'name', set to value, limited to min and max values\n"
		"ctrl_range(name = value, min_value, max_value, step): creates a slider control with 'name', set to value, limited to min and max values, with 'step'\n"
		"ctrl_select(name = value, option1 = value1, ..., optionN = valueN): creates a selection menu with 'name', set to value. A maximum op 7 options can be specified, 'value' must be one of the options\n"
		"ctrl_bool_with_callback(name = value, \"callbackName\"): like ctrl_bool(), but calls 'callbackName()' when value changes.\n"
		"ctrl_range_with_callback(name = value, min_value, max_value, \"callbackName\"): like ctrl_range(), but calls 'callbackName()' when value changes.\n"
		"ctrl_range_with_callback(name = value, min_value, max_value, step, \"callbackName\"): like ctrl_range(), but calls 'callbackName()' when value changes.\n"
		"ctrl_select_with_callback(name = value, option1 = value1, ..., optionN = valueN, \"callbackName\"): like ctrl_select(), but calls 'callbackName()' when value changes.\n"
		"ctrl_remove(name): removes any control with name 'name'\n");
	}


	cprintf("\n\n");

	return new consoleVariable("", tmp);
}	


const consoleFunc c_consoleFunc[] =  {
	{"add_net_port", NULL, cf_add_net_port, 1, {CVF_LHS | CVF_RHS | CVF_ANY_MODEL}},
	{"remove_net_port", NULL, cf_remove_net_port, 1, {CVF_LHS | CVF_RHS | CVF_ANY_MODEL}},
	{"net_status", NULL, cf_net_status, 0, {0}},	
	{"net_close", NULL, cf_net_close, 0, {0}},	
	{"disable_mouse_interaction", NULL, cf_disable_mouse_interaction, 0, {0}},	
	{"enable_mouse_interaction", NULL, cf_enable_mouse_interaction, 0, {0}},	
	{"screenshot", NULL, cf_screenshot, 4, {CVF_RHS | CVF_ANY_MODEL, CVF_LHS | CVF_RHS | CVF_ANY_MODEL, CVF_LHS | CVF_RHS | CVF_ANY_MODEL, CVF_LHS | CVF_RHS | CVF_ANY_MODEL}},
	{"set_window_title", NULL, cf_set_window_title, 1, {CVF_RHS | CVF_ANY_MODEL}},
	{"set_point_size", NULL, cf_set_point_size, 1, {CVF_LHS | CVF_RHS | CVF_ANY_MODEL}},	
	{"set_near_far_clip_planes", NULL, cf_set_near_far_clip_planes, 2, {CVF_LHS | CVF_RHS | CVF_ANY_MODEL, CVF_LHS | CVF_RHS | CVF_ANY_MODEL}},	
	{"set_text_scale", NULL, cf_set_text_scale, 1, {CVF_LHS | CVF_RHS | CVF_ANY_MODEL}},	
	{"set_line_width", NULL, cf_set_line_width, 1, {CVF_LHS | CVF_RHS | CVF_ANY_MODEL}},	
	{"set_vector_head_size", NULL, cf_set_vector_head_size, 1, {CVF_LHS | CVF_RHS | CVF_ANY_MODEL}},	
	{"set_gl_lines", NULL, cf_set_gl_lines, 1, {CVF_LHS | CVF_RHS | CVF_ANY_MODEL}},	
	{"set_point_sub_div", NULL, cf_set_point_sub_div, 1, {CVF_LHS | CVF_RHS | CVF_ANY_MODEL}},	
	{"set_sphere_sub_div", NULL, cf_set_sphere_sub_div, 1, {CVF_LHS | CVF_RHS | CVF_ANY_MODEL}},	
	{"cmd", NULL, cf_cmd, 1, {CVF_LHS | CVF_RHS | CVF_ANY_MODEL}},
	{"prompt", NULL, cf_prompt, 1, {CVF_LHS | CVF_RHS | CVF_ANY_MODEL}},
	{"prompt", NULL, cf_prompt_default, 0, {0}},
	{"mute_warnings", NULL, cf_mute_warnings, 0, {0}},
	{"unmute_warnings", NULL, cf_unmute_warnings, 0, {0}},
	{"diary", NULL, cf_diary, 0, {0}},
	{"diary", NULL, cf_diary_filename, 1, {CVF_LHS | CVF_RHS | CVF_ANY_MODEL}},
	{"cprint", NULL, cf_cprint, 1, {CVF_LHS | CVF_RHS | CVF_ANY_MODEL}},
	{"select", NULL, cf_select, 1, {CVF_LHS | CVF_RHS | CVF_ANY_MODEL}},
	{"remove", NULL, cf_remove, 1, {CVF_LHS | CVF_RHS | CVF_ANY_MODEL}},
	{"get_draw_flags", NULL, cf_get_draw_flags, 1, {CVF_RHS | CVF_ANY_MODEL}},
	{"get_interpretation", NULL, cf_get_interpretation, 1, {CVF_RHS | CVF_ANY_MODEL}},
	{"autocolorfunc", NULL, cf_autocolorfunc, 1, {CVF_RHS | CVF_ANY_MODEL}},
	{"camrot", NULL, cf_camrotfunc, 2, {CVF_RHS | MVI_E3GA, CVF_RHS | CVF_ANY_MODEL}},
	{"add_const", NULL, cf_add_const, 1, {CVF_RHS | CVF_ANY_MODEL}},
	{"remove_const", NULL, cf_remove_const, 1, {CVF_RHS | CVF_LHS | CVF_ANY_MODEL}},
	{"rename_builtin_const", NULL, cf_rename_builtin_const, 2, {CVF_RHS | CVF_LHS | CVF_ANY_MODEL, CVF_RHS | CVF_LHS | CVF_ANY_MODEL}},
	{"label", NULL, cf_label, 1, {CVF_RHS | CVF_ANY_MODEL}},
	{"label", NULL, cf_label2, 2, {CVF_RHS | CVF_ANY_MODEL, CVF_RHS | CVF_ANY_MODEL}},


	{"ctrl_bool", NULL, cf_console_ctrl_bool, 1, {CVF_RHS | CVF_ANY_MODEL}},
	{"ctrl_range", NULL, cf_console_ctrl_range, 3, {CVF_RHS | CVF_ANY_MODEL, CVF_LHS | CVF_RHS | CVF_ANY_MODEL, CVF_LHS | CVF_RHS | CVF_ANY_MODEL}},
	{"ctrl_range", NULL, cf_console_ctrl_range_step, 4, {CVF_RHS | CVF_ANY_MODEL, CVF_LHS | CVF_RHS | CVF_ANY_MODEL, CVF_LHS | CVF_RHS | CVF_ANY_MODEL, CVF_LHS | CVF_RHS | CVF_ANY_MODEL}},
	{"ctrl_select", NULL, cf_console_ctrl_selection1, 2, {CVF_RHS | CVF_ANY_MODEL, CVF_RHS | CVF_ANY_MODEL}},
	{"ctrl_select", NULL, cf_console_ctrl_selection2, 3, {CVF_RHS | CVF_ANY_MODEL, CVF_RHS | CVF_ANY_MODEL, CVF_RHS | CVF_ANY_MODEL}},
	{"ctrl_select", NULL, cf_console_ctrl_selection3, 4, {CVF_RHS | CVF_ANY_MODEL, CVF_RHS | CVF_ANY_MODEL, CVF_RHS | CVF_ANY_MODEL, CVF_RHS | CVF_ANY_MODEL}},
	{"ctrl_select", NULL, cf_console_ctrl_selection4, 5, {CVF_RHS | CVF_ANY_MODEL, CVF_RHS | CVF_ANY_MODEL, CVF_RHS | CVF_ANY_MODEL, CVF_RHS | CVF_ANY_MODEL, CVF_RHS | CVF_ANY_MODEL}},
	{"ctrl_select", NULL, cf_console_ctrl_selection5, 6, {CVF_RHS | CVF_ANY_MODEL, CVF_RHS | CVF_ANY_MODEL, CVF_RHS | CVF_ANY_MODEL, CVF_RHS | CVF_ANY_MODEL, CVF_RHS | CVF_ANY_MODEL, CVF_RHS | CVF_ANY_MODEL}},
	{"ctrl_select", NULL, cf_console_ctrl_selection6, 7, {CVF_RHS | CVF_ANY_MODEL, CVF_RHS | CVF_ANY_MODEL, CVF_RHS | CVF_ANY_MODEL, CVF_RHS | CVF_ANY_MODEL, CVF_RHS | CVF_ANY_MODEL, CVF_RHS | CVF_ANY_MODEL, CVF_RHS | CVF_ANY_MODEL}},
	{"ctrl_select", NULL, cf_console_ctrl_selection7, 8, {CVF_RHS | CVF_ANY_MODEL, CVF_RHS | CVF_ANY_MODEL, CVF_RHS | CVF_ANY_MODEL, CVF_RHS | CVF_ANY_MODEL, CVF_RHS | CVF_ANY_MODEL, CVF_RHS | CVF_ANY_MODEL, CVF_RHS | CVF_ANY_MODEL, CVF_RHS | CVF_ANY_MODEL}},
	
	{"ctrl_bool_with_callback", NULL, cf_console_ctrl_bool_with_callback, 2, {CVF_RHS | CVF_ANY_MODEL, CVF_RHS | CVF_ANY_MODEL}},
	{"ctrl_range_with_callback", NULL, cf_console_ctrl_range_with_callback, 4, {CVF_RHS | CVF_ANY_MODEL, CVF_LHS | CVF_RHS | CVF_ANY_MODEL, CVF_LHS | CVF_RHS | CVF_ANY_MODEL, CVF_RHS | CVF_ANY_MODEL}},
	{"ctrl_range_with_callback", NULL, cf_console_ctrl_range_step_with_callback, 5, {CVF_RHS | CVF_ANY_MODEL, CVF_LHS | CVF_RHS | CVF_ANY_MODEL, CVF_LHS | CVF_RHS | CVF_ANY_MODEL, CVF_LHS | CVF_RHS | CVF_ANY_MODEL, CVF_RHS | CVF_ANY_MODEL}},
	{"ctrl_select_with_callback", NULL, cf_console_ctrl_selection1_with_callback, 3, {CVF_RHS | CVF_ANY_MODEL, CVF_RHS | CVF_ANY_MODEL, CVF_RHS | CVF_ANY_MODEL}},
	{"ctrl_select_with_callback", NULL, cf_console_ctrl_selection2_with_callback, 4, {CVF_RHS | CVF_ANY_MODEL, CVF_RHS | CVF_ANY_MODEL, CVF_RHS | CVF_ANY_MODEL, CVF_RHS | CVF_ANY_MODEL}},
	{"ctrl_select_with_callback", NULL, cf_console_ctrl_selection3_with_callback, 5, {CVF_RHS | CVF_ANY_MODEL, CVF_RHS | CVF_ANY_MODEL, CVF_RHS | CVF_ANY_MODEL, CVF_RHS | CVF_ANY_MODEL, CVF_RHS | CVF_ANY_MODEL}},
	{"ctrl_select_with_callback", NULL, cf_console_ctrl_selection4_with_callback, 6, {CVF_RHS | CVF_ANY_MODEL, CVF_RHS | CVF_ANY_MODEL, CVF_RHS | CVF_ANY_MODEL, CVF_RHS | CVF_ANY_MODEL, CVF_RHS | CVF_ANY_MODEL, CVF_RHS | CVF_ANY_MODEL}},
	{"ctrl_select_with_callback", NULL, cf_console_ctrl_selection5_with_callback, 7, {CVF_RHS | CVF_ANY_MODEL, CVF_RHS | CVF_ANY_MODEL, CVF_RHS | CVF_ANY_MODEL, CVF_RHS | CVF_ANY_MODEL, CVF_RHS | CVF_ANY_MODEL, CVF_RHS | CVF_ANY_MODEL, CVF_RHS | CVF_ANY_MODEL}},
	{"ctrl_select_with_callback", NULL, cf_console_ctrl_selection6_with_callback, 8, {CVF_RHS | CVF_ANY_MODEL, CVF_RHS | CVF_ANY_MODEL, CVF_RHS | CVF_ANY_MODEL, CVF_RHS | CVF_ANY_MODEL, CVF_RHS | CVF_ANY_MODEL, CVF_RHS | CVF_ANY_MODEL, CVF_RHS | CVF_ANY_MODEL, CVF_RHS | CVF_ANY_MODEL}},
	
	{"ctrl_remove", NULL, cf_console_ctrl_remove, 1, {CVF_RHS | CVF_ANY_MODEL}},

	{"cld", NULL, cf_cld, 0, {0}},
	{"cld", NULL, cf_cld_1, 1, {CVF_RHS | CVF_ANY_MODEL}},

	{"rand", NULL, cf_rand, 0, {0}},
	{"time", NULL, cf_time, 0, {0}},
	{"randGaussStd", NULL, cf_randGaussStd, 0, {}},
	
	{"start_animation", NULL, cf_start_animation, 0, {0}},
	{"stop_animation", NULL, cf_stop_animation, 0, {0}},
	{"pause_animation", NULL, cf_pause_animation, 0, {0}},
	{"resume_animation", NULL, cf_start_animation, 0, {0}},

	{"reset", NULL, cf_reset, 0, {0}},
	{"help", NULL, cf_help_general, 0, {0}},
	{"help", NULL, cf_help, 1, {CVF_LHS | CVF_RHS | CVF_ANY_MODEL}},

	{"p3ga_point", NULL, cf_p3ga_point3, 3, {CVF_RHS | MVI_E3GA, CVF_RHS | MVI_E3GA, CVF_RHS | MVI_E3GA}},
	{"p3ga_point", NULL, cf_p3ga_point1, 1, {CVF_RHS | MVI_E3GA}},

	{"c3ga_point", NULL, cf_c3ga_point3, 3, {CVF_RHS | MVI_E3GA, CVF_RHS | MVI_E3GA, CVF_RHS | MVI_E3GA}},
	{"c3ga_point", NULL, cf_c3ga_point1, 1, {CVF_RHS | MVI_E3GA}},
	{"c3ga_point", NULL, cf_c3ga_pointP1, 1, {CVF_RHS | MVI_P3GA}},

	{"translation_versor", NULL, cf_translation_versor3, 3, {CVF_RHS | MVI_E3GA, CVF_RHS | MVI_E3GA, CVF_RHS | MVI_E3GA}},
	{"tv", NULL, cf_translation_versor3, 3, {CVF_RHS | MVI_E3GA, CVF_RHS | MVI_E3GA, CVF_RHS | MVI_E3GA}},
	{"translation_versor", NULL, cf_translation_versor1, 1, {CVF_RHS | MVI_E3GA}},
	{"tv", NULL, cf_translation_versor1, 1, {CVF_RHS | MVI_E3GA}},

	{"clf", NULL, cf_clf, 0, {0}},
	{"clc", NULL, cf_clc, 0, {0}},
	{"set_object_fg_color", NULL, cf_set_object_fg_color_vector,  2, {CVF_RHS | CVF_ANY_MODEL, CVF_RHS | MVI_E3GA}},
	{"set_object_fg_color", NULL, cf_set_object_fg_color_RGB, 4, {CVF_RHS | CVF_ANY_MODEL, CVF_RHS | MVI_E3GA, CVF_RHS | MVI_E3GA, CVF_RHS | MVI_E3GA}},
	{"set_object_fg_color", NULL, cf_set_object_fg_color_RGBA, 5, {CVF_RHS | CVF_ANY_MODEL, CVF_RHS | MVI_E3GA, CVF_RHS | MVI_E3GA, CVF_RHS | MVI_E3GA, CVF_RHS | MVI_E3GA}},
	
	{"red", NULL, cf_red, 1, {CVF_RHS | CVF_ANY_MODEL}},
	{"green", NULL, cf_green, 1, {CVF_RHS | CVF_ANY_MODEL}},
	{"blue", NULL, cf_blue, 1, {CVF_RHS | CVF_ANY_MODEL}},
	{"white", NULL, cf_white, 1, {CVF_RHS | CVF_ANY_MODEL}},
	{"magenta", NULL, cf_magenta, 1, {CVF_RHS | CVF_ANY_MODEL}},
	{"yellow", NULL, cf_yellow, 1, {CVF_RHS | CVF_ANY_MODEL}},
	{"cyan", NULL, cf_cyan, 1, {CVF_RHS | CVF_ANY_MODEL}},
	{"black", NULL, cf_black, 1, {CVF_RHS | CVF_ANY_MODEL}},
	{"grey", NULL, cf_grey, 1, {CVF_RHS | CVF_ANY_MODEL}},
	{"gray", NULL, cf_grey, 1, {CVF_RHS | CVF_ANY_MODEL}},

	{"color", NULL, cf_color1, 2, {CVF_RHS | CVF_ANY_MODEL, CVF_RHS | MVI_E3GA}},
	{"color", NULL, cf_color3, 4, {CVF_RHS | CVF_ANY_MODEL, CVF_RHS | MVI_E3GA, CVF_RHS | MVI_E3GA, CVF_RHS | MVI_E3GA}},
	{"color", NULL, cf_color4, 5, {CVF_RHS | CVF_ANY_MODEL, CVF_RHS | MVI_E3GA, CVF_RHS | MVI_E3GA, CVF_RHS | MVI_E3GA, CVF_RHS | MVI_E3GA}},
	{"alpha", NULL, cf_alpha, 2, {CVF_RHS | CVF_ANY_MODEL, CVF_RHS | MVI_E3GA}},

	{"versor", NULL, cf_versor, 1, {CVF_RHS | CVF_ANY_MODEL}},
	{"blade", NULL, cf_blade, 1, {CVF_RHS | CVF_ANY_MODEL}},

 	{"dm1", NULL, cf_dm1, 1, {CVF_RHS | CVF_ANY_MODEL}},
	{"dm2", NULL, cf_dm2, 1, {CVF_RHS | CVF_ANY_MODEL}},
 	{"dm3", NULL, cf_dm3, 1, {CVF_RHS | CVF_ANY_MODEL}},
	{"dm4", NULL, cf_dm4, 1, {CVF_RHS | CVF_ANY_MODEL}},
 	{"dm5", NULL, cf_dm5, 1, {CVF_RHS | CVF_ANY_MODEL}},
	{"dm6", NULL, cf_dm6, 1, {CVF_RHS | CVF_ANY_MODEL}},
 	{"dm7", NULL, cf_dm7, 1, {CVF_RHS | CVF_ANY_MODEL}},

	{"stipple", NULL, cf_stipple, 1, {CVF_RHS | CVF_ANY_MODEL}},
	{"no_stipple", NULL, cf_no_stipple, 1, {CVF_RHS | CVF_ANY_MODEL}},
	{"ori", NULL, cf_ori, 1, {CVF_RHS | CVF_ANY_MODEL}},
	{"no_ori", NULL, cf_no_ori, 1, {CVF_RHS | CVF_ANY_MODEL}},
	{"mute", NULL, cf_mute, 1, {CVF_RHS | CVF_ANY_MODEL}},
	{"unmute", NULL, cf_unmute, 1, {CVF_RHS | CVF_ANY_MODEL}},
	{"wireframe", NULL, cf_wireframe, 1, {CVF_RHS | CVF_ANY_MODEL}},
	{"no_wireframe", NULL, cf_no_wireframe, 1, {CVF_RHS | CVF_ANY_MODEL}},
	{"shade", NULL, cf_shade, 1, {CVF_RHS | CVF_ANY_MODEL}},
	{"no_shade", NULL, cf_no_shade, 1, {CVF_RHS | CVF_ANY_MODEL}},
	{"hide", NULL, cf_hide, 1, {CVF_RHS | CVF_ANY_MODEL}},
	{"show", NULL, cf_show, 1, {CVF_RHS | CVF_ANY_MODEL}},
	{"outline", NULL, cf_outline, 1, {CVF_RHS | CVF_ANY_MODEL}},
	{"no_outline", NULL, cf_no_outline, 1, {CVF_RHS | CVF_ANY_MODEL}},
	{"weight", NULL, cf_weight, 1, {CVF_RHS | CVF_ANY_MODEL}},
	{"no_weight", NULL, cf_no_weight, 1, {CVF_RHS | CVF_ANY_MODEL}},

	{"get_color", NULL, cf_get_color, 1, {CVF_RHS | CVF_ANY_MODEL}},
	{"get_alpha", NULL, cf_get_alpha, 1, {CVF_RHS | CVF_ANY_MODEL}},
	{"get_stipple", NULL, cf_get_stipple, 1, {CVF_RHS | CVF_ANY_MODEL}},
	{"get_wireframe", NULL, cf_get_wireframe, 1, {CVF_RHS | CVF_ANY_MODEL}},
	{"get_outline", NULL, cf_get_outline, 1, {CVF_RHS | CVF_ANY_MODEL}},
	{"get_weight", NULL, cf_get_weight, 1, {CVF_RHS | CVF_ANY_MODEL}},
	{"get_ori", NULL, cf_get_ori, 1, {CVF_RHS | CVF_ANY_MODEL}},
	{"get_hide", NULL, cf_get_hide, 1, {CVF_RHS | CVF_ANY_MODEL}},


	{"bit_not", NULL, cf_bit_not, 1, {CVF_RHS | CVF_ANY_MODEL}},
	{"bit_and", NULL, cf_bit_and, 2, {CVF_RHS | CVF_ANY_MODEL, CVF_RHS | CVF_ANY_MODEL}},
	{"bit_or", NULL, cf_bit_or, 2, {CVF_RHS | CVF_ANY_MODEL, CVF_RHS | CVF_ANY_MODEL}},
	{"bit_xor", NULL, cf_bit_xor, 2, {CVF_RHS | CVF_ANY_MODEL, CVF_RHS | CVF_ANY_MODEL}},
	{"bit_shift", NULL, cf_bit_shift, 2, {CVF_RHS | CVF_ANY_MODEL, CVF_RHS | CVF_ANY_MODEL}},

	// arg 1 = name, arg 2 = draw mode, other args are vertex names
 	{"create_polygon", NULL, cf_create_polygon_3, 5, {CVF_RHS | CVF_ANY_MODEL, CVF_RHS | CVF_ANY_MODEL, CVF_RHS | CVF_ANY_MODEL, CVF_RHS | CVF_ANY_MODEL, CVF_RHS | CVF_ANY_MODEL}},
 	{"create_polygon", NULL, cf_create_polygon_4, 6, {CVF_RHS | CVF_ANY_MODEL, CVF_RHS | CVF_ANY_MODEL, CVF_RHS | CVF_ANY_MODEL, CVF_RHS | CVF_ANY_MODEL, CVF_RHS | CVF_ANY_MODEL, CVF_RHS | CVF_ANY_MODEL}},
 	{"create_polygon", NULL, cf_create_polygon_5, 7, {CVF_RHS | CVF_ANY_MODEL, CVF_RHS | CVF_ANY_MODEL, CVF_RHS | CVF_ANY_MODEL, CVF_RHS | CVF_ANY_MODEL, CVF_RHS | CVF_ANY_MODEL, CVF_RHS | CVF_ANY_MODEL, CVF_RHS | CVF_ANY_MODEL}},
 	{"create_polygon", NULL, cf_create_polygon_6, 8, {CVF_RHS | CVF_ANY_MODEL, CVF_RHS | CVF_ANY_MODEL, CVF_RHS | CVF_ANY_MODEL, CVF_RHS | CVF_ANY_MODEL, CVF_RHS | CVF_ANY_MODEL, CVF_RHS | CVF_ANY_MODEL, CVF_RHS | CVF_ANY_MODEL, CVF_RHS | CVF_ANY_MODEL}},
 	
 	{"create_arc", NULL, cf_create_arc, 4, {CVF_RHS | CVF_ANY_MODEL, CVF_RHS | CVF_ANY_MODEL, CVF_RHS | CVF_ANY_MODEL, CVF_RHS | CVF_ANY_MODEL}},


	{"print", NULL, cf_e3ga_print, 1, {CVF_RHS | MVI_E3GA}},
	{"print", NULL, cf_e3ga_print_prec, 2, {CVF_RHS | MVI_E3GA, CVF_RHS | CVF_ANY_MODEL}},
	{"scalar", NULL, cf_e3ga_scalar, 1, {CVF_RHS | MVI_E3GA}},
	{"dual", NULL, cf_e3ga_dual, 1, {CVF_RHS | MVI_E3GA}},
	{"dual", NULL, cf_e3ga_dual2, 2, {CVF_RHS | MVI_E3GA, CVF_RHS | MVI_E3GA}},
	{"reverse", NULL, cf_e3ga_reverse, 1, {CVF_RHS | MVI_E3GA}},
	{"clifford_conjugate", NULL, cf_e3ga_clifford_conjugate, 1, {CVF_RHS | MVI_E3GA}},
	{"grade_involution", NULL, cf_e3ga_grade_involution, 1, {CVF_RHS | MVI_E3GA}},
	{"inverse", NULL, cf_e3ga_inverse, 1, {CVF_RHS | MVI_E3GA}},
	{"general_inverse", NULL, cf_e3ga_general_inverse, 1, {CVF_RHS | MVI_E3GA}},
	{"negate", NULL, cf_e3ga_negate, 1, {CVF_RHS | MVI_E3GA}},
	{"assign", NULL, cf_e3ga_assign, 2, {CVF_LHS | CVF_ANY_MODEL, CVF_RHS | MVI_E3GA}},
	{"gp", NULL, cf_e3ga_gp, 2, {CVF_RHS | MVI_E3GA, CVF_RHS | MVI_E3GA}},
	{"igp", NULL, cf_e3ga_igp, 2, {CVF_RHS | MVI_E3GA, CVF_RHS | MVI_E3GA}},
	{"op", NULL, cf_e3ga_op, 2, {CVF_RHS | MVI_E3GA, CVF_RHS | MVI_E3GA}},
	{"hip", NULL, cf_e3ga_hip, 2, {CVF_RHS | MVI_E3GA, CVF_RHS | MVI_E3GA}},
	{"mhip", NULL, cf_e3ga_mhip, 2, {CVF_RHS | MVI_E3GA, CVF_RHS | MVI_E3GA}},
	{"lcont", NULL, cf_e3ga_lcont, 2, {CVF_RHS | MVI_E3GA, CVF_RHS | MVI_E3GA}},
	{"rcont", NULL, cf_e3ga_rcont, 2, {CVF_RHS | MVI_E3GA, CVF_RHS | MVI_E3GA}},
	{"scp", NULL, cf_e3ga_scp, 2, {CVF_RHS | MVI_E3GA, CVF_RHS | MVI_E3GA}},
	{"gpem", NULL, cf_e3ga_gpem, 2, {CVF_RHS | MVI_E3GA, CVF_RHS | MVI_E3GA}},
	{"lcem", NULL, cf_e3ga_lcem, 2, {CVF_RHS | MVI_E3GA, CVF_RHS | MVI_E3GA}},
	{"meet", NULL, cf_e3ga_meet, 2, {CVF_RHS | MVI_E3GA, CVF_RHS | MVI_E3GA}},
	{"cp", NULL, cf_e3ga_cp, 2, {CVF_RHS | MVI_E3GA, CVF_RHS | MVI_E3GA}},
	{"join", NULL, cf_e3ga_join, 2, {CVF_RHS | MVI_E3GA, CVF_RHS | MVI_E3GA}},
	{"add", NULL, cf_e3ga_add, 2, {CVF_RHS | MVI_E3GA, CVF_RHS | MVI_E3GA}},
	{"sub", NULL, cf_e3ga_sub, 2, {CVF_RHS | MVI_E3GA, CVF_RHS | MVI_E3GA}},

	{"grade", NULL, cf_e3ga_grade_nb, 1, {CVF_RHS | MVI_E3GA}},
	{"grade", NULL, cf_e3ga_grade, 2, {CVF_RHS | MVI_E3GA, CVF_RHS | MVI_E3GA}},
	{"versor_parity", NULL, cf_e3ga_versor_parity, 1, {CVF_RHS | MVI_E3GA}},

	{"norm", NULL, cf_e3ga_norm, 1, {CVF_RHS | MVI_E3GA}},
	{"norm_2", NULL, cf_e3ga_norm_2, 1, {CVF_RHS | MVI_E3GA}},
	{"norm_r", NULL, cf_e3ga_norm_r, 1, {CVF_RHS | MVI_E3GA}},

	{"normalize", NULL, cf_e3ga_normalize, 1, {CVF_RHS | MVI_E3GA}},


	{"abs", NULL, cf_e3ga_abs, 1, {CVF_RHS | MVI_E3GA}},

	{"sqrt", NULL, cf_e3ga_sqrt, 1, {CVF_RHS | MVI_E3GA}},
	{"tan", NULL, cf_e3ga_tan, 1, {CVF_RHS | MVI_E3GA}},
	{"sin", NULL, cf_e3ga_sin, 1, {CVF_RHS | MVI_E3GA}},
	{"cos", NULL, cf_e3ga_cos, 1, {CVF_RHS | MVI_E3GA}},
	{"atan", NULL, cf_e3ga_atan, 1, {CVF_RHS | MVI_E3GA}},
	{"asin", NULL, cf_e3ga_asin, 1, {CVF_RHS | MVI_E3GA}},
	{"acos", NULL, cf_e3ga_acos, 1, {CVF_RHS | MVI_E3GA}},
	{"atan2", NULL, cf_e3ga_atan2, 2, {CVF_RHS | MVI_E3GA, CVF_RHS | MVI_E3GA}},
	{"cosh", NULL, cf_e3ga_cosh, 1, {CVF_RHS | MVI_E3GA}},
	{"sinh", NULL, cf_e3ga_sinh, 1, {CVF_RHS | MVI_E3GA}},
	{"acosh", NULL, cf_e3ga_acosh, 1, {CVF_RHS | MVI_E3GA}},
	{"asinh", NULL, cf_e3ga_asinh, 1, {CVF_RHS | MVI_E3GA}},
	{"sinc", NULL, cf_e3ga_sinc, 1, {CVF_RHS | MVI_E3GA}},
	{"log", NULL, cf_e3ga_log, 1, {CVF_RHS | MVI_E3GA}},
	{"exp", NULL, cf_e3ga_exp, 1, {CVF_RHS | MVI_E3GA}},
	{"pow", NULL, cf_e3ga_pow, 2, {CVF_RHS | MVI_E3GA, CVF_RHS | MVI_E3GA}},
	{"scalar_pow", NULL, cf_e3ga_scalar_pow, 2, {CVF_RHS | MVI_E3GA, CVF_RHS | MVI_E3GA}},
	{"max", NULL, cf_e3ga_max, 2, {CVF_RHS | MVI_E3GA, CVF_RHS | MVI_E3GA}},
	{"min", NULL, cf_e3ga_min, 2, {CVF_RHS | MVI_E3GA, CVF_RHS | MVI_E3GA}},
	
//	{"time", NULL, cf_e3ga_time, 0, {}},
	{"randSeed", NULL, cf_e3ga_randSeed, 1, {CVF_RHS | MVI_E3GA}},
	{"randGauss", NULL, cf_e3ga_randGauss, 2, {CVF_RHS | MVI_E3GA, CVF_RHS | MVI_E3GA}},
	
	{"versor_product", NULL, cf_e3ga_versorProduct, 2, {CVF_RHS | MVI_E3GA, CVF_RHS | MVI_E3GA}},
	{"inverse_versor_product", NULL, cf_e3ga_inverseVersorProduct, 2, {CVF_RHS | MVI_E3GA, CVF_RHS | MVI_E3GA}},
	{"vp", NULL, cf_e3ga_versorProduct, 2, {CVF_RHS | MVI_E3GA, CVF_RHS | MVI_E3GA}},
	{"ivp", NULL, cf_e3ga_inverseVersorProduct, 2, {CVF_RHS | MVI_E3GA, CVF_RHS | MVI_E3GA}},

	// temp mierenneuk version of versor product
	{"mnvp", NULL, cf_e3ga_MNversorProduct, 2, {CVF_RHS | MVI_E3GA, CVF_RHS | MVI_E3GA}},
	{"mnivp", NULL, cf_e3ga_MNinverseVersorProduct, 2, {CVF_RHS | MVI_E3GA, CVF_RHS | MVI_E3GA}},
	
	{"project", NULL, cf_e3ga_project, 2, {CVF_RHS | MVI_E3GA, CVF_RHS | MVI_E3GA}},
	{"reject", NULL, cf_e3ga_reject, 2, {CVF_RHS | MVI_E3GA, CVF_RHS | MVI_E3GA}},

	{"factor", NULL, cf_e3ga_factor, 2, {CVF_RHS | MVI_E3GA, CVF_RHS | MVI_E3GA}},

	{"set_factor", NULL, cf_e3ga_set_factor, 2, {CVF_RHS | CVF_ANY_MODEL, CVF_RHS | MVI_E3GA}},

	{"equal", NULL, cf_e3ga_equal, 2, {CVF_RHS | MVI_E3GA, CVF_RHS | MVI_E3GA}},
	{"ne", NULL, cf_e3ga_ne, 2, {CVF_RHS | MVI_E3GA, CVF_RHS | MVI_E3GA}},
	{"less", NULL, cf_e3ga_less, 2, {CVF_RHS | MVI_E3GA, CVF_RHS | MVI_E3GA}},
	{"greater", NULL, cf_e3ga_greater, 2, {CVF_RHS | MVI_E3GA, CVF_RHS | MVI_E3GA}},
	{"le", NULL, cf_e3ga_le, 2, {CVF_RHS | MVI_E3GA, CVF_RHS | MVI_E3GA}},
	{"ge", NULL, cf_e3ga_ge, 2, {CVF_RHS | MVI_E3GA, CVF_RHS | MVI_E3GA}},
	{"and", NULL, cf_e3ga_and, 2, {CVF_RHS | MVI_E3GA, CVF_RHS | MVI_E3GA}},
	{"or", NULL, cf_e3ga_or, 2, {CVF_RHS | MVI_E3GA, CVF_RHS | MVI_E3GA}},
	{"not", NULL, cf_e3ga_not, 1, {CVF_RHS | MVI_E3GA}},

/*
To add: 

To debug general inverse fails after one failure?
Or after multiple algebra use????
*/



	{"print", NULL, cf_p3ga_print, 1, {CVF_RHS | MVI_P3GA}},
	{"print", NULL, cf_p3ga_print_prec, 2, {CVF_RHS | MVI_P3GA, CVF_RHS | CVF_ANY_MODEL}},
	{"scalar", NULL, cf_p3ga_scalar, 1, {CVF_RHS | MVI_P3GA}},
	{"dual", NULL, cf_p3ga_dual, 1, {CVF_RHS | MVI_P3GA}},
	{"dual", NULL, cf_p3ga_dual2, 2, {CVF_RHS | MVI_P3GA, CVF_RHS | MVI_P3GA}},
	{"reverse", NULL, cf_p3ga_reverse, 1, {CVF_RHS | MVI_P3GA}},
	{"clifford_conjugate", NULL, cf_p3ga_clifford_conjugate, 1, {CVF_RHS | MVI_P3GA}},
	{"grade_involution", NULL, cf_p3ga_grade_involution, 1, {CVF_RHS | MVI_P3GA}},
	{"inverse", NULL, cf_p3ga_inverse, 1, {CVF_RHS | MVI_P3GA}},
	{"general_inverse", NULL, cf_p3ga_general_inverse, 1, {CVF_RHS | MVI_P3GA}},
	{"negate", NULL, cf_p3ga_negate, 1, {CVF_RHS | MVI_P3GA}},
	{"assign", NULL, cf_p3ga_assign, 2, {CVF_LHS | CVF_ANY_MODEL, CVF_RHS | MVI_P3GA}},
	{"gp", NULL, cf_p3ga_gp, 2, {CVF_RHS | MVI_P3GA, CVF_RHS | MVI_P3GA}},
	{"igp", NULL, cf_p3ga_igp, 2, {CVF_RHS | MVI_P3GA, CVF_RHS | MVI_P3GA}},
	{"op", NULL, cf_p3ga_op, 2, {CVF_RHS | MVI_P3GA, CVF_RHS | MVI_P3GA}},
	{"hip", NULL, cf_p3ga_hip, 2, {CVF_RHS | MVI_P3GA, CVF_RHS | MVI_P3GA}},
	{"mhip", NULL, cf_p3ga_mhip, 2, {CVF_RHS | MVI_P3GA, CVF_RHS | MVI_P3GA}},
	{"lcont", NULL, cf_p3ga_lcont, 2, {CVF_RHS | MVI_P3GA, CVF_RHS | MVI_P3GA}},
	{"rcont", NULL, cf_p3ga_rcont, 2, {CVF_RHS | MVI_P3GA, CVF_RHS | MVI_P3GA}},
	{"scp", NULL, cf_p3ga_scp, 2, {CVF_RHS | MVI_P3GA, CVF_RHS | MVI_P3GA}},
	{"gpem", NULL, cf_p3ga_gpem, 2, {CVF_RHS | MVI_P3GA, CVF_RHS | MVI_P3GA}},
	{"lcem", NULL, cf_p3ga_lcem, 2, {CVF_RHS | MVI_P3GA, CVF_RHS | MVI_P3GA}},
	{"meet", NULL, cf_p3ga_meet, 2, {CVF_RHS | MVI_P3GA, CVF_RHS | MVI_P3GA}},
	{"cp", NULL, cf_p3ga_cp, 2, {CVF_RHS | MVI_P3GA, CVF_RHS | MVI_P3GA}},
	{"join", NULL, cf_p3ga_join, 2, {CVF_RHS | MVI_P3GA, CVF_RHS | MVI_P3GA}},
	{"add", NULL, cf_p3ga_add, 2, {CVF_RHS | MVI_P3GA, CVF_RHS | MVI_P3GA}},
	{"sub", NULL, cf_p3ga_sub, 2, {CVF_RHS | MVI_P3GA, CVF_RHS | MVI_P3GA}},

	{"grade", NULL, cf_p3ga_grade_nb, 1, {CVF_RHS | MVI_P3GA}},
	{"grade", NULL, cf_p3ga_grade, 2, {CVF_RHS | MVI_P3GA, CVF_RHS | MVI_P3GA}},
	{"versor_parity", NULL, cf_p3ga_versor_parity, 1, {CVF_RHS | MVI_P3GA}},

	{"norm", NULL, cf_p3ga_norm, 1, {CVF_RHS | MVI_P3GA}},
	{"norm_2", NULL, cf_p3ga_norm_2, 1, {CVF_RHS | MVI_P3GA}},
	{"norm_r", NULL, cf_p3ga_norm_r, 1, {CVF_RHS | MVI_P3GA}},

	{"normalize", NULL, cf_p3ga_normalize, 1, {CVF_RHS | MVI_P3GA}},


	{"abs", NULL, cf_p3ga_abs, 1, {CVF_RHS | MVI_P3GA}},

	{"sqrt", NULL, cf_p3ga_sqrt, 1, {CVF_RHS | MVI_P3GA}},
	{"tan", NULL, cf_p3ga_tan, 1, {CVF_RHS | MVI_P3GA}},
	{"sin", NULL, cf_p3ga_sin, 1, {CVF_RHS | MVI_P3GA}},
	{"cos", NULL, cf_p3ga_cos, 1, {CVF_RHS | MVI_P3GA}},
	{"atan", NULL, cf_p3ga_atan, 1, {CVF_RHS | MVI_P3GA}},
	{"asin", NULL, cf_p3ga_asin, 1, {CVF_RHS | MVI_P3GA}},
	{"acos", NULL, cf_p3ga_acos, 1, {CVF_RHS | MVI_P3GA}},
	{"atan2", NULL, cf_p3ga_atan2, 2, {CVF_RHS | MVI_P3GA, CVF_RHS | MVI_P3GA}},
	{"cosh", NULL, cf_p3ga_cosh, 1, {CVF_RHS | MVI_P3GA}},
	{"sinh", NULL, cf_p3ga_sinh, 1, {CVF_RHS | MVI_P3GA}},
	{"acosh", NULL, cf_p3ga_acosh, 1, {CVF_RHS | MVI_P3GA}},
	{"asinh", NULL, cf_p3ga_asinh, 1, {CVF_RHS | MVI_P3GA}},
	{"sinc", NULL, cf_p3ga_sinc, 1, {CVF_RHS | MVI_P3GA}},
	{"log", NULL, cf_p3ga_log, 1, {CVF_RHS | MVI_P3GA}},
	{"exp", NULL, cf_p3ga_exp, 1, {CVF_RHS | MVI_P3GA}},
	{"pow", NULL, cf_p3ga_pow, 2, {CVF_RHS | MVI_P3GA, CVF_RHS | MVI_P3GA}},
	{"scalar_pow", NULL, cf_p3ga_scalar_pow, 2, {CVF_RHS | MVI_P3GA, CVF_RHS | MVI_P3GA}},
	{"max", NULL, cf_p3ga_max, 2, {CVF_RHS | MVI_P3GA, CVF_RHS | MVI_P3GA}},
	{"min", NULL, cf_p3ga_min, 2, {CVF_RHS | MVI_P3GA, CVF_RHS | MVI_P3GA}},
	
//	{"time", NULL, cf_p3ga_time, 0, {}},
	{"randSeed", NULL, cf_p3ga_randSeed, 1, {CVF_RHS | MVI_P3GA}},
	{"randGauss", NULL, cf_p3ga_randGauss, 2, {CVF_RHS | MVI_P3GA, CVF_RHS | MVI_P3GA}},
	
	{"versor_product", NULL, cf_p3ga_versorProduct, 2, {CVF_RHS | MVI_P3GA, CVF_RHS | MVI_P3GA}},
	{"inverse_versor_product", NULL, cf_p3ga_inverseVersorProduct, 2, {CVF_RHS | MVI_P3GA, CVF_RHS | MVI_P3GA}},
	{"vp", NULL, cf_p3ga_versorProduct, 2, {CVF_RHS | MVI_P3GA, CVF_RHS | MVI_P3GA}},
	{"ivp", NULL, cf_p3ga_inverseVersorProduct, 2, {CVF_RHS | MVI_P3GA, CVF_RHS | MVI_P3GA}},

	// temp mierenneuk version of versor product
	{"mnvp", NULL, cf_p3ga_MNversorProduct, 2, {CVF_RHS | MVI_P3GA, CVF_RHS | MVI_P3GA}},
	{"mnivp", NULL, cf_p3ga_MNinverseVersorProduct, 2, {CVF_RHS | MVI_P3GA, CVF_RHS | MVI_P3GA}},
	
	{"project", NULL, cf_p3ga_project, 2, {CVF_RHS | MVI_P3GA, CVF_RHS | MVI_P3GA}},
	{"reject", NULL, cf_p3ga_reject, 2, {CVF_RHS | MVI_P3GA, CVF_RHS | MVI_P3GA}},

	{"factor", NULL, cf_p3ga_factor, 2, {CVF_RHS | MVI_P3GA, CVF_RHS | MVI_P3GA}},

	{"set_factor", NULL, cf_p3ga_set_factor, 2, {CVF_RHS | CVF_ANY_MODEL, CVF_RHS | MVI_P3GA}},

	{"equal", NULL, cf_p3ga_equal, 2, {CVF_RHS | MVI_P3GA, CVF_RHS | MVI_P3GA}},
	{"ne", NULL, cf_p3ga_ne, 2, {CVF_RHS | MVI_P3GA, CVF_RHS | MVI_P3GA}},
	{"less", NULL, cf_p3ga_less, 2, {CVF_RHS | MVI_P3GA, CVF_RHS | MVI_P3GA}},
	{"greater", NULL, cf_p3ga_greater, 2, {CVF_RHS | MVI_P3GA, CVF_RHS | MVI_P3GA}},
	{"le", NULL, cf_p3ga_le, 2, {CVF_RHS | MVI_P3GA, CVF_RHS | MVI_P3GA}},
	{"ge", NULL, cf_p3ga_ge, 2, {CVF_RHS | MVI_P3GA, CVF_RHS | MVI_P3GA}},
	{"and", NULL, cf_p3ga_and, 2, {CVF_RHS | MVI_P3GA, CVF_RHS | MVI_P3GA}},
	{"or", NULL, cf_p3ga_or, 2, {CVF_RHS | MVI_P3GA, CVF_RHS | MVI_P3GA}},
	{"not", NULL, cf_p3ga_not, 1, {CVF_RHS | MVI_P3GA}},

/*
To add: 

To debug general inverse fails after one failure?
Or after multiple algebra use????
*/



	{"print", NULL, cf_c3ga_print, 1, {CVF_RHS | MVI_C3GA}},
	{"print", NULL, cf_c3ga_print_prec, 2, {CVF_RHS | MVI_C3GA, CVF_RHS | CVF_ANY_MODEL}},
	{"scalar", NULL, cf_c3ga_scalar, 1, {CVF_RHS | MVI_C3GA}},
	{"dual", NULL, cf_c3ga_dual, 1, {CVF_RHS | MVI_C3GA}},
	{"dual", NULL, cf_c3ga_dual2, 2, {CVF_RHS | MVI_C3GA, CVF_RHS | MVI_C3GA}},
	{"reverse", NULL, cf_c3ga_reverse, 1, {CVF_RHS | MVI_C3GA}},
	{"clifford_conjugate", NULL, cf_c3ga_clifford_conjugate, 1, {CVF_RHS | MVI_C3GA}},
	{"grade_involution", NULL, cf_c3ga_grade_involution, 1, {CVF_RHS | MVI_C3GA}},
	{"inverse", NULL, cf_c3ga_inverse, 1, {CVF_RHS | MVI_C3GA}},
	{"general_inverse", NULL, cf_c3ga_general_inverse, 1, {CVF_RHS | MVI_C3GA}},
	{"negate", NULL, cf_c3ga_negate, 1, {CVF_RHS | MVI_C3GA}},
	{"assign", NULL, cf_c3ga_assign, 2, {CVF_LHS | CVF_ANY_MODEL, CVF_RHS | MVI_C3GA}},
	{"gp", NULL, cf_c3ga_gp, 2, {CVF_RHS | MVI_C3GA, CVF_RHS | MVI_C3GA}},
	{"igp", NULL, cf_c3ga_igp, 2, {CVF_RHS | MVI_C3GA, CVF_RHS | MVI_C3GA}},
	{"op", NULL, cf_c3ga_op, 2, {CVF_RHS | MVI_C3GA, CVF_RHS | MVI_C3GA}},
	{"hip", NULL, cf_c3ga_hip, 2, {CVF_RHS | MVI_C3GA, CVF_RHS | MVI_C3GA}},
	{"mhip", NULL, cf_c3ga_mhip, 2, {CVF_RHS | MVI_C3GA, CVF_RHS | MVI_C3GA}},
	{"lcont", NULL, cf_c3ga_lcont, 2, {CVF_RHS | MVI_C3GA, CVF_RHS | MVI_C3GA}},
	{"rcont", NULL, cf_c3ga_rcont, 2, {CVF_RHS | MVI_C3GA, CVF_RHS | MVI_C3GA}},
	{"scp", NULL, cf_c3ga_scp, 2, {CVF_RHS | MVI_C3GA, CVF_RHS | MVI_C3GA}},
	{"gpem", NULL, cf_c3ga_gpem, 2, {CVF_RHS | MVI_C3GA, CVF_RHS | MVI_C3GA}},
	{"lcem", NULL, cf_c3ga_lcem, 2, {CVF_RHS | MVI_C3GA, CVF_RHS | MVI_C3GA}},
	{"meet", NULL, cf_c3ga_meet, 2, {CVF_RHS | MVI_C3GA, CVF_RHS | MVI_C3GA}},
	{"cp", NULL, cf_c3ga_cp, 2, {CVF_RHS | MVI_C3GA, CVF_RHS | MVI_C3GA}},
	{"join", NULL, cf_c3ga_join, 2, {CVF_RHS | MVI_C3GA, CVF_RHS | MVI_C3GA}},
	{"add", NULL, cf_c3ga_add, 2, {CVF_RHS | MVI_C3GA, CVF_RHS | MVI_C3GA}},
	{"sub", NULL, cf_c3ga_sub, 2, {CVF_RHS | MVI_C3GA, CVF_RHS | MVI_C3GA}},

	{"grade", NULL, cf_c3ga_grade_nb, 1, {CVF_RHS | MVI_C3GA}},
	{"grade", NULL, cf_c3ga_grade, 2, {CVF_RHS | MVI_C3GA, CVF_RHS | MVI_C3GA}},
	{"versor_parity", NULL, cf_c3ga_versor_parity, 1, {CVF_RHS | MVI_C3GA}},

	{"norm", NULL, cf_c3ga_norm, 1, {CVF_RHS | MVI_C3GA}},
	{"norm_2", NULL, cf_c3ga_norm_2, 1, {CVF_RHS | MVI_C3GA}},
	{"norm_r", NULL, cf_c3ga_norm_r, 1, {CVF_RHS | MVI_C3GA}},

	{"normalize", NULL, cf_c3ga_normalize, 1, {CVF_RHS | MVI_C3GA}},


	{"abs", NULL, cf_c3ga_abs, 1, {CVF_RHS | MVI_C3GA}},

	{"sqrt", NULL, cf_c3ga_sqrt, 1, {CVF_RHS | MVI_C3GA}},
	{"tan", NULL, cf_c3ga_tan, 1, {CVF_RHS | MVI_C3GA}},
	{"sin", NULL, cf_c3ga_sin, 1, {CVF_RHS | MVI_C3GA}},
	{"cos", NULL, cf_c3ga_cos, 1, {CVF_RHS | MVI_C3GA}},
	{"atan", NULL, cf_c3ga_atan, 1, {CVF_RHS | MVI_C3GA}},
	{"asin", NULL, cf_c3ga_asin, 1, {CVF_RHS | MVI_C3GA}},
	{"acos", NULL, cf_c3ga_acos, 1, {CVF_RHS | MVI_C3GA}},
	{"atan2", NULL, cf_c3ga_atan2, 2, {CVF_RHS | MVI_C3GA, CVF_RHS | MVI_C3GA}},
	{"cosh", NULL, cf_c3ga_cosh, 1, {CVF_RHS | MVI_C3GA}},
	{"sinh", NULL, cf_c3ga_sinh, 1, {CVF_RHS | MVI_C3GA}},
	{"acosh", NULL, cf_c3ga_acosh, 1, {CVF_RHS | MVI_C3GA}},
	{"asinh", NULL, cf_c3ga_asinh, 1, {CVF_RHS | MVI_C3GA}},
	{"sinc", NULL, cf_c3ga_sinc, 1, {CVF_RHS | MVI_C3GA}},
	{"log", NULL, cf_c3ga_log, 1, {CVF_RHS | MVI_C3GA}},
	{"exp", NULL, cf_c3ga_exp, 1, {CVF_RHS | MVI_C3GA}},
	{"pow", NULL, cf_c3ga_pow, 2, {CVF_RHS | MVI_C3GA, CVF_RHS | MVI_C3GA}},
	{"scalar_pow", NULL, cf_c3ga_scalar_pow, 2, {CVF_RHS | MVI_C3GA, CVF_RHS | MVI_C3GA}},
	{"max", NULL, cf_c3ga_max, 2, {CVF_RHS | MVI_C3GA, CVF_RHS | MVI_C3GA}},
	{"min", NULL, cf_c3ga_min, 2, {CVF_RHS | MVI_C3GA, CVF_RHS | MVI_C3GA}},
	
//	{"time", NULL, cf_c3ga_time, 0, {}},
	{"randSeed", NULL, cf_c3ga_randSeed, 1, {CVF_RHS | MVI_C3GA}},
	{"randGauss", NULL, cf_c3ga_randGauss, 2, {CVF_RHS | MVI_C3GA, CVF_RHS | MVI_C3GA}},
	
	{"versor_product", NULL, cf_c3ga_versorProduct, 2, {CVF_RHS | MVI_C3GA, CVF_RHS | MVI_C3GA}},
	{"inverse_versor_product", NULL, cf_c3ga_inverseVersorProduct, 2, {CVF_RHS | MVI_C3GA, CVF_RHS | MVI_C3GA}},
	{"vp", NULL, cf_c3ga_versorProduct, 2, {CVF_RHS | MVI_C3GA, CVF_RHS | MVI_C3GA}},
	{"ivp", NULL, cf_c3ga_inverseVersorProduct, 2, {CVF_RHS | MVI_C3GA, CVF_RHS | MVI_C3GA}},

	// temp mierenneuk version of versor product
	{"mnvp", NULL, cf_c3ga_MNversorProduct, 2, {CVF_RHS | MVI_C3GA, CVF_RHS | MVI_C3GA}},
	{"mnivp", NULL, cf_c3ga_MNinverseVersorProduct, 2, {CVF_RHS | MVI_C3GA, CVF_RHS | MVI_C3GA}},
	
	{"project", NULL, cf_c3ga_project, 2, {CVF_RHS | MVI_C3GA, CVF_RHS | MVI_C3GA}},
	{"reject", NULL, cf_c3ga_reject, 2, {CVF_RHS | MVI_C3GA, CVF_RHS | MVI_C3GA}},

	{"factor", NULL, cf_c3ga_factor, 2, {CVF_RHS | MVI_C3GA, CVF_RHS | MVI_C3GA}},

	{"set_factor", NULL, cf_c3ga_set_factor, 2, {CVF_RHS | CVF_ANY_MODEL, CVF_RHS | MVI_C3GA}},

	{"equal", NULL, cf_c3ga_equal, 2, {CVF_RHS | MVI_C3GA, CVF_RHS | MVI_C3GA}},
	{"ne", NULL, cf_c3ga_ne, 2, {CVF_RHS | MVI_C3GA, CVF_RHS | MVI_C3GA}},
	{"less", NULL, cf_c3ga_less, 2, {CVF_RHS | MVI_C3GA, CVF_RHS | MVI_C3GA}},
	{"greater", NULL, cf_c3ga_greater, 2, {CVF_RHS | MVI_C3GA, CVF_RHS | MVI_C3GA}},
	{"le", NULL, cf_c3ga_le, 2, {CVF_RHS | MVI_C3GA, CVF_RHS | MVI_C3GA}},
	{"ge", NULL, cf_c3ga_ge, 2, {CVF_RHS | MVI_C3GA, CVF_RHS | MVI_C3GA}},
	{"and", NULL, cf_c3ga_and, 2, {CVF_RHS | MVI_C3GA, CVF_RHS | MVI_C3GA}},
	{"or", NULL, cf_c3ga_or, 2, {CVF_RHS | MVI_C3GA, CVF_RHS | MVI_C3GA}},
	{"not", NULL, cf_c3ga_not, 1, {CVF_RHS | MVI_C3GA}},

/*
To add: 

To debug general inverse fails after one failure?
Or after multiple algebra use????
*/



	{"print", NULL, cf_c5ga_print, 1, {CVF_RHS | MVI_C5GA}},
	{"print", NULL, cf_c5ga_print_prec, 2, {CVF_RHS | MVI_C5GA, CVF_RHS | CVF_ANY_MODEL}},
	{"scalar", NULL, cf_c5ga_scalar, 1, {CVF_RHS | MVI_C5GA}},
	{"dual", NULL, cf_c5ga_dual, 1, {CVF_RHS | MVI_C5GA}},
	{"dual", NULL, cf_c5ga_dual2, 2, {CVF_RHS | MVI_C5GA, CVF_RHS | MVI_C5GA}},
	{"reverse", NULL, cf_c5ga_reverse, 1, {CVF_RHS | MVI_C5GA}},
	{"clifford_conjugate", NULL, cf_c5ga_clifford_conjugate, 1, {CVF_RHS | MVI_C5GA}},
	{"grade_involution", NULL, cf_c5ga_grade_involution, 1, {CVF_RHS | MVI_C5GA}},
	{"inverse", NULL, cf_c5ga_inverse, 1, {CVF_RHS | MVI_C5GA}},
	{"general_inverse", NULL, cf_c5ga_general_inverse, 1, {CVF_RHS | MVI_C5GA}},
	{"negate", NULL, cf_c5ga_negate, 1, {CVF_RHS | MVI_C5GA}},
	{"assign", NULL, cf_c5ga_assign, 2, {CVF_LHS | CVF_ANY_MODEL, CVF_RHS | MVI_C5GA}},
	{"gp", NULL, cf_c5ga_gp, 2, {CVF_RHS | MVI_C5GA, CVF_RHS | MVI_C5GA}},
	{"igp", NULL, cf_c5ga_igp, 2, {CVF_RHS | MVI_C5GA, CVF_RHS | MVI_C5GA}},
	{"op", NULL, cf_c5ga_op, 2, {CVF_RHS | MVI_C5GA, CVF_RHS | MVI_C5GA}},
	{"hip", NULL, cf_c5ga_hip, 2, {CVF_RHS | MVI_C5GA, CVF_RHS | MVI_C5GA}},
	{"mhip", NULL, cf_c5ga_mhip, 2, {CVF_RHS | MVI_C5GA, CVF_RHS | MVI_C5GA}},
	{"lcont", NULL, cf_c5ga_lcont, 2, {CVF_RHS | MVI_C5GA, CVF_RHS | MVI_C5GA}},
	{"rcont", NULL, cf_c5ga_rcont, 2, {CVF_RHS | MVI_C5GA, CVF_RHS | MVI_C5GA}},
	{"scp", NULL, cf_c5ga_scp, 2, {CVF_RHS | MVI_C5GA, CVF_RHS | MVI_C5GA}},
	{"gpem", NULL, cf_c5ga_gpem, 2, {CVF_RHS | MVI_C5GA, CVF_RHS | MVI_C5GA}},
	{"lcem", NULL, cf_c5ga_lcem, 2, {CVF_RHS | MVI_C5GA, CVF_RHS | MVI_C5GA}},
	{"meet", NULL, cf_c5ga_meet, 2, {CVF_RHS | MVI_C5GA, CVF_RHS | MVI_C5GA}},
	{"cp", NULL, cf_c5ga_cp, 2, {CVF_RHS | MVI_C5GA, CVF_RHS | MVI_C5GA}},
	{"join", NULL, cf_c5ga_join, 2, {CVF_RHS | MVI_C5GA, CVF_RHS | MVI_C5GA}},
	{"add", NULL, cf_c5ga_add, 2, {CVF_RHS | MVI_C5GA, CVF_RHS | MVI_C5GA}},
	{"sub", NULL, cf_c5ga_sub, 2, {CVF_RHS | MVI_C5GA, CVF_RHS | MVI_C5GA}},

	{"grade", NULL, cf_c5ga_grade_nb, 1, {CVF_RHS | MVI_C5GA}},
	{"grade", NULL, cf_c5ga_grade, 2, {CVF_RHS | MVI_C5GA, CVF_RHS | MVI_C5GA}},
	{"versor_parity", NULL, cf_c5ga_versor_parity, 1, {CVF_RHS | MVI_C5GA}},

	{"norm", NULL, cf_c5ga_norm, 1, {CVF_RHS | MVI_C5GA}},
	{"norm_2", NULL, cf_c5ga_norm_2, 1, {CVF_RHS | MVI_C5GA}},
	{"norm_r", NULL, cf_c5ga_norm_r, 1, {CVF_RHS | MVI_C5GA}},

	{"normalize", NULL, cf_c5ga_normalize, 1, {CVF_RHS | MVI_C5GA}},


	{"abs", NULL, cf_c5ga_abs, 1, {CVF_RHS | MVI_C5GA}},

	{"sqrt", NULL, cf_c5ga_sqrt, 1, {CVF_RHS | MVI_C5GA}},
	{"tan", NULL, cf_c5ga_tan, 1, {CVF_RHS | MVI_C5GA}},
	{"sin", NULL, cf_c5ga_sin, 1, {CVF_RHS | MVI_C5GA}},
	{"cos", NULL, cf_c5ga_cos, 1, {CVF_RHS | MVI_C5GA}},
	{"atan", NULL, cf_c5ga_atan, 1, {CVF_RHS | MVI_C5GA}},
	{"asin", NULL, cf_c5ga_asin, 1, {CVF_RHS | MVI_C5GA}},
	{"acos", NULL, cf_c5ga_acos, 1, {CVF_RHS | MVI_C5GA}},
	{"atan2", NULL, cf_c5ga_atan2, 2, {CVF_RHS | MVI_C5GA, CVF_RHS | MVI_C5GA}},
	{"cosh", NULL, cf_c5ga_cosh, 1, {CVF_RHS | MVI_C5GA}},
	{"sinh", NULL, cf_c5ga_sinh, 1, {CVF_RHS | MVI_C5GA}},
	{"acosh", NULL, cf_c5ga_acosh, 1, {CVF_RHS | MVI_C5GA}},
	{"asinh", NULL, cf_c5ga_asinh, 1, {CVF_RHS | MVI_C5GA}},
	{"sinc", NULL, cf_c5ga_sinc, 1, {CVF_RHS | MVI_C5GA}},
	{"log", NULL, cf_c5ga_log, 1, {CVF_RHS | MVI_C5GA}},
	{"exp", NULL, cf_c5ga_exp, 1, {CVF_RHS | MVI_C5GA}},
	{"pow", NULL, cf_c5ga_pow, 2, {CVF_RHS | MVI_C5GA, CVF_RHS | MVI_C5GA}},
	{"scalar_pow", NULL, cf_c5ga_scalar_pow, 2, {CVF_RHS | MVI_C5GA, CVF_RHS | MVI_C5GA}},
	{"max", NULL, cf_c5ga_max, 2, {CVF_RHS | MVI_C5GA, CVF_RHS | MVI_C5GA}},
	{"min", NULL, cf_c5ga_min, 2, {CVF_RHS | MVI_C5GA, CVF_RHS | MVI_C5GA}},
	
//	{"time", NULL, cf_c5ga_time, 0, {}},
	{"randSeed", NULL, cf_c5ga_randSeed, 1, {CVF_RHS | MVI_C5GA}},
	{"randGauss", NULL, cf_c5ga_randGauss, 2, {CVF_RHS | MVI_C5GA, CVF_RHS | MVI_C5GA}},
	
	{"versor_product", NULL, cf_c5ga_versorProduct, 2, {CVF_RHS | MVI_C5GA, CVF_RHS | MVI_C5GA}},
	{"inverse_versor_product", NULL, cf_c5ga_inverseVersorProduct, 2, {CVF_RHS | MVI_C5GA, CVF_RHS | MVI_C5GA}},
	{"vp", NULL, cf_c5ga_versorProduct, 2, {CVF_RHS | MVI_C5GA, CVF_RHS | MVI_C5GA}},
	{"ivp", NULL, cf_c5ga_inverseVersorProduct, 2, {CVF_RHS | MVI_C5GA, CVF_RHS | MVI_C5GA}},

	// temp mierenneuk version of versor product
	{"mnvp", NULL, cf_c5ga_MNversorProduct, 2, {CVF_RHS | MVI_C5GA, CVF_RHS | MVI_C5GA}},
	{"mnivp", NULL, cf_c5ga_MNinverseVersorProduct, 2, {CVF_RHS | MVI_C5GA, CVF_RHS | MVI_C5GA}},
	
	{"project", NULL, cf_c5ga_project, 2, {CVF_RHS | MVI_C5GA, CVF_RHS | MVI_C5GA}},
	{"reject", NULL, cf_c5ga_reject, 2, {CVF_RHS | MVI_C5GA, CVF_RHS | MVI_C5GA}},

	{"factor", NULL, cf_c5ga_factor, 2, {CVF_RHS | MVI_C5GA, CVF_RHS | MVI_C5GA}},

	{"set_factor", NULL, cf_c5ga_set_factor, 2, {CVF_RHS | CVF_ANY_MODEL, CVF_RHS | MVI_C5GA}},

	{"equal", NULL, cf_c5ga_equal, 2, {CVF_RHS | MVI_C5GA, CVF_RHS | MVI_C5GA}},
	{"ne", NULL, cf_c5ga_ne, 2, {CVF_RHS | MVI_C5GA, CVF_RHS | MVI_C5GA}},
	{"less", NULL, cf_c5ga_less, 2, {CVF_RHS | MVI_C5GA, CVF_RHS | MVI_C5GA}},
	{"greater", NULL, cf_c5ga_greater, 2, {CVF_RHS | MVI_C5GA, CVF_RHS | MVI_C5GA}},
	{"le", NULL, cf_c5ga_le, 2, {CVF_RHS | MVI_C5GA, CVF_RHS | MVI_C5GA}},
	{"ge", NULL, cf_c5ga_ge, 2, {CVF_RHS | MVI_C5GA, CVF_RHS | MVI_C5GA}},
	{"and", NULL, cf_c5ga_and, 2, {CVF_RHS | MVI_C5GA, CVF_RHS | MVI_C5GA}},
	{"or", NULL, cf_c5ga_or, 2, {CVF_RHS | MVI_C5GA, CVF_RHS | MVI_C5GA}},
	{"not", NULL, cf_c5ga_not, 1, {CVF_RHS | MVI_C5GA}},

/*
To add: 

To debug general inverse fails after one failure?
Or after multiple algebra use????
*/



	{"print", NULL, cf_i2ga_print, 1, {CVF_RHS | MVI_I2GA}},
	{"print", NULL, cf_i2ga_print_prec, 2, {CVF_RHS | MVI_I2GA, CVF_RHS | CVF_ANY_MODEL}},
	{"scalar", NULL, cf_i2ga_scalar, 1, {CVF_RHS | MVI_I2GA}},
	{"dual", NULL, cf_i2ga_dual, 1, {CVF_RHS | MVI_I2GA}},
	{"dual", NULL, cf_i2ga_dual2, 2, {CVF_RHS | MVI_I2GA, CVF_RHS | MVI_I2GA}},
	{"reverse", NULL, cf_i2ga_reverse, 1, {CVF_RHS | MVI_I2GA}},
	{"clifford_conjugate", NULL, cf_i2ga_clifford_conjugate, 1, {CVF_RHS | MVI_I2GA}},
	{"grade_involution", NULL, cf_i2ga_grade_involution, 1, {CVF_RHS | MVI_I2GA}},
	{"inverse", NULL, cf_i2ga_inverse, 1, {CVF_RHS | MVI_I2GA}},
	{"general_inverse", NULL, cf_i2ga_general_inverse, 1, {CVF_RHS | MVI_I2GA}},
	{"negate", NULL, cf_i2ga_negate, 1, {CVF_RHS | MVI_I2GA}},
	{"assign", NULL, cf_i2ga_assign, 2, {CVF_LHS | CVF_ANY_MODEL, CVF_RHS | MVI_I2GA}},
	{"gp", NULL, cf_i2ga_gp, 2, {CVF_RHS | MVI_I2GA, CVF_RHS | MVI_I2GA}},
	{"igp", NULL, cf_i2ga_igp, 2, {CVF_RHS | MVI_I2GA, CVF_RHS | MVI_I2GA}},
	{"op", NULL, cf_i2ga_op, 2, {CVF_RHS | MVI_I2GA, CVF_RHS | MVI_I2GA}},
	{"hip", NULL, cf_i2ga_hip, 2, {CVF_RHS | MVI_I2GA, CVF_RHS | MVI_I2GA}},
	{"mhip", NULL, cf_i2ga_mhip, 2, {CVF_RHS | MVI_I2GA, CVF_RHS | MVI_I2GA}},
	{"lcont", NULL, cf_i2ga_lcont, 2, {CVF_RHS | MVI_I2GA, CVF_RHS | MVI_I2GA}},
	{"rcont", NULL, cf_i2ga_rcont, 2, {CVF_RHS | MVI_I2GA, CVF_RHS | MVI_I2GA}},
	{"scp", NULL, cf_i2ga_scp, 2, {CVF_RHS | MVI_I2GA, CVF_RHS | MVI_I2GA}},
	{"gpem", NULL, cf_i2ga_gpem, 2, {CVF_RHS | MVI_I2GA, CVF_RHS | MVI_I2GA}},
	{"lcem", NULL, cf_i2ga_lcem, 2, {CVF_RHS | MVI_I2GA, CVF_RHS | MVI_I2GA}},
	{"meet", NULL, cf_i2ga_meet, 2, {CVF_RHS | MVI_I2GA, CVF_RHS | MVI_I2GA}},
	{"cp", NULL, cf_i2ga_cp, 2, {CVF_RHS | MVI_I2GA, CVF_RHS | MVI_I2GA}},
	{"join", NULL, cf_i2ga_join, 2, {CVF_RHS | MVI_I2GA, CVF_RHS | MVI_I2GA}},
	{"add", NULL, cf_i2ga_add, 2, {CVF_RHS | MVI_I2GA, CVF_RHS | MVI_I2GA}},
	{"sub", NULL, cf_i2ga_sub, 2, {CVF_RHS | MVI_I2GA, CVF_RHS | MVI_I2GA}},

	{"grade", NULL, cf_i2ga_grade_nb, 1, {CVF_RHS | MVI_I2GA}},
	{"grade", NULL, cf_i2ga_grade, 2, {CVF_RHS | MVI_I2GA, CVF_RHS | MVI_I2GA}},
	{"versor_parity", NULL, cf_i2ga_versor_parity, 1, {CVF_RHS | MVI_I2GA}},

	{"norm", NULL, cf_i2ga_norm, 1, {CVF_RHS | MVI_I2GA}},
	{"norm_2", NULL, cf_i2ga_norm_2, 1, {CVF_RHS | MVI_I2GA}},
	{"norm_r", NULL, cf_i2ga_norm_r, 1, {CVF_RHS | MVI_I2GA}},

	{"normalize", NULL, cf_i2ga_normalize, 1, {CVF_RHS | MVI_I2GA}},


	{"abs", NULL, cf_i2ga_abs, 1, {CVF_RHS | MVI_I2GA}},

	{"sqrt", NULL, cf_i2ga_sqrt, 1, {CVF_RHS | MVI_I2GA}},
	{"tan", NULL, cf_i2ga_tan, 1, {CVF_RHS | MVI_I2GA}},
	{"sin", NULL, cf_i2ga_sin, 1, {CVF_RHS | MVI_I2GA}},
	{"cos", NULL, cf_i2ga_cos, 1, {CVF_RHS | MVI_I2GA}},
	{"atan", NULL, cf_i2ga_atan, 1, {CVF_RHS | MVI_I2GA}},
	{"asin", NULL, cf_i2ga_asin, 1, {CVF_RHS | MVI_I2GA}},
	{"acos", NULL, cf_i2ga_acos, 1, {CVF_RHS | MVI_I2GA}},
	{"atan2", NULL, cf_i2ga_atan2, 2, {CVF_RHS | MVI_I2GA, CVF_RHS | MVI_I2GA}},
	{"cosh", NULL, cf_i2ga_cosh, 1, {CVF_RHS | MVI_I2GA}},
	{"sinh", NULL, cf_i2ga_sinh, 1, {CVF_RHS | MVI_I2GA}},
	{"acosh", NULL, cf_i2ga_acosh, 1, {CVF_RHS | MVI_I2GA}},
	{"asinh", NULL, cf_i2ga_asinh, 1, {CVF_RHS | MVI_I2GA}},
	{"sinc", NULL, cf_i2ga_sinc, 1, {CVF_RHS | MVI_I2GA}},
	{"log", NULL, cf_i2ga_log, 1, {CVF_RHS | MVI_I2GA}},
	{"exp", NULL, cf_i2ga_exp, 1, {CVF_RHS | MVI_I2GA}},
	{"pow", NULL, cf_i2ga_pow, 2, {CVF_RHS | MVI_I2GA, CVF_RHS | MVI_I2GA}},
	{"scalar_pow", NULL, cf_i2ga_scalar_pow, 2, {CVF_RHS | MVI_I2GA, CVF_RHS | MVI_I2GA}},
	{"max", NULL, cf_i2ga_max, 2, {CVF_RHS | MVI_I2GA, CVF_RHS | MVI_I2GA}},
	{"min", NULL, cf_i2ga_min, 2, {CVF_RHS | MVI_I2GA, CVF_RHS | MVI_I2GA}},
	
//	{"time", NULL, cf_i2ga_time, 0, {}},
	{"randSeed", NULL, cf_i2ga_randSeed, 1, {CVF_RHS | MVI_I2GA}},
	{"randGauss", NULL, cf_i2ga_randGauss, 2, {CVF_RHS | MVI_I2GA, CVF_RHS | MVI_I2GA}},
	
	{"versor_product", NULL, cf_i2ga_versorProduct, 2, {CVF_RHS | MVI_I2GA, CVF_RHS | MVI_I2GA}},
	{"inverse_versor_product", NULL, cf_i2ga_inverseVersorProduct, 2, {CVF_RHS | MVI_I2GA, CVF_RHS | MVI_I2GA}},
	{"vp", NULL, cf_i2ga_versorProduct, 2, {CVF_RHS | MVI_I2GA, CVF_RHS | MVI_I2GA}},
	{"ivp", NULL, cf_i2ga_inverseVersorProduct, 2, {CVF_RHS | MVI_I2GA, CVF_RHS | MVI_I2GA}},

	// temp mierenneuk version of versor product
	{"mnvp", NULL, cf_i2ga_MNversorProduct, 2, {CVF_RHS | MVI_I2GA, CVF_RHS | MVI_I2GA}},
	{"mnivp", NULL, cf_i2ga_MNinverseVersorProduct, 2, {CVF_RHS | MVI_I2GA, CVF_RHS | MVI_I2GA}},
	
	{"project", NULL, cf_i2ga_project, 2, {CVF_RHS | MVI_I2GA, CVF_RHS | MVI_I2GA}},
	{"reject", NULL, cf_i2ga_reject, 2, {CVF_RHS | MVI_I2GA, CVF_RHS | MVI_I2GA}},

	{"factor", NULL, cf_i2ga_factor, 2, {CVF_RHS | MVI_I2GA, CVF_RHS | MVI_I2GA}},

	{"set_factor", NULL, cf_i2ga_set_factor, 2, {CVF_RHS | CVF_ANY_MODEL, CVF_RHS | MVI_I2GA}},

	{"equal", NULL, cf_i2ga_equal, 2, {CVF_RHS | MVI_I2GA, CVF_RHS | MVI_I2GA}},
	{"ne", NULL, cf_i2ga_ne, 2, {CVF_RHS | MVI_I2GA, CVF_RHS | MVI_I2GA}},
	{"less", NULL, cf_i2ga_less, 2, {CVF_RHS | MVI_I2GA, CVF_RHS | MVI_I2GA}},
	{"greater", NULL, cf_i2ga_greater, 2, {CVF_RHS | MVI_I2GA, CVF_RHS | MVI_I2GA}},
	{"le", NULL, cf_i2ga_le, 2, {CVF_RHS | MVI_I2GA, CVF_RHS | MVI_I2GA}},
	{"ge", NULL, cf_i2ga_ge, 2, {CVF_RHS | MVI_I2GA, CVF_RHS | MVI_I2GA}},
	{"and", NULL, cf_i2ga_and, 2, {CVF_RHS | MVI_I2GA, CVF_RHS | MVI_I2GA}},
	{"or", NULL, cf_i2ga_or, 2, {CVF_RHS | MVI_I2GA, CVF_RHS | MVI_I2GA}},
	{"not", NULL, cf_i2ga_not, 1, {CVF_RHS | MVI_I2GA}},

/*
To add: 

To debug general inverse fails after one failure?
Or after multiple algebra use????
*/



	{"cast_e3ga", NULL, cf_e3ga_to_e3ga, 1, {CVF_RHS | MVI_E3GA}},

	{"cast_p3ga", NULL, cf_e3ga_to_p3ga, 1, {CVF_RHS | MVI_E3GA}},

	{"cast_c3ga", NULL, cf_e3ga_to_c3ga, 1, {CVF_RHS | MVI_E3GA}},

	{"cast_c5ga", NULL, cf_e3ga_to_c5ga, 1, {CVF_RHS | MVI_E3GA}},

	{"cast_i2ga", NULL, cf_e3ga_to_i2ga, 1, {CVF_RHS | MVI_E3GA}},

	{"cast_e3ga", NULL, cf_p3ga_to_e3ga, 1, {CVF_RHS | MVI_P3GA}},

	{"cast_p3ga", NULL, cf_p3ga_to_p3ga, 1, {CVF_RHS | MVI_P3GA}},

	{"cast_c3ga", NULL, cf_p3ga_to_c3ga, 1, {CVF_RHS | MVI_P3GA}},

	{"cast_c5ga", NULL, cf_p3ga_to_c5ga, 1, {CVF_RHS | MVI_P3GA}},

	{"cast_i2ga", NULL, cf_p3ga_to_i2ga, 1, {CVF_RHS | MVI_P3GA}},

	{"cast_e3ga", NULL, cf_c3ga_to_e3ga, 1, {CVF_RHS | MVI_C3GA}},

	{"cast_p3ga", NULL, cf_c3ga_to_p3ga, 1, {CVF_RHS | MVI_C3GA}},

	{"cast_c3ga", NULL, cf_c3ga_to_c3ga, 1, {CVF_RHS | MVI_C3GA}},

	{"cast_c5ga", NULL, cf_c3ga_to_c5ga, 1, {CVF_RHS | MVI_C3GA}},

	{"cast_i2ga", NULL, cf_c3ga_to_i2ga, 1, {CVF_RHS | MVI_C3GA}},

	{"cast_e3ga", NULL, cf_c5ga_to_e3ga, 1, {CVF_RHS | MVI_C5GA}},

	{"cast_p3ga", NULL, cf_c5ga_to_p3ga, 1, {CVF_RHS | MVI_C5GA}},

	{"cast_c3ga", NULL, cf_c5ga_to_c3ga, 1, {CVF_RHS | MVI_C5GA}},

	{"cast_c5ga", NULL, cf_c5ga_to_c5ga, 1, {CVF_RHS | MVI_C5GA}},

	{"cast_i2ga", NULL, cf_c5ga_to_i2ga, 1, {CVF_RHS | MVI_C5GA}},

	{"cast_e3ga", NULL, cf_i2ga_to_e3ga, 1, {CVF_RHS | MVI_I2GA}},

	{"cast_p3ga", NULL, cf_i2ga_to_p3ga, 1, {CVF_RHS | MVI_I2GA}},

	{"cast_c3ga", NULL, cf_i2ga_to_c3ga, 1, {CVF_RHS | MVI_I2GA}},

	{"cast_c5ga", NULL, cf_i2ga_to_c5ga, 1, {CVF_RHS | MVI_I2GA}},

	{"cast_i2ga", NULL, cf_i2ga_to_i2ga, 1, {CVF_RHS | MVI_I2GA}},

	{NULL, NULL, NULL, 0, NULL}
};
